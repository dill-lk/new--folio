"use strict";
(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
    [870], {
        2079: function(t, e, i) {
            let s;
            i.d(e, {
                $V: function() {
                    return of
                },
                $YQ: function() {
                    return ny
                },
                BFQ: function() {
                    return tZ
                },
                BG$: function() {
                    return ee
                },
                BVF: function() {
                    return U
                },
                Bf4: function() {
                    return tc
                },
                Bgp: function() {
                    return tn
                },
                BtG: function() {
                    return rp
                },
                CaW: function() {
                    return t$
                },
                CdI: function() {
                    return te
                },
                CtA: function() {
                    return tW
                },
                Cy: function() {
                    return F
                },
                D1R: function() {
                    return tv
                },
                D67: function() {
                    return ek
                },
                D9w: function() {
                    return tj
                },
                Djp: function() {
                    return et
                },
                DvJ: function() {
                    return rt
                },
                E2K: function() {
                    return tJ
                },
                EJi: function() {
                    return ax
                },
                EcG: function() {
                    return ox
                },
                EoG: function() {
                    return tt
                },
                F1y: function() {
                    return eB
                },
                F5T: function() {
                    return sP
                },
                FIo: function() {
                    return af
                },
                FM8: function() {
                    return e6
                },
                FUD: function() {
                    return eo
                },
                GG6: function() {
                    return en
                },
                GUF: function() {
                    return eA
                },
                Gih: function() {
                    return ea
                },
                H7L: function() {
                    return eF
                },
                HTn: function() {
                    return t3
                },
                HdW: function() {
                    return ed
                },
                HkE: function() {
                    return oe
                },
                Hy8: function() {
                    return P
                },
                I3e: function() {
                    return e$
                },
                IEO: function() {
                    return rI
                },
                ILR: function() {
                    return tX
                },
                INK: function() {
                    return t5
                },
                IOt: function() {
                    return ew
                },
                Ilk: function() {
                    return sB
                },
                JOQ: function() {
                    return rG
                },
                JQ4: function() {
                    return tT
                },
                JUT: function() {
                    return iv
                },
                Jjb: function() {
                    return eR
                },
                KI_: function() {
                    return ez
                },
                KhW: function() {
                    return O
                },
                Kj0: function() {
                    return s9
                },
                Kz5: function() {
                    return tA
                },
                LOc: function() {
                    return nf
                },
                LSk: function() {
                    return eL
                },
                LY2: function() {
                    return ts
                },
                LgZ: function() {
                    return N
                },
                LsT: function() {
                    return tz
                },
                Ltg: function() {
                    return ig
                },
                Lun: function() {
                    return aw
                },
                M$G: function() {
                    return eN
                },
                M5h: function() {
                    return M
                },
                M6v: function() {
                    return G
                },
                M8C: function() {
                    return e4
                },
                Mig: function() {
                    return a7
                },
                N$j: function() {
                    return rN
                },
                N4l: function() {
                    return b
                },
                NDo: function() {
                    return $
                },
                NKc: function() {
                    return j
                },
                NMF: function() {
                    return ex
                },
                NYV: function() {
                    return ei
                },
                NiX: function() {
                    return rf
                },
                Ns1: function() {
                    return H
                },
                O4K: function() {
                    return eZ
                },
                O5A: function() {
                    return ej
                },
                O78: function() {
                    return eP
                },
                O7d: function() {
                    return as
                },
                ORg: function() {
                    return ta
                },
                OTo: function() {
                    return tR
                },
                OdW: function() {
                    return rV
                },
                OoA: function() {
                    return ty
                },
                Ox3: function() {
                    return a6
                },
                PA7: function() {
                    return eS
                },
                PMe: function() {
                    return a1
                },
                Pa4: function() {
                    return e9
                },
                PeU: function() {
                    return o
                },
                QO2: function() {
                    return ep
                },
                QRU: function() {
                    return ot
                },
                Qey: function() {
                    return eY
                },
                QmN: function() {
                    return a
                },
                ROQ: function() {
                    return nm
                },
                Rhp: function() {
                    return ri
                },
                RlZ: function() {
                    return L
                },
                RsA: function() {
                    return n
                },
                S2y: function() {
                    return l
                },
                S9g: function() {
                    return i6
                },
                SPe: function() {
                    return rq
                },
                SUY: function() {
                    return oi
                },
                Se2: function() {
                    return W
                },
                Sm8: function() {
                    return A
                },
                SvJ: function() {
                    return el
                },
                Syv: function() {
                    return eg
                },
                T6w: function() {
                    return eV
                },
                T95: function() {
                    return tS
                },
                TUv: function() {
                    return rB
                },
                TlE: function() {
                    return sF
                },
                Tme: function() {
                    return sp
                },
                TyD: function() {
                    return tf
                },
                UCm: function() {
                    return tV
                },
                USm: function() {
                    return i4
                },
                UY4: function() {
                    return no
                },
                UZH: function() {
                    return r
                },
                UlW: function() {
                    return eM
                },
                Vdb: function() {
                    return R
                },
                Vkp: function() {
                    return ie
                },
                VzW: function() {
                    return tC
                },
                WMw: function() {
                    return x
                },
                Wbm: function() {
                    return S
                },
                Wid: function() {
                    return ag
                },
                Wl3: function() {
                    return d
                },
                Wpd: function() {
                    return V
                },
                WwZ: function() {
                    return eb
                },
                Xaj: function() {
                    return v
                },
                XvJ: function() {
                    return ad
                },
                YBi: function() {
                    return t4
                },
                YBo: function() {
                    return aM
                },
                YGz: function() {
                    return ti
                },
                YLQ: function() {
                    return tg
                },
                ZAu: function() {
                    return rm
                },
                ZK6: function() {
                    return eJ
                },
                ZTh: function() {
                    return ey
                },
                ZXd: function() {
                    return og
                },
                Zen: function() {
                    return eI
                },
                Zp0: function() {
                    return a9
                },
                Zr5: function() {
                    return J
                },
                ZzF: function() {
                    return iw
                },
                _12: function() {
                    return ah
                },
                _AM: function() {
                    return tG
                },
                _C8: function() {
                    return aA
                },
                _Li: function() {
                    return m
                },
                _RZ: function() {
                    return eE
                },
                _fP: function() {
                    return e7
                },
                _iA: function() {
                    return u
                },
                _wr: function() {
                    return E
                },
                a$l: function() {
                    return sU
                },
                aCh: function() {
                    return e_
                },
                aH4: function() {
                    return tx
                },
                aLr: function() {
                    return iD
                },
                aNw: function() {
                    return aU
                },
                av9: function() {
                    return tU
                },
                b7q: function() {
                    return t2
                },
                bGH: function() {
                    return w
                },
                bdR: function() {
                    return g
                },
                blk: function() {
                    return na
                },
                bnF: function() {
                    return nZ
                },
                brP: function() {
                    return tF
                },
                bsb: function() {
                    return eu
                },
                c8b: function() {
                    return T
                },
                cLu: function() {
                    return tO
                },
                cM7: function() {
                    return eW
                },
                cPb: function() {
                    return ru
                },
                cac: function() {
                    return eD
                },
                cek: function() {
                    return a3
                },
                dSO: function() {
                    return tu
                },
                dUE: function() {
                    return aI
                },
                dVD: function() {
                    return tP
                },
                dZ3: function() {
                    return tr
                },
                dd2: function() {
                    return ib
                },
                dpR: function() {
                    return aX
                },
                dwf: function() {
                    return re
                },
                dwk: function() {
                    return p
                },
                eD: function() {
                    return Z
                },
                eaV: function() {
                    return tQ
                },
                ehD: function() {
                    return y
                },
                ejS: function() {
                    return nn
                },
                ekQ: function() {
                    return t1
                },
                epp: function() {
                    return ia
                },
                f2y: function() {
                    return ec
                },
                fSK: function() {
                    return I
                },
                fY$: function() {
                    return th
                },
                fto: function() {
                    return tK
                },
                g8_: function() {
                    return tp
                },
                ghN: function() {
                    return C
                },
                gi4: function() {
                    return t8
                },
                hEm: function() {
                    return tD
                },
                hH6: function() {
                    return aq
                },
                iAb: function() {
                    return t_
                },
                iKG: function() {
                    return a5
                },
                iLg: function() {
                    return aR
                },
                iMs: function() {
                    return od
                },
                iUV: function() {
                    return oc
                },
                iWC: function() {
                    return k
                },
                iWj: function() {
                    return rK
                },
                iiP: function() {
                    return eh
                },
                irR: function() {
                    return tB
                },
                j17: function() {
                    return eC
                },
                jFi: function() {
                    return f
                },
                jZA: function() {
                    return t7
                },
                jes: function() {
                    return D
                },
                jyz: function() {
                    return rn
                },
                k0A: function() {
                    return tk
                },
                k74: function() {
                    return B
                },
                kB5: function() {
                    return rv
                },
                ksN: function() {
                    return Y
                },
                l0P: function() {
                    return t0
                },
                l6D: function() {
                    return eT
                },
                lCJ: function() {
                    return sj
                },
                lGU: function() {
                    return ef
                },
                lRF: function() {
                    return av
                },
                lb7: function() {
                    return rL
                },
                m7l: function() {
                    return aE
                },
                nls: function() {
                    return r3
                },
                ntZ: function() {
                    return c
                },
                oAp: function() {
                    return rd
                },
                oDz: function() {
                    return rs
                },
                p3g: function() {
                    return iM
                },
                pBf: function() {
                    return eX
                },
                pKu: function() {
                    return er
                },
                ptH: function() {
                    return t6
                },
                qhX: function() {
                    return Q
                },
                qkB: function() {
                    return tE
                },
                qlB: function() {
                    return sD
                },
                qyh: function() {
                    return tM
                },
                rDY: function() {
                    return rr
                },
                rOj: function() {
                    return _
                },
                r_: function() {
                    return z
                },
                rpg: function() {
                    return td
                },
                tQZ: function() {
                    return tI
                },
                tm_: function() {
                    return h
                },
                u9r: function() {
                    return sH
                },
                uL9: function() {
                    return K
                },
                uWy: function() {
                    return tm
                },
                v3W: function() {
                    return tY
                },
                vBJ: function() {
                    return sR
                },
                vCF: function() {
                    return q
                },
                vCx: function() {
                    return tH
                },
                vUy: function() {
                    return eq
                },
                vpT: function() {
                    return rb
                },
                vuL: function() {
                    return em
                },
                vxC: function() {
                    return tl
                },
                w$m: function() {
                    return X
                },
                wJv: function() {
                    return tN
                },
                wem: function() {
                    return tb
                },
                wk1: function() {
                    return tL
                },
                woe: function() {
                    return np
                },
                wuA: function() {
                    return tq
                },
                x12: function() {
                    return ne
                },
                xEZ: function() {
                    return iy
                },
                xJs: function() {
                    return es
                },
                xnb: function() {
                    return ng
                },
                xoQ: function() {
                    return eO
                },
                xoR: function() {
                    return ab
                },
                xsS: function() {
                    return rx
                },
                y2t: function() {
                    return t9
                },
                yC1: function() {
                    return aL
                },
                yGw: function() {
                    return iG
                },
                yo9: function() {
                    return rg
                },
                ywz: function() {
                    return tw
                },
                z$h: function() {
                    return ev
                },
                zHn: function() {
                    return iX
                }
            });
            let r = "182",
                n = {
                    LEFT: 0,
                    MIDDLE: 1,
                    RIGHT: 2,
                    ROTATE: 0,
                    DOLLY: 1,
                    PAN: 2
                },
                a = {
                    ROTATE: 0,
                    PAN: 1,
                    DOLLY_PAN: 2,
                    DOLLY_ROTATE: 3
                },
                o = 0,
                h = 1,
                l = 2,
                u = 1,
                c = 2,
                p = 3,
                d = 0,
                m = 1,
                y = 2,
                f = 0,
                g = 1,
                x = 2,
                b = 3,
                M = 4,
                v = 5,
                w = 100,
                S = 101,
                _ = 102,
                z = 103,
                A = 104,
                T = 200,
                C = 201,
                O = 202,
                k = 203,
                B = 204,
                N = 205,
                I = 206,
                P = 207,
                R = 208,
                V = 209,
                L = 210,
                E = 211,
                F = 212,
                D = 213,
                j = 214,
                U = 0,
                W = 1,
                J = 2,
                q = 3,
                Z = 4,
                Y = 5,
                X = 6,
                G = 7,
                H = 0,
                Q = 1,
                $ = 2,
                K = 0,
                tt = 1,
                te = 2,
                ti = 3,
                ts = 4,
                tr = 5,
                tn = 6,
                ta = 7,
                to = "attached",
                th = 301,
                tl = 302,
                tu = 303,
                tc = 304,
                tp = 306,
                td = 1e3,
                tm = 1001,
                ty = 1002,
                tf = 1003,
                tg = 1004,
                tx = 1005,
                tb = 1006,
                tM = 1007,
                tv = 1008,
                tw = 1009,
                tS = 1010,
                t_ = 1011,
                tz = 1012,
                tA = 1013,
                tT = 1014,
                tC = 1015,
                tO = 1016,
                tk = 1017,
                tB = 1018,
                tN = 1020,
                tI = 35902,
                tP = 35899,
                tR = 1021,
                tV = 1022,
                tL = 1023,
                tE = 1026,
                tF = 1027,
                tD = 1028,
                tj = 1029,
                tU = 1030,
                tW = 1031,
                tJ = 1033,
                tq = 33776,
                tZ = 33777,
                tY = 33778,
                tX = 33779,
                tG = 35840,
                tH = 35841,
                tQ = 35842,
                t$ = 35843,
                tK = 36196,
                t0 = 37492,
                t1 = 37496,
                t2 = 37488,
                t3 = 37489,
                t5 = 37490,
                t4 = 37491,
                t6 = 37808,
                t7 = 37809,
                t9 = 37810,
                t8 = 37811,
                et = 37812,
                ee = 37813,
                ei = 37814,
                es = 37815,
                er = 37816,
                en = 37817,
                ea = 37818,
                eo = 37819,
                eh = 37820,
                el = 37821,
                eu = 36492,
                ec = 36494,
                ep = 36495,
                ed = 36283,
                em = 36284,
                ey = 36285,
                ef = 36286,
                eg = 2300,
                ex = 2301,
                eb = 0,
                eM = 1,
                ev = 2,
                ew = 0,
                eS = 1,
                e_ = "",
                ez = "srgb",
                eA = "srgb-linear",
                eT = "linear",
                eC = "srgb",
                eO = 512,
                ek = 513,
                eB = 514,
                eN = 515,
                eI = 516,
                eP = 517,
                eR = 518,
                eV = 519,
                eL = "300 es",
                eE = 2e3;

            function eF(t) {
                for (let e = t.length - 1; e >= 0; --e)
                    if (t[e] >= 65535) return !0;
                return !1
            }

            function eD(t) {
                return document.createElementNS("http://www.w3.org/1999/xhtml", t)
            }

            function ej() {
                let t = eD("canvas");
                return t.style.display = "block", t
            }
            Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
            let eU = {};

            function eW(...t) {
                console.log("THREE." + t.shift(), ...t)
            }

            function eJ(...t) {
                console.warn("THREE." + t.shift(), ...t)
            }

            function eq(...t) {
                console.error("THREE." + t.shift(), ...t)
            }

            function eZ(...t) {
                let e = t.join(" ");
                e in eU || (eU[e] = !0, eJ(...t))
            }

            function eY(t, e, i) {
                return new Promise(function(s, r) {
                    setTimeout(function n() {
                        switch (t.clientWaitSync(e, t.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                            case t.WAIT_FAILED:
                                r();
                                break;
                            case t.TIMEOUT_EXPIRED:
                                setTimeout(n, i);
                                break;
                            default:
                                s()
                        }
                    }, i)
                })
            }
            class eX {
                addEventListener(t, e) {
                    void 0 === this._listeners && (this._listeners = {});
                    let i = this._listeners;
                    void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e)
                }
                hasEventListener(t, e) {
                    let i = this._listeners;
                    return void 0 !== i && void 0 !== i[t] && -1 !== i[t].indexOf(e)
                }
                removeEventListener(t, e) {
                    let i = this._listeners;
                    if (void 0 === i) return;
                    let s = i[t];
                    if (void 0 !== s) {
                        let t = s.indexOf(e); - 1 !== t && s.splice(t, 1)
                    }
                }
                dispatchEvent(t) {
                    let e = this._listeners;
                    if (void 0 === e) return;
                    let i = e[t.type];
                    if (void 0 !== i) {
                        t.target = this;
                        let e = i.slice(0);
                        for (let i = 0, s = e.length; i < s; i++) e[i].call(this, t);
                        t.target = null
                    }
                }
            }
            let eG = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"],
                eH = 1234567,
                eQ = Math.PI / 180,
                e$ = 180 / Math.PI;

            function eK() {
                let t = 4294967295 * Math.random() | 0,
                    e = 4294967295 * Math.random() | 0,
                    i = 4294967295 * Math.random() | 0,
                    s = 4294967295 * Math.random() | 0;
                return (eG[255 & t] + eG[t >> 8 & 255] + eG[t >> 16 & 255] + eG[t >> 24 & 255] + "-" + eG[255 & e] + eG[e >> 8 & 255] + "-" + eG[e >> 16 & 15 | 64] + eG[e >> 24 & 255] + "-" + eG[63 & i | 128] + eG[i >> 8 & 255] + "-" + eG[i >> 16 & 255] + eG[i >> 24 & 255] + eG[255 & s] + eG[s >> 8 & 255] + eG[s >> 16 & 255] + eG[s >> 24 & 255]).toLowerCase()
            }

            function e0(t, e, i) {
                return Math.max(e, Math.min(i, t))
            }

            function e1(t, e) {
                return (t % e + e) % e
            }

            function e2(t, e, i) {
                return (1 - i) * t + i * e
            }

            function e3(t, e) {
                switch (e.constructor) {
                    case Float32Array:
                        return t;
                    case Uint32Array:
                        return t / 4294967295;
                    case Uint16Array:
                        return t / 65535;
                    case Uint8Array:
                        return t / 255;
                    case Int32Array:
                        return Math.max(t / 2147483647, -1);
                    case Int16Array:
                        return Math.max(t / 32767, -1);
                    case Int8Array:
                        return Math.max(t / 127, -1);
                    default:
                        throw Error("Invalid component type.")
                }
            }

            function e5(t, e) {
                switch (e.constructor) {
                    case Float32Array:
                        return t;
                    case Uint32Array:
                        return Math.round(4294967295 * t);
                    case Uint16Array:
                        return Math.round(65535 * t);
                    case Uint8Array:
                        return Math.round(255 * t);
                    case Int32Array:
                        return Math.round(2147483647 * t);
                    case Int16Array:
                        return Math.round(32767 * t);
                    case Int8Array:
                        return Math.round(127 * t);
                    default:
                        throw Error("Invalid component type.")
                }
            }
            let e4 = {
                DEG2RAD: eQ,
                RAD2DEG: e$,
                generateUUID: eK,
                clamp: e0,
                euclideanModulo: e1,
                mapLinear: function(t, e, i, s, r) {
                    return s + (t - e) * (r - s) / (i - e)
                },
                inverseLerp: function(t, e, i) {
                    return t !== e ? (i - t) / (e - t) : 0
                },
                lerp: e2,
                damp: function(t, e, i, s) {
                    return e2(t, e, 1 - Math.exp(-i * s))
                },
                pingpong: function(t, e = 1) {
                    return e - Math.abs(e1(t, 2 * e) - e)
                },
                smoothstep: function(t, e, i) {
                    return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t)
                },
                smootherstep: function(t, e, i) {
                    return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10)
                },
                randInt: function(t, e) {
                    return t + Math.floor(Math.random() * (e - t + 1))
                },
                randFloat: function(t, e) {
                    return t + Math.random() * (e - t)
                },
                randFloatSpread: function(t) {
                    return t * (.5 - Math.random())
                },
                seededRandom: function(t) {
                    void 0 !== t && (eH = t);
                    let e = eH += 1831565813;
                    return e = Math.imul(e ^ e >>> 15, 1 | e), (((e ^= e + Math.imul(e ^ e >>> 7, 61 | e)) ^ e >>> 14) >>> 0) / 4294967296
                },
                degToRad: function(t) {
                    return t * eQ
                },
                radToDeg: function(t) {
                    return t * e$
                },
                isPowerOfTwo: function(t) {
                    return (t & t - 1) == 0 && 0 !== t
                },
                ceilPowerOfTwo: function(t) {
                    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
                },
                floorPowerOfTwo: function(t) {
                    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                },
                setQuaternionFromProperEuler: function(t, e, i, s, r) {
                    let n = Math.cos,
                        a = Math.sin,
                        o = n(i / 2),
                        h = a(i / 2),
                        l = n((e + s) / 2),
                        u = a((e + s) / 2),
                        c = n((e - s) / 2),
                        p = a((e - s) / 2),
                        d = n((s - e) / 2),
                        m = a((s - e) / 2);
                    switch (r) {
                        case "XYX":
                            t.set(o * u, h * c, h * p, o * l);
                            break;
                        case "YZY":
                            t.set(h * p, o * u, h * c, o * l);
                            break;
                        case "ZXZ":
                            t.set(h * c, h * p, o * u, o * l);
                            break;
                        case "XZX":
                            t.set(o * u, h * m, h * d, o * l);
                            break;
                        case "YXY":
                            t.set(h * d, o * u, h * m, o * l);
                            break;
                        case "ZYZ":
                            t.set(h * m, h * d, o * u, o * l);
                            break;
                        default:
                            eJ("MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                    }
                },
                normalize: e5,
                denormalize: e3
            };
            class e6 {
                constructor(t = 0, e = 0) {
                    e6.prototype.isVector2 = !0, this.x = t, this.y = e
                }
                get width() {
                    return this.x
                }
                set width(t) {
                    this.x = t
                }
                get height() {
                    return this.y
                }
                set height(t) {
                    this.y = t
                }
                set(t, e) {
                    return this.x = t, this.y = e, this
                }
                setScalar(t) {
                    return this.x = t, this.y = t, this
                }
                setX(t) {
                    return this.x = t, this
                }
                setY(t) {
                    return this.y = t, this
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        default:
                            throw Error("index is out of range: " + t)
                    }
                    return this
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw Error("index is out of range: " + t)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y)
                }
                copy(t) {
                    return this.x = t.x, this.y = t.y, this
                }
                add(t) {
                    return this.x += t.x, this.y += t.y, this
                }
                addScalar(t) {
                    return this.x += t, this.y += t, this
                }
                addVectors(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this
                }
                addScaledVector(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this
                }
                sub(t) {
                    return this.x -= t.x, this.y -= t.y, this
                }
                subScalar(t) {
                    return this.x -= t, this.y -= t, this
                }
                subVectors(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this
                }
                multiply(t) {
                    return this.x *= t.x, this.y *= t.y, this
                }
                multiplyScalar(t) {
                    return this.x *= t, this.y *= t, this
                }
                divide(t) {
                    return this.x /= t.x, this.y /= t.y, this
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t)
                }
                applyMatrix3(t) {
                    let e = this.x,
                        i = this.y,
                        s = t.elements;
                    return this.x = s[0] * e + s[3] * i + s[6], this.y = s[1] * e + s[4] * i + s[7], this
                }
                min(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
                }
                max(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
                }
                clamp(t, e) {
                    return this.x = e0(this.x, t.x, e.x), this.y = e0(this.y, t.y, e.y), this
                }
                clampScalar(t, e) {
                    return this.x = e0(this.x, t, e), this.y = e0(this.y, t, e), this
                }
                clampLength(t, e) {
                    let i = this.length();
                    return this.divideScalar(i || 1).multiplyScalar(e0(i, t, e))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                }
                roundToZero() {
                    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y
                }
                cross(t) {
                    return this.x * t.y - this.y * t.x
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                angle() {
                    return Math.atan2(-this.y, -this.x) + Math.PI
                }
                angleTo(t) {
                    let e = Math.sqrt(this.lengthSq() * t.lengthSq());
                    return 0 === e ? Math.PI / 2 : Math.acos(e0(this.dot(t) / e, -1, 1))
                }
                distanceTo(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                }
                distanceToSquared(t) {
                    let e = this.x - t.x,
                        i = this.y - t.y;
                    return e * e + i * i
                }
                manhattanDistanceTo(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t)
                }
                lerp(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
                }
                lerpVectors(t, e, i) {
                    return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y
                }
                fromArray(t, e = 0) {
                    return this.x = t[e], this.y = t[e + 1], this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this.x, t[e + 1] = this.y, t
                }
                fromBufferAttribute(t, e) {
                    return this.x = t.getX(e), this.y = t.getY(e), this
                }
                rotateAround(t, e) {
                    let i = Math.cos(e),
                        s = Math.sin(e),
                        r = this.x - t.x,
                        n = this.y - t.y;
                    return this.x = r * i - n * s + t.x, this.y = r * s + n * i + t.y, this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y
                }
            }
            class e7 {
                constructor(t = 0, e = 0, i = 0, s = 1) {
                    this.isQuaternion = !0, this._x = t, this._y = e, this._z = i, this._w = s
                }
                static slerpFlat(t, e, i, s, r, n, a) {
                    let o = i[s + 0],
                        h = i[s + 1],
                        l = i[s + 2],
                        u = i[s + 3],
                        c = r[n + 0],
                        p = r[n + 1],
                        d = r[n + 2],
                        m = r[n + 3];
                    if (a <= 0) {
                        t[e + 0] = o, t[e + 1] = h, t[e + 2] = l, t[e + 3] = u;
                        return
                    }
                    if (a >= 1) {
                        t[e + 0] = c, t[e + 1] = p, t[e + 2] = d, t[e + 3] = m;
                        return
                    }
                    if (u !== m || o !== c || h !== p || l !== d) {
                        let t = o * c + h * p + l * d + u * m;
                        t < 0 && (c = -c, p = -p, d = -d, m = -m, t = -t);
                        let e = 1 - a;
                        if (t < .9995) {
                            let i = Math.acos(t),
                                s = Math.sin(i);
                            o = o * (e = Math.sin(e * i) / s) + c * (a = Math.sin(a * i) / s), h = h * e + p * a, l = l * e + d * a, u = u * e + m * a
                        } else {
                            let t = 1 / Math.sqrt((o = o * e + c * a) * o + (h = h * e + p * a) * h + (l = l * e + d * a) * l + (u = u * e + m * a) * u);
                            o *= t, h *= t, l *= t, u *= t
                        }
                    }
                    t[e] = o, t[e + 1] = h, t[e + 2] = l, t[e + 3] = u
                }
                static multiplyQuaternionsFlat(t, e, i, s, r, n) {
                    let a = i[s],
                        o = i[s + 1],
                        h = i[s + 2],
                        l = i[s + 3],
                        u = r[n],
                        c = r[n + 1],
                        p = r[n + 2],
                        d = r[n + 3];
                    return t[e] = a * d + l * u + o * p - h * c, t[e + 1] = o * d + l * c + h * u - a * p, t[e + 2] = h * d + l * p + a * c - o * u, t[e + 3] = l * d - a * u - o * c - h * p, t
                }
                get x() {
                    return this._x
                }
                set x(t) {
                    this._x = t, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(t) {
                    this._y = t, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(t) {
                    this._z = t, this._onChangeCallback()
                }
                get w() {
                    return this._w
                }
                set w(t) {
                    this._w = t, this._onChangeCallback()
                }
                set(t, e, i, s) {
                    return this._x = t, this._y = e, this._z = i, this._w = s, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                }
                copy(t) {
                    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
                }
                setFromEuler(t, e = !0) {
                    let i = t._x,
                        s = t._y,
                        r = t._z,
                        n = t._order,
                        a = Math.cos,
                        o = Math.sin,
                        h = a(i / 2),
                        l = a(s / 2),
                        u = a(r / 2),
                        c = o(i / 2),
                        p = o(s / 2),
                        d = o(r / 2);
                    switch (n) {
                        case "XYZ":
                            this._x = c * l * u + h * p * d, this._y = h * p * u - c * l * d, this._z = h * l * d + c * p * u, this._w = h * l * u - c * p * d;
                            break;
                        case "YXZ":
                            this._x = c * l * u + h * p * d, this._y = h * p * u - c * l * d, this._z = h * l * d - c * p * u, this._w = h * l * u + c * p * d;
                            break;
                        case "ZXY":
                            this._x = c * l * u - h * p * d, this._y = h * p * u + c * l * d, this._z = h * l * d + c * p * u, this._w = h * l * u - c * p * d;
                            break;
                        case "ZYX":
                            this._x = c * l * u - h * p * d, this._y = h * p * u + c * l * d, this._z = h * l * d - c * p * u, this._w = h * l * u + c * p * d;
                            break;
                        case "YZX":
                            this._x = c * l * u + h * p * d, this._y = h * p * u + c * l * d, this._z = h * l * d - c * p * u, this._w = h * l * u - c * p * d;
                            break;
                        case "XZY":
                            this._x = c * l * u - h * p * d, this._y = h * p * u - c * l * d, this._z = h * l * d + c * p * u, this._w = h * l * u + c * p * d;
                            break;
                        default:
                            eJ("Quaternion: .setFromEuler() encountered an unknown order: " + n)
                    }
                    return !0 === e && this._onChangeCallback(), this
                }
                setFromAxisAngle(t, e) {
                    let i = e / 2,
                        s = Math.sin(i);
                    return this._x = t.x * s, this._y = t.y * s, this._z = t.z * s, this._w = Math.cos(i), this._onChangeCallback(), this
                }
                setFromRotationMatrix(t) {
                    let e = t.elements,
                        i = e[0],
                        s = e[4],
                        r = e[8],
                        n = e[1],
                        a = e[5],
                        o = e[9],
                        h = e[2],
                        l = e[6],
                        u = e[10],
                        c = i + a + u;
                    if (c > 0) {
                        let t = .5 / Math.sqrt(c + 1);
                        this._w = .25 / t, this._x = (l - o) * t, this._y = (r - h) * t, this._z = (n - s) * t
                    } else if (i > a && i > u) {
                        let t = 2 * Math.sqrt(1 + i - a - u);
                        this._w = (l - o) / t, this._x = .25 * t, this._y = (s + n) / t, this._z = (r + h) / t
                    } else if (a > u) {
                        let t = 2 * Math.sqrt(1 + a - i - u);
                        this._w = (r - h) / t, this._x = (s + n) / t, this._y = .25 * t, this._z = (o + l) / t
                    } else {
                        let t = 2 * Math.sqrt(1 + u - i - a);
                        this._w = (n - s) / t, this._x = (r + h) / t, this._y = (o + l) / t, this._z = .25 * t
                    }
                    return this._onChangeCallback(), this
                }
                setFromUnitVectors(t, e) {
                    let i = t.dot(e) + 1;
                    return i < 1e-8 ? (i = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0) : (this._x = 0, this._y = -t.z, this._z = t.y)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x), this._w = i, this.normalize()
                }
                angleTo(t) {
                    return 2 * Math.acos(Math.abs(e0(this.dot(t), -1, 1)))
                }
                rotateTowards(t, e) {
                    let i = this.angleTo(t);
                    return 0 === i || this.slerp(t, Math.min(1, e / i)), this
                }
                identity() {
                    return this.set(0, 0, 0, 1)
                }
                invert() {
                    return this.conjugate()
                }
                conjugate() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                }
                dot(t) {
                    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
                }
                lengthSq() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                }
                length() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                }
                normalize() {
                    let t = this.length();
                    return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
                }
                multiply(t) {
                    return this.multiplyQuaternions(this, t)
                }
                premultiply(t) {
                    return this.multiplyQuaternions(t, this)
                }
                multiplyQuaternions(t, e) {
                    let i = t._x,
                        s = t._y,
                        r = t._z,
                        n = t._w,
                        a = e._x,
                        o = e._y,
                        h = e._z,
                        l = e._w;
                    return this._x = i * l + n * a + s * h - r * o, this._y = s * l + n * o + r * a - i * h, this._z = r * l + n * h + i * o - s * a, this._w = n * l - i * a - s * o - r * h, this._onChangeCallback(), this
                }
                slerp(t, e) {
                    if (e <= 0) return this;
                    if (e >= 1) return this.copy(t);
                    let i = t._x,
                        s = t._y,
                        r = t._z,
                        n = t._w,
                        a = this.dot(t);
                    a < 0 && (i = -i, s = -s, r = -r, n = -n, a = -a);
                    let o = 1 - e;
                    if (a < .9995) {
                        let t = Math.acos(a),
                            h = Math.sin(t);
                        o = Math.sin(o * t) / h, e = Math.sin(e * t) / h, this._x = this._x * o + i * e, this._y = this._y * o + s * e, this._z = this._z * o + r * e, this._w = this._w * o + n * e, this._onChangeCallback()
                    } else this._x = this._x * o + i * e, this._y = this._y * o + s * e, this._z = this._z * o + r * e, this._w = this._w * o + n * e, this.normalize();
                    return this
                }
                slerpQuaternions(t, e, i) {
                    return this.copy(t).slerp(e, i)
                }
                random() {
                    let t = 2 * Math.PI * Math.random(),
                        e = 2 * Math.PI * Math.random(),
                        i = Math.random(),
                        s = Math.sqrt(1 - i),
                        r = Math.sqrt(i);
                    return this.set(s * Math.sin(t), s * Math.cos(t), r * Math.sin(e), r * Math.cos(e))
                }
                equals(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
                }
                fromArray(t, e = 0) {
                    return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
                }
                fromBufferAttribute(t, e) {
                    return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this._onChangeCallback(), this
                }
                toJSON() {
                    return this.toArray()
                }
                _onChange(t) {
                    return this._onChangeCallback = t, this
                }
                _onChangeCallback() {}*[Symbol.iterator]() {
                    yield this._x, yield this._y, yield this._z, yield this._w
                }
            }
            class e9 {
                constructor(t = 0, e = 0, i = 0) {
                    e9.prototype.isVector3 = !0, this.x = t, this.y = e, this.z = i
                }
                set(t, e, i) {
                    return void 0 === i && (i = this.z), this.x = t, this.y = e, this.z = i, this
                }
                setScalar(t) {
                    return this.x = t, this.y = t, this.z = t, this
                }
                setX(t) {
                    return this.x = t, this
                }
                setY(t) {
                    return this.y = t, this
                }
                setZ(t) {
                    return this.z = t, this
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        default:
                            throw Error("index is out of range: " + t)
                    }
                    return this
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw Error("index is out of range: " + t)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z)
                }
                copy(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this
                }
                add(t) {
                    return this.x += t.x, this.y += t.y, this.z += t.z, this
                }
                addScalar(t) {
                    return this.x += t, this.y += t, this.z += t, this
                }
                addVectors(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
                }
                addScaledVector(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
                }
                sub(t) {
                    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this
                }
                subScalar(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this
                }
                subVectors(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
                }
                multiply(t) {
                    return this.x *= t.x, this.y *= t.y, this.z *= t.z, this
                }
                multiplyScalar(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this
                }
                multiplyVectors(t, e) {
                    return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
                }
                applyEuler(t) {
                    return this.applyQuaternion(it.setFromEuler(t))
                }
                applyAxisAngle(t, e) {
                    return this.applyQuaternion(it.setFromAxisAngle(t, e))
                }
                applyMatrix3(t) {
                    let e = this.x,
                        i = this.y,
                        s = this.z,
                        r = t.elements;
                    return this.x = r[0] * e + r[3] * i + r[6] * s, this.y = r[1] * e + r[4] * i + r[7] * s, this.z = r[2] * e + r[5] * i + r[8] * s, this
                }
                applyNormalMatrix(t) {
                    return this.applyMatrix3(t).normalize()
                }
                applyMatrix4(t) {
                    let e = this.x,
                        i = this.y,
                        s = this.z,
                        r = t.elements,
                        n = 1 / (r[3] * e + r[7] * i + r[11] * s + r[15]);
                    return this.x = (r[0] * e + r[4] * i + r[8] * s + r[12]) * n, this.y = (r[1] * e + r[5] * i + r[9] * s + r[13]) * n, this.z = (r[2] * e + r[6] * i + r[10] * s + r[14]) * n, this
                }
                applyQuaternion(t) {
                    let e = this.x,
                        i = this.y,
                        s = this.z,
                        r = t.x,
                        n = t.y,
                        a = t.z,
                        o = t.w,
                        h = 2 * (n * s - a * i),
                        l = 2 * (a * e - r * s),
                        u = 2 * (r * i - n * e);
                    return this.x = e + o * h + n * u - a * l, this.y = i + o * l + a * h - r * u, this.z = s + o * u + r * l - n * h, this
                }
                project(t) {
                    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
                }
                unproject(t) {
                    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
                }
                transformDirection(t) {
                    let e = this.x,
                        i = this.y,
                        s = this.z,
                        r = t.elements;
                    return this.x = r[0] * e + r[4] * i + r[8] * s, this.y = r[1] * e + r[5] * i + r[9] * s, this.z = r[2] * e + r[6] * i + r[10] * s, this.normalize()
                }
                divide(t) {
                    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t)
                }
                min(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
                }
                max(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
                }
                clamp(t, e) {
                    return this.x = e0(this.x, t.x, e.x), this.y = e0(this.y, t.y, e.y), this.z = e0(this.z, t.z, e.z), this
                }
                clampScalar(t, e) {
                    return this.x = e0(this.x, t, e), this.y = e0(this.y, t, e), this.z = e0(this.z, t, e), this
                }
                clampLength(t, e) {
                    let i = this.length();
                    return this.divideScalar(i || 1).multiplyScalar(e0(i, t, e))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                }
                roundToZero() {
                    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t)
                }
                lerp(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
                }
                lerpVectors(t, e, i) {
                    return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this
                }
                cross(t) {
                    return this.crossVectors(this, t)
                }
                crossVectors(t, e) {
                    let i = t.x,
                        s = t.y,
                        r = t.z,
                        n = e.x,
                        a = e.y,
                        o = e.z;
                    return this.x = s * o - r * a, this.y = r * n - i * o, this.z = i * a - s * n, this
                }
                projectOnVector(t) {
                    let e = t.lengthSq();
                    if (0 === e) return this.set(0, 0, 0);
                    let i = t.dot(this) / e;
                    return this.copy(t).multiplyScalar(i)
                }
                projectOnPlane(t) {
                    return e8.copy(this).projectOnVector(t), this.sub(e8)
                }
                reflect(t) {
                    return this.sub(e8.copy(t).multiplyScalar(2 * this.dot(t)))
                }
                angleTo(t) {
                    let e = Math.sqrt(this.lengthSq() * t.lengthSq());
                    return 0 === e ? Math.PI / 2 : Math.acos(e0(this.dot(t) / e, -1, 1))
                }
                distanceTo(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                }
                distanceToSquared(t) {
                    let e = this.x - t.x,
                        i = this.y - t.y,
                        s = this.z - t.z;
                    return e * e + i * i + s * s
                }
                manhattanDistanceTo(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
                }
                setFromSpherical(t) {
                    return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
                }
                setFromSphericalCoords(t, e, i) {
                    let s = Math.sin(e) * t;
                    return this.x = s * Math.sin(i), this.y = Math.cos(e) * t, this.z = s * Math.cos(i), this
                }
                setFromCylindrical(t) {
                    return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
                }
                setFromCylindricalCoords(t, e, i) {
                    return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this
                }
                setFromMatrixPosition(t) {
                    let e = t.elements;
                    return this.x = e[12], this.y = e[13], this.z = e[14], this
                }
                setFromMatrixScale(t) {
                    let e = this.setFromMatrixColumn(t, 0).length(),
                        i = this.setFromMatrixColumn(t, 1).length(),
                        s = this.setFromMatrixColumn(t, 2).length();
                    return this.x = e, this.y = i, this.z = s, this
                }
                setFromMatrixColumn(t, e) {
                    return this.fromArray(t.elements, 4 * e)
                }
                setFromMatrix3Column(t, e) {
                    return this.fromArray(t.elements, 3 * e)
                }
                setFromEuler(t) {
                    return this.x = t._x, this.y = t._y, this.z = t._z, this
                }
                setFromColor(t) {
                    return this.x = t.r, this.y = t.g, this.z = t.b, this
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z
                }
                fromArray(t, e = 0) {
                    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
                }
                fromBufferAttribute(t, e) {
                    return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
                }
                randomDirection() {
                    let t = Math.random() * Math.PI * 2,
                        e = 2 * Math.random() - 1,
                        i = Math.sqrt(1 - e * e);
                    return this.x = i * Math.cos(t), this.y = e, this.z = i * Math.sin(t), this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y, yield this.z
                }
            }
            let e8 = new e9,
                it = new e7;
            class ie {
                constructor(t, e, i, s, r, n, a, o, h) {
                    ie.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], void 0 !== t && this.set(t, e, i, s, r, n, a, o, h)
                }
                set(t, e, i, s, r, n, a, o, h) {
                    let l = this.elements;
                    return l[0] = t, l[1] = s, l[2] = a, l[3] = e, l[4] = r, l[5] = o, l[6] = i, l[7] = n, l[8] = h, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                }
                copy(t) {
                    let e = this.elements,
                        i = t.elements;
                    return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this
                }
                extractBasis(t, e, i) {
                    return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this
                }
                setFromMatrix4(t) {
                    let e = t.elements;
                    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
                }
                multiply(t) {
                    return this.multiplyMatrices(this, t)
                }
                premultiply(t) {
                    return this.multiplyMatrices(t, this)
                }
                multiplyMatrices(t, e) {
                    let i = t.elements,
                        s = e.elements,
                        r = this.elements,
                        n = i[0],
                        a = i[3],
                        o = i[6],
                        h = i[1],
                        l = i[4],
                        u = i[7],
                        c = i[2],
                        p = i[5],
                        d = i[8],
                        m = s[0],
                        y = s[3],
                        f = s[6],
                        g = s[1],
                        x = s[4],
                        b = s[7],
                        M = s[2],
                        v = s[5],
                        w = s[8];
                    return r[0] = n * m + a * g + o * M, r[3] = n * y + a * x + o * v, r[6] = n * f + a * b + o * w, r[1] = h * m + l * g + u * M, r[4] = h * y + l * x + u * v, r[7] = h * f + l * b + u * w, r[2] = c * m + p * g + d * M, r[5] = c * y + p * x + d * v, r[8] = c * f + p * b + d * w, this
                }
                multiplyScalar(t) {
                    let e = this.elements;
                    return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
                }
                determinant() {
                    let t = this.elements,
                        e = t[0],
                        i = t[1],
                        s = t[2],
                        r = t[3],
                        n = t[4],
                        a = t[5],
                        o = t[6],
                        h = t[7],
                        l = t[8];
                    return e * n * l - e * a * h - i * r * l + i * a * o + s * r * h - s * n * o
                }
                invert() {
                    let t = this.elements,
                        e = t[0],
                        i = t[1],
                        s = t[2],
                        r = t[3],
                        n = t[4],
                        a = t[5],
                        o = t[6],
                        h = t[7],
                        l = t[8],
                        u = l * n - a * h,
                        c = a * o - l * r,
                        p = h * r - n * o,
                        d = e * u + i * c + s * p;
                    if (0 === d) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                    let m = 1 / d;
                    return t[0] = u * m, t[1] = (s * h - l * i) * m, t[2] = (a * i - s * n) * m, t[3] = c * m, t[4] = (l * e - s * o) * m, t[5] = (s * r - a * e) * m, t[6] = p * m, t[7] = (i * o - h * e) * m, t[8] = (n * e - i * r) * m, this
                }
                transpose() {
                    let t;
                    let e = this.elements;
                    return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
                }
                getNormalMatrix(t) {
                    return this.setFromMatrix4(t).invert().transpose()
                }
                transposeIntoArray(t) {
                    let e = this.elements;
                    return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
                }
                setUvTransform(t, e, i, s, r, n, a) {
                    let o = Math.cos(r),
                        h = Math.sin(r);
                    return this.set(i * o, i * h, -i * (o * n + h * a) + n + t, -s * h, s * o, -s * (-h * n + o * a) + a + e, 0, 0, 1), this
                }
                scale(t, e) {
                    return this.premultiply(ii.makeScale(t, e)), this
                }
                rotate(t) {
                    return this.premultiply(ii.makeRotation(-t)), this
                }
                translate(t, e) {
                    return this.premultiply(ii.makeTranslation(t, e)), this
                }
                makeTranslation(t, e) {
                    return t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, e, 0, 0, 1), this
                }
                makeRotation(t) {
                    let e = Math.cos(t),
                        i = Math.sin(t);
                    return this.set(e, -i, 0, i, e, 0, 0, 0, 1), this
                }
                makeScale(t, e) {
                    return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this
                }
                equals(t) {
                    let e = this.elements,
                        i = t.elements;
                    for (let t = 0; t < 9; t++)
                        if (e[t] !== i[t]) return !1;
                    return !0
                }
                fromArray(t, e = 0) {
                    for (let i = 0; i < 9; i++) this.elements[i] = t[i + e];
                    return this
                }
                toArray(t = [], e = 0) {
                    let i = this.elements;
                    return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t
                }
                clone() {
                    return new this.constructor().fromArray(this.elements)
                }
            }
            let ii = new ie,
                is = new ie().set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322),
                ir = new ie().set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715),
                ia = function() {
                    let t = {
                            enabled: !0,
                            workingColorSpace: eA,
                            spaces: {},
                            convert: function(t, e, i) {
                                return !1 !== this.enabled && e !== i && e && i && (this.spaces[e].transfer === eC && (t.r = io(t.r), t.g = io(t.g), t.b = io(t.b)), this.spaces[e].primaries !== this.spaces[i].primaries && (t.applyMatrix3(this.spaces[e].toXYZ), t.applyMatrix3(this.spaces[i].fromXYZ)), this.spaces[i].transfer === eC && (t.r = ih(t.r), t.g = ih(t.g), t.b = ih(t.b))), t
                            },
                            workingToColorSpace: function(t, e) {
                                return this.convert(t, this.workingColorSpace, e)
                            },
                            colorSpaceToWorking: function(t, e) {
                                return this.convert(t, e, this.workingColorSpace)
                            },
                            getPrimaries: function(t) {
                                return this.spaces[t].primaries
                            },
                            getTransfer: function(t) {
                                return t === e_ ? eT : this.spaces[t].transfer
                            },
                            getToneMappingMode: function(t) {
                                return this.spaces[t].outputColorSpaceConfig.toneMappingMode || "standard"
                            },
                            getLuminanceCoefficients: function(t, e = this.workingColorSpace) {
                                return t.fromArray(this.spaces[e].luminanceCoefficients)
                            },
                            define: function(t) {
                                Object.assign(this.spaces, t)
                            },
                            _getMatrix: function(t, e, i) {
                                return t.copy(this.spaces[e].toXYZ).multiply(this.spaces[i].fromXYZ)
                            },
                            _getDrawingBufferColorSpace: function(t) {
                                return this.spaces[t].outputColorSpaceConfig.drawingBufferColorSpace
                            },
                            _getUnpackColorSpace: function(t = this.workingColorSpace) {
                                return this.spaces[t].workingColorSpaceConfig.unpackColorSpace
                            },
                            fromWorkingColorSpace: function(e, i) {
                                return eZ("ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."), t.workingToColorSpace(e, i)
                            },
                            toWorkingColorSpace: function(e, i) {
                                return eZ("ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."), t.colorSpaceToWorking(e, i)
                            }
                        },
                        e = [.64, .33, .3, .6, .15, .06],
                        i = [.2126, .7152, .0722],
                        s = [.3127, .329];
                    return t.define({
                        [eA]: {
                            primaries: e,
                            whitePoint: s,
                            transfer: eT,
                            toXYZ: is,
                            fromXYZ: ir,
                            luminanceCoefficients: i,
                            workingColorSpaceConfig: {
                                unpackColorSpace: ez
                            },
                            outputColorSpaceConfig: {
                                drawingBufferColorSpace: ez
                            }
                        },
                        [ez]: {
                            primaries: e,
                            whitePoint: s,
                            transfer: eC,
                            toXYZ: is,
                            fromXYZ: ir,
                            luminanceCoefficients: i,
                            outputColorSpaceConfig: {
                                drawingBufferColorSpace: ez
                            }
                        }
                    }), t
                }();

            function io(t) {
                return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
            }

            function ih(t) {
                return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
            }
            class il {
                static getDataURL(t, e = "image/png") {
                    let i;
                    if (/^data:/i.test(t.src) || "undefined" == typeof HTMLCanvasElement) return t.src;
                    if (t instanceof HTMLCanvasElement) i = t;
                    else {
                        void 0 === s && (s = eD("canvas")), s.width = t.width, s.height = t.height;
                        let e = s.getContext("2d");
                        t instanceof ImageData ? e.putImageData(t, 0, 0) : e.drawImage(t, 0, 0, t.width, t.height), i = s
                    }
                    return i.toDataURL(e)
                }
                static sRGBToLinear(t) {
                    if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                        let e = eD("canvas");
                        e.width = t.width, e.height = t.height;
                        let i = e.getContext("2d");
                        i.drawImage(t, 0, 0, t.width, t.height);
                        let s = i.getImageData(0, 0, t.width, t.height),
                            r = s.data;
                        for (let t = 0; t < r.length; t++) r[t] = 255 * io(r[t] / 255);
                        return i.putImageData(s, 0, 0), e
                    }
                    if (!t.data) return eJ("ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t; {
                        let e = t.data.slice(0);
                        for (let t = 0; t < e.length; t++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * io(e[t] / 255)) : e[t] = io(e[t]);
                        return {
                            data: e,
                            width: t.width,
                            height: t.height
                        }
                    }
                }
            }
            let iu = 0;
            class ic {
                constructor(t = null) {
                    this.isSource = !0, Object.defineProperty(this, "id", {
                        value: iu++
                    }), this.uuid = eK(), this.data = t, this.dataReady = !0, this.version = 0
                }
                getSize(t) {
                    let e = this.data;
                    return "undefined" != typeof HTMLVideoElement && e instanceof HTMLVideoElement ? t.set(e.videoWidth, e.videoHeight, 0) : "undefined" != typeof VideoFrame && e instanceof VideoFrame ? t.set(e.displayHeight, e.displayWidth, 0) : null !== e ? t.set(e.width, e.height, e.depth || 0) : t.set(0, 0, 0), t
                }
                set needsUpdate(t) {
                    !0 === t && this.version++
                }
                toJSON(t) {
                    let e = void 0 === t || "string" == typeof t;
                    if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid];
                    let i = {
                            uuid: this.uuid,
                            url: ""
                        },
                        s = this.data;
                    if (null !== s) {
                        let t;
                        if (Array.isArray(s)) {
                            t = [];
                            for (let e = 0, i = s.length; e < i; e++) s[e].isDataTexture ? t.push(ip(s[e].image)) : t.push(ip(s[e]))
                        } else t = ip(s);
                        i.url = t
                    }
                    return e || (t.images[this.uuid] = i), i
                }
            }

            function ip(t) {
                return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? il.getDataURL(t) : t.data ? {
                    data: Array.from(t.data),
                    width: t.width,
                    height: t.height,
                    type: t.data.constructor.name
                } : (eJ("Texture: Unable to serialize Texture."), {})
            }
            let id = 0,
                im = new e9;
            class iy extends eX {
                constructor(t = iy.DEFAULT_IMAGE, e = iy.DEFAULT_MAPPING, i = tm, s = tm, r = tb, n = tv, a = tL, o = tw, h = iy.DEFAULT_ANISOTROPY, l = e_) {
                    super(), this.isTexture = !0, Object.defineProperty(this, "id", {
                        value: id++
                    }), this.uuid = eK(), this.name = "", this.source = new ic(t), this.mipmaps = [], this.mapping = e, this.channel = 0, this.wrapS = i, this.wrapT = s, this.magFilter = r, this.minFilter = n, this.anisotropy = h, this.format = a, this.internalFormat = null, this.type = o, this.offset = new e6(0, 0), this.repeat = new e6(1, 1), this.center = new e6(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new ie, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = l, this.userData = {}, this.updateRanges = [], this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = !1, this.isArrayTexture = !!t && !!t.depth && t.depth > 1, this.pmremVersion = 0
                }
                get width() {
                    return this.source.getSize(im).x
                }
                get height() {
                    return this.source.getSize(im).y
                }
                get depth() {
                    return this.source.getSize(im).z
                }
                get image() {
                    return this.source.data
                }
                set image(t = null) {
                    this.source.data = t
                }
                updateMatrix() {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                }
                addUpdateRange(t, e) {
                    this.updateRanges.push({
                        start: t,
                        count: e
                    })
                }
                clearUpdateRanges() {
                    this.updateRanges.length = 0
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(t) {
                    return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.channel = t.channel, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.colorSpace = t.colorSpace, this.renderTarget = t.renderTarget, this.isRenderTargetTexture = t.isRenderTargetTexture, this.isArrayTexture = t.isArrayTexture, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this
                }
                setValues(t) {
                    for (let e in t) {
                        let i = t[e];
                        if (void 0 === i) {
                            eJ(`Texture.setValues(): parameter '${e}' has value of undefined.`);
                            continue
                        }
                        let s = this[e];
                        if (void 0 === s) {
                            eJ(`Texture.setValues(): property '${e}' does not exist.`);
                            continue
                        }
                        s && i && s.isVector2 && i.isVector2 ? s.copy(i) : s && i && s.isVector3 && i.isVector3 ? s.copy(i) : s && i && s.isMatrix3 && i.isMatrix3 ? s.copy(i) : this[e] = i
                    }
                }
                toJSON(t) {
                    let e = void 0 === t || "string" == typeof t;
                    if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                    let i = {
                        metadata: {
                            version: 4.7,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        image: this.source.toJSON(t).uuid,
                        mapping: this.mapping,
                        channel: this.channel,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        internalFormat: this.internalFormat,
                        type: this.type,
                        colorSpace: this.colorSpace,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY,
                        generateMipmaps: this.generateMipmaps,
                        premultiplyAlpha: this.premultiplyAlpha,
                        unpackAlignment: this.unpackAlignment
                    };
                    return Object.keys(this.userData).length > 0 && (i.userData = this.userData), e || (t.textures[this.uuid] = i), i
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                transformUv(t) {
                    if (300 !== this.mapping) return t;
                    if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                        case td:
                            t.x = t.x - Math.floor(t.x);
                            break;
                        case tm:
                            t.x = t.x < 0 ? 0 : 1;
                            break;
                        case ty:
                            1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                    }
                    if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                        case td:
                            t.y = t.y - Math.floor(t.y);
                            break;
                        case tm:
                            t.y = t.y < 0 ? 0 : 1;
                            break;
                        case ty:
                            1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                    }
                    return this.flipY && (t.y = 1 - t.y), t
                }
                set needsUpdate(t) {
                    !0 === t && (this.version++, this.source.needsUpdate = !0)
                }
                set needsPMREMUpdate(t) {
                    !0 === t && this.pmremVersion++
                }
            }
            iy.DEFAULT_IMAGE = null, iy.DEFAULT_MAPPING = 300, iy.DEFAULT_ANISOTROPY = 1;
            class ig {
                constructor(t = 0, e = 0, i = 0, s = 1) {
                    ig.prototype.isVector4 = !0, this.x = t, this.y = e, this.z = i, this.w = s
                }
                get width() {
                    return this.z
                }
                set width(t) {
                    this.z = t
                }
                get height() {
                    return this.w
                }
                set height(t) {
                    this.w = t
                }
                set(t, e, i, s) {
                    return this.x = t, this.y = e, this.z = i, this.w = s, this
                }
                setScalar(t) {
                    return this.x = t, this.y = t, this.z = t, this.w = t, this
                }
                setX(t) {
                    return this.x = t, this
                }
                setY(t) {
                    return this.y = t, this
                }
                setZ(t) {
                    return this.z = t, this
                }
                setW(t) {
                    return this.w = t, this
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        case 3:
                            this.w = e;
                            break;
                        default:
                            throw Error("index is out of range: " + t)
                    }
                    return this
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw Error("index is out of range: " + t)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                }
                copy(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
                }
                add(t) {
                    return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this
                }
                addScalar(t) {
                    return this.x += t, this.y += t, this.z += t, this.w += t, this
                }
                addVectors(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
                }
                addScaledVector(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
                }
                sub(t) {
                    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this
                }
                subScalar(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
                }
                subVectors(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
                }
                multiply(t) {
                    return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
                }
                multiplyScalar(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
                }
                applyMatrix4(t) {
                    let e = this.x,
                        i = this.y,
                        s = this.z,
                        r = this.w,
                        n = t.elements;
                    return this.x = n[0] * e + n[4] * i + n[8] * s + n[12] * r, this.y = n[1] * e + n[5] * i + n[9] * s + n[13] * r, this.z = n[2] * e + n[6] * i + n[10] * s + n[14] * r, this.w = n[3] * e + n[7] * i + n[11] * s + n[15] * r, this
                }
                divide(t) {
                    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this.w /= t.w, this
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t)
                }
                setAxisAngleFromQuaternion(t) {
                    this.w = 2 * Math.acos(t.w);
                    let e = Math.sqrt(1 - t.w * t.w);
                    return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
                }
                setAxisAngleFromRotationMatrix(t) {
                    let e, i, s, r;
                    let n = t.elements,
                        a = n[0],
                        o = n[4],
                        h = n[8],
                        l = n[1],
                        u = n[5],
                        c = n[9],
                        p = n[2],
                        d = n[6],
                        m = n[10];
                    if (.01 > Math.abs(o - l) && .01 > Math.abs(h - p) && .01 > Math.abs(c - d)) {
                        if (.1 > Math.abs(o + l) && .1 > Math.abs(h + p) && .1 > Math.abs(c + d) && .1 > Math.abs(a + u + m - 3)) return this.set(1, 0, 0, 0), this;
                        e = Math.PI;
                        let t = (a + 1) / 2,
                            n = (u + 1) / 2,
                            y = (m + 1) / 2,
                            f = (o + l) / 4,
                            g = (h + p) / 4,
                            x = (c + d) / 4;
                        return t > n && t > y ? t < .01 ? (i = 0, s = .707106781, r = .707106781) : (s = f / (i = Math.sqrt(t)), r = g / i) : n > y ? n < .01 ? (i = .707106781, s = 0, r = .707106781) : (i = f / (s = Math.sqrt(n)), r = x / s) : y < .01 ? (i = .707106781, s = .707106781, r = 0) : (i = g / (r = Math.sqrt(y)), s = x / r), this.set(i, s, r, e), this
                    }
                    let y = Math.sqrt((d - c) * (d - c) + (h - p) * (h - p) + (l - o) * (l - o));
                    return .001 > Math.abs(y) && (y = 1), this.x = (d - c) / y, this.y = (h - p) / y, this.z = (l - o) / y, this.w = Math.acos((a + u + m - 1) / 2), this
                }
                setFromMatrixPosition(t) {
                    let e = t.elements;
                    return this.x = e[12], this.y = e[13], this.z = e[14], this.w = e[15], this
                }
                min(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
                }
                max(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
                }
                clamp(t, e) {
                    return this.x = e0(this.x, t.x, e.x), this.y = e0(this.y, t.y, e.y), this.z = e0(this.z, t.z, e.z), this.w = e0(this.w, t.w, e.w), this
                }
                clampScalar(t, e) {
                    return this.x = e0(this.x, t, e), this.y = e0(this.y, t, e), this.z = e0(this.z, t, e), this.w = e0(this.w, t, e), this
                }
                clampLength(t, e) {
                    let i = this.length();
                    return this.divideScalar(i || 1).multiplyScalar(e0(i, t, e))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                }
                roundToZero() {
                    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t)
                }
                lerp(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
                }
                lerpVectors(t, e, i) {
                    return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this.w = t.w + (e.w - t.w) * i, this
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
                }
                fromArray(t, e = 0) {
                    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
                }
                fromBufferAttribute(t, e) {
                    return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y, yield this.z, yield this.w
                }
            }
            class ix extends eX {
                constructor(t = 1, e = 1, i = {}) {
                    super(), i = Object.assign({
                        generateMipmaps: !1,
                        internalFormat: null,
                        minFilter: tb,
                        depthBuffer: !0,
                        stencilBuffer: !1,
                        resolveDepthBuffer: !0,
                        resolveStencilBuffer: !0,
                        depthTexture: null,
                        samples: 0,
                        count: 1,
                        depth: 1,
                        multiview: !1
                    }, i), this.isRenderTarget = !0, this.width = t, this.height = e, this.depth = i.depth, this.scissor = new ig(0, 0, t, e), this.scissorTest = !1, this.viewport = new ig(0, 0, t, e);
                    let s = new iy({
                        width: t,
                        height: e,
                        depth: i.depth
                    });
                    this.textures = [];
                    let r = i.count;
                    for (let t = 0; t < r; t++) this.textures[t] = s.clone(), this.textures[t].isRenderTargetTexture = !0, this.textures[t].renderTarget = this;
                    this._setTextureOptions(i), this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.resolveDepthBuffer = i.resolveDepthBuffer, this.resolveStencilBuffer = i.resolveStencilBuffer, this._depthTexture = null, this.depthTexture = i.depthTexture, this.samples = i.samples, this.multiview = i.multiview
                }
                _setTextureOptions(t = {}) {
                    let e = {
                        minFilter: tb,
                        generateMipmaps: !1,
                        flipY: !1,
                        internalFormat: null
                    };
                    void 0 !== t.mapping && (e.mapping = t.mapping), void 0 !== t.wrapS && (e.wrapS = t.wrapS), void 0 !== t.wrapT && (e.wrapT = t.wrapT), void 0 !== t.wrapR && (e.wrapR = t.wrapR), void 0 !== t.magFilter && (e.magFilter = t.magFilter), void 0 !== t.minFilter && (e.minFilter = t.minFilter), void 0 !== t.format && (e.format = t.format), void 0 !== t.type && (e.type = t.type), void 0 !== t.anisotropy && (e.anisotropy = t.anisotropy), void 0 !== t.colorSpace && (e.colorSpace = t.colorSpace), void 0 !== t.flipY && (e.flipY = t.flipY), void 0 !== t.generateMipmaps && (e.generateMipmaps = t.generateMipmaps), void 0 !== t.internalFormat && (e.internalFormat = t.internalFormat);
                    for (let t = 0; t < this.textures.length; t++) this.textures[t].setValues(e)
                }
                get texture() {
                    return this.textures[0]
                }
                set texture(t) {
                    this.textures[0] = t
                }
                set depthTexture(t) {
                    null !== this._depthTexture && (this._depthTexture.renderTarget = null), null !== t && (t.renderTarget = this), this._depthTexture = t
                }
                get depthTexture() {
                    return this._depthTexture
                }
                setSize(t, e, i = 1) {
                    if (this.width !== t || this.height !== e || this.depth !== i) {
                        this.width = t, this.height = e, this.depth = i;
                        for (let s = 0, r = this.textures.length; s < r; s++) this.textures[s].image.width = t, this.textures[s].image.height = e, this.textures[s].image.depth = i, !0 !== this.textures[s].isData3DTexture && (this.textures[s].isArrayTexture = this.textures[s].image.depth > 1);
                        this.dispose()
                    }
                    this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(t) {
                    this.width = t.width, this.height = t.height, this.depth = t.depth, this.scissor.copy(t.scissor), this.scissorTest = t.scissorTest, this.viewport.copy(t.viewport), this.textures.length = 0;
                    for (let e = 0, i = t.textures.length; e < i; e++) {
                        this.textures[e] = t.textures[e].clone(), this.textures[e].isRenderTargetTexture = !0, this.textures[e].renderTarget = this;
                        let i = Object.assign({}, t.textures[e].image);
                        this.textures[e].source = new ic(i)
                    }
                    return this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.resolveDepthBuffer = t.resolveDepthBuffer, this.resolveStencilBuffer = t.resolveStencilBuffer, null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            class ib extends ix {
                constructor(t = 1, e = 1, i = {}) {
                    super(t, e, i), this.isWebGLRenderTarget = !0
                }
            }
            class iM extends iy {
                constructor(t = null, e = 1, i = 1, s = 1) {
                    super(null), this.isDataArrayTexture = !0, this.image = {
                        data: t,
                        width: e,
                        height: i,
                        depth: s
                    }, this.magFilter = tf, this.minFilter = tf, this.wrapR = tm, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = new Set
                }
                addLayerUpdate(t) {
                    this.layerUpdates.add(t)
                }
                clearLayerUpdates() {
                    this.layerUpdates.clear()
                }
            }
            class iv extends iy {
                constructor(t = null, e = 1, i = 1, s = 1) {
                    super(null), this.isData3DTexture = !0, this.image = {
                        data: t,
                        width: e,
                        height: i,
                        depth: s
                    }, this.magFilter = tf, this.minFilter = tf, this.wrapR = tm, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                }
            }
            class iw {
                constructor(t = new e9(Infinity, Infinity, Infinity), e = new e9(-1 / 0, -1 / 0, -1 / 0)) {
                    this.isBox3 = !0, this.min = t, this.max = e
                }
                set(t, e) {
                    return this.min.copy(t), this.max.copy(e), this
                }
                setFromArray(t) {
                    this.makeEmpty();
                    for (let e = 0, i = t.length; e < i; e += 3) this.expandByPoint(i_.fromArray(t, e));
                    return this
                }
                setFromBufferAttribute(t) {
                    this.makeEmpty();
                    for (let e = 0, i = t.count; e < i; e++) this.expandByPoint(i_.fromBufferAttribute(t, e));
                    return this
                }
                setFromPoints(t) {
                    this.makeEmpty();
                    for (let e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                    return this
                }
                setFromCenterAndSize(t, e) {
                    let i = i_.copy(e).multiplyScalar(.5);
                    return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
                }
                setFromObject(t, e = !1) {
                    return this.makeEmpty(), this.expandByObject(t, e)
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(t) {
                    return this.min.copy(t.min), this.max.copy(t.max), this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = this.min.z = Infinity, this.max.x = this.max.y = this.max.z = -1 / 0, this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                }
                getCenter(t) {
                    return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(t) {
                    return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
                }
                expandByPoint(t) {
                    return this.min.min(t), this.max.max(t), this
                }
                expandByVector(t) {
                    return this.min.sub(t), this.max.add(t), this
                }
                expandByScalar(t) {
                    return this.min.addScalar(-t), this.max.addScalar(t), this
                }
                expandByObject(t, e = !1) {
                    t.updateWorldMatrix(!1, !1);
                    let i = t.geometry;
                    if (void 0 !== i) {
                        let s = i.getAttribute("position");
                        if (!0 === e && void 0 !== s && !0 !== t.isInstancedMesh)
                            for (let e = 0, i = s.count; e < i; e++) !0 === t.isMesh ? t.getVertexPosition(e, i_) : i_.fromBufferAttribute(s, e), i_.applyMatrix4(t.matrixWorld), this.expandByPoint(i_);
                        else void 0 !== t.boundingBox ? (null === t.boundingBox && t.computeBoundingBox(), iz.copy(t.boundingBox)) : (null === i.boundingBox && i.computeBoundingBox(), iz.copy(i.boundingBox)), iz.applyMatrix4(t.matrixWorld), this.union(iz)
                    }
                    let s = t.children;
                    for (let t = 0, i = s.length; t < i; t++) this.expandByObject(s[t], e);
                    return this
                }
                containsPoint(t) {
                    return t.x >= this.min.x && t.x <= this.max.x && t.y >= this.min.y && t.y <= this.max.y && t.z >= this.min.z && t.z <= this.max.z
                }
                containsBox(t) {
                    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
                }
                getParameter(t, e) {
                    return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                }
                intersectsBox(t) {
                    return t.max.x >= this.min.x && t.min.x <= this.max.x && t.max.y >= this.min.y && t.min.y <= this.max.y && t.max.z >= this.min.z && t.min.z <= this.max.z
                }
                intersectsSphere(t) {
                    return this.clampPoint(t.center, i_), i_.distanceToSquared(t.center) <= t.radius * t.radius
                }
                intersectsPlane(t) {
                    let e, i;
                    return t.normal.x > 0 ? (e = t.normal.x * this.min.x, i = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, i = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t.constant && i >= -t.constant
                }
                intersectsTriangle(t) {
                    if (this.isEmpty()) return !1;
                    this.getCenter(iN), iI.subVectors(this.max, iN), iA.subVectors(t.a, iN), iT.subVectors(t.b, iN), iC.subVectors(t.c, iN), iO.subVectors(iT, iA), ik.subVectors(iC, iT), iB.subVectors(iA, iC);
                    let e = [0, -iO.z, iO.y, 0, -ik.z, ik.y, 0, -iB.z, iB.y, iO.z, 0, -iO.x, ik.z, 0, -ik.x, iB.z, 0, -iB.x, -iO.y, iO.x, 0, -ik.y, ik.x, 0, -iB.y, iB.x, 0];
                    return !!(iV(e, iA, iT, iC, iI) && iV(e = [1, 0, 0, 0, 1, 0, 0, 0, 1], iA, iT, iC, iI)) && (iP.crossVectors(iO, ik), iV(e = [iP.x, iP.y, iP.z], iA, iT, iC, iI))
                }
                clampPoint(t, e) {
                    return e.copy(t).clamp(this.min, this.max)
                }
                distanceToPoint(t) {
                    return this.clampPoint(t, i_).distanceTo(t)
                }
                getBoundingSphere(t) {
                    return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center), t.radius = .5 * this.getSize(i_).length()), t
                }
                intersect(t) {
                    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
                }
                union(t) {
                    return this.min.min(t.min), this.max.max(t.max), this
                }
                applyMatrix4(t) {
                    return this.isEmpty() || (iS[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), iS[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), iS[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), iS[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), iS[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), iS[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), iS[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), iS[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(iS)), this
                }
                translate(t) {
                    return this.min.add(t), this.max.add(t), this
                }
                equals(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max)
                }
                toJSON() {
                    return {
                        min: this.min.toArray(),
                        max: this.max.toArray()
                    }
                }
                fromJSON(t) {
                    return this.min.fromArray(t.min), this.max.fromArray(t.max), this
                }
            }
            let iS = [new e9, new e9, new e9, new e9, new e9, new e9, new e9, new e9],
                i_ = new e9,
                iz = new iw,
                iA = new e9,
                iT = new e9,
                iC = new e9,
                iO = new e9,
                ik = new e9,
                iB = new e9,
                iN = new e9,
                iI = new e9,
                iP = new e9,
                iR = new e9;

            function iV(t, e, i, s, r) {
                for (let n = 0, a = t.length - 3; n <= a; n += 3) {
                    iR.fromArray(t, n);
                    let a = r.x * Math.abs(iR.x) + r.y * Math.abs(iR.y) + r.z * Math.abs(iR.z),
                        o = e.dot(iR),
                        h = i.dot(iR),
                        l = s.dot(iR);
                    if (Math.max(-Math.max(o, h, l), Math.min(o, h, l)) > a) return !1
                }
                return !0
            }
            let iL = new iw,
                iE = new e9,
                iF = new e9;
            class iD {
                constructor(t = new e9, e = -1) {
                    this.isSphere = !0, this.center = t, this.radius = e
                }
                set(t, e) {
                    return this.center.copy(t), this.radius = e, this
                }
                setFromPoints(t, e) {
                    let i = this.center;
                    void 0 !== e ? i.copy(e) : iL.setFromPoints(t).getCenter(i);
                    let s = 0;
                    for (let e = 0, r = t.length; e < r; e++) s = Math.max(s, i.distanceToSquared(t[e]));
                    return this.radius = Math.sqrt(s), this
                }
                copy(t) {
                    return this.center.copy(t.center), this.radius = t.radius, this
                }
                isEmpty() {
                    return this.radius < 0
                }
                makeEmpty() {
                    return this.center.set(0, 0, 0), this.radius = -1, this
                }
                containsPoint(t) {
                    return t.distanceToSquared(this.center) <= this.radius * this.radius
                }
                distanceToPoint(t) {
                    return t.distanceTo(this.center) - this.radius
                }
                intersectsSphere(t) {
                    let e = this.radius + t.radius;
                    return t.center.distanceToSquared(this.center) <= e * e
                }
                intersectsBox(t) {
                    return t.intersectsSphere(this)
                }
                intersectsPlane(t) {
                    return Math.abs(t.distanceToPoint(this.center)) <= this.radius
                }
                clampPoint(t, e) {
                    let i = this.center.distanceToSquared(t);
                    return e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
                }
                getBoundingBox(t) {
                    return this.isEmpty() ? t.makeEmpty() : (t.set(this.center, this.center), t.expandByScalar(this.radius)), t
                }
                applyMatrix4(t) {
                    return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
                }
                translate(t) {
                    return this.center.add(t), this
                }
                expandByPoint(t) {
                    if (this.isEmpty()) return this.center.copy(t), this.radius = 0, this;
                    iE.subVectors(t, this.center);
                    let e = iE.lengthSq();
                    if (e > this.radius * this.radius) {
                        let t = Math.sqrt(e),
                            i = (t - this.radius) * .5;
                        this.center.addScaledVector(iE, i / t), this.radius += i
                    }
                    return this
                }
                union(t) {
                    return t.isEmpty() || (this.isEmpty() ? this.copy(t) : !0 === this.center.equals(t.center) ? this.radius = Math.max(this.radius, t.radius) : (iF.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(iE.copy(t.center).add(iF)), this.expandByPoint(iE.copy(t.center).sub(iF)))), this
                }
                equals(t) {
                    return t.center.equals(this.center) && t.radius === this.radius
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                toJSON() {
                    return {
                        radius: this.radius,
                        center: this.center.toArray()
                    }
                }
                fromJSON(t) {
                    return this.radius = t.radius, this.center.fromArray(t.center), this
                }
            }
            let ij = new e9,
                iU = new e9,
                iW = new e9,
                iJ = new e9,
                iq = new e9,
                iZ = new e9,
                iY = new e9;
            class iX {
                constructor(t = new e9, e = new e9(0, 0, -1)) {
                    this.origin = t, this.direction = e
                }
                set(t, e) {
                    return this.origin.copy(t), this.direction.copy(e), this
                }
                copy(t) {
                    return this.origin.copy(t.origin), this.direction.copy(t.direction), this
                }
                at(t, e) {
                    return e.copy(this.origin).addScaledVector(this.direction, t)
                }
                lookAt(t) {
                    return this.direction.copy(t).sub(this.origin).normalize(), this
                }
                recast(t) {
                    return this.origin.copy(this.at(t, ij)), this
                }
                closestPointToPoint(t, e) {
                    e.subVectors(t, this.origin);
                    let i = e.dot(this.direction);
                    return i < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, i)
                }
                distanceToPoint(t) {
                    return Math.sqrt(this.distanceSqToPoint(t))
                }
                distanceSqToPoint(t) {
                    let e = ij.subVectors(t, this.origin).dot(this.direction);
                    return e < 0 ? this.origin.distanceToSquared(t) : (ij.copy(this.origin).addScaledVector(this.direction, e), ij.distanceToSquared(t))
                }
                distanceSqToSegment(t, e, i, s) {
                    let r, n, a, o;
                    iU.copy(t).add(e).multiplyScalar(.5), iW.copy(e).sub(t).normalize(), iJ.copy(this.origin).sub(iU);
                    let h = .5 * t.distanceTo(e),
                        l = -this.direction.dot(iW),
                        u = iJ.dot(this.direction),
                        c = -iJ.dot(iW),
                        p = iJ.lengthSq(),
                        d = Math.abs(1 - l * l);
                    if (d > 0) {
                        if (r = l * c - u, n = l * u - c, o = h * d, r >= 0) {
                            if (n >= -o) {
                                if (n <= o) {
                                    let t = 1 / d;
                                    r *= t, n *= t, a = r * (r + l * n + 2 * u) + n * (l * r + n + 2 * c) + p
                                } else a = -(r = Math.max(0, -(l * (n = h) + u))) * r + n * (n + 2 * c) + p
                            } else a = -(r = Math.max(0, -(l * (n = -h) + u))) * r + n * (n + 2 * c) + p
                        } else n <= -o ? (n = (r = Math.max(0, -(-l * h + u))) > 0 ? -h : Math.min(Math.max(-h, -c), h), a = -r * r + n * (n + 2 * c) + p) : n <= o ? (r = 0, a = (n = Math.min(Math.max(-h, -c), h)) * (n + 2 * c) + p) : (n = (r = Math.max(0, -(l * h + u))) > 0 ? h : Math.min(Math.max(-h, -c), h), a = -r * r + n * (n + 2 * c) + p)
                    } else n = l > 0 ? -h : h, a = -(r = Math.max(0, -(l * n + u))) * r + n * (n + 2 * c) + p;
                    return i && i.copy(this.origin).addScaledVector(this.direction, r), s && s.copy(iU).addScaledVector(iW, n), a
                }
                intersectSphere(t, e) {
                    ij.subVectors(t.center, this.origin);
                    let i = ij.dot(this.direction),
                        s = ij.dot(ij) - i * i,
                        r = t.radius * t.radius;
                    if (s > r) return null;
                    let n = Math.sqrt(r - s),
                        a = i - n,
                        o = i + n;
                    return o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e)
                }
                intersectsSphere(t) {
                    return !(t.radius < 0) && this.distanceSqToPoint(t.center) <= t.radius * t.radius
                }
                distanceToPlane(t) {
                    let e = t.normal.dot(this.direction);
                    if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                    let i = -(this.origin.dot(t.normal) + t.constant) / e;
                    return i >= 0 ? i : null
                }
                intersectPlane(t, e) {
                    let i = this.distanceToPlane(t);
                    return null === i ? null : this.at(i, e)
                }
                intersectsPlane(t) {
                    let e = t.distanceToPoint(this.origin);
                    return !!(0 === e || t.normal.dot(this.direction) * e < 0)
                }
                intersectBox(t, e) {
                    let i, s, r, n, a, o;
                    let h = 1 / this.direction.x,
                        l = 1 / this.direction.y,
                        u = 1 / this.direction.z,
                        c = this.origin;
                    return (h >= 0 ? (i = (t.min.x - c.x) * h, s = (t.max.x - c.x) * h) : (i = (t.max.x - c.x) * h, s = (t.min.x - c.x) * h), l >= 0 ? (r = (t.min.y - c.y) * l, n = (t.max.y - c.y) * l) : (r = (t.max.y - c.y) * l, n = (t.min.y - c.y) * l), i > n || r > s) ? null : ((r > i || isNaN(i)) && (i = r), (n < s || isNaN(s)) && (s = n), u >= 0 ? (a = (t.min.z - c.z) * u, o = (t.max.z - c.z) * u) : (a = (t.max.z - c.z) * u, o = (t.min.z - c.z) * u), i > o || a > s) ? null : ((a > i || i != i) && (i = a), (o < s || s != s) && (s = o), s < 0) ? null : this.at(i >= 0 ? i : s, e)
                }
                intersectsBox(t) {
                    return null !== this.intersectBox(t, ij)
                }
                intersectTriangle(t, e, i, s, r) {
                    let n;
                    iq.subVectors(e, t), iZ.subVectors(i, t), iY.crossVectors(iq, iZ);
                    let a = this.direction.dot(iY);
                    if (a > 0) {
                        if (s) return null;
                        n = 1
                    } else {
                        if (!(a < 0)) return null;
                        n = -1, a = -a
                    }
                    iJ.subVectors(this.origin, t);
                    let o = n * this.direction.dot(iZ.crossVectors(iJ, iZ));
                    if (o < 0) return null;
                    let h = n * this.direction.dot(iq.cross(iJ));
                    if (h < 0 || o + h > a) return null;
                    let l = -n * iJ.dot(iY);
                    return l < 0 ? null : this.at(l / a, r)
                }
                applyMatrix4(t) {
                    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
                }
                equals(t) {
                    return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            class iG {
                constructor(t, e, i, s, r, n, a, o, h, l, u, c, p, d, m, y) {
                    iG.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], void 0 !== t && this.set(t, e, i, s, r, n, a, o, h, l, u, c, p, d, m, y)
                }
                set(t, e, i, s, r, n, a, o, h, l, u, c, p, d, m, y) {
                    let f = this.elements;
                    return f[0] = t, f[4] = e, f[8] = i, f[12] = s, f[1] = r, f[5] = n, f[9] = a, f[13] = o, f[2] = h, f[6] = l, f[10] = u, f[14] = c, f[3] = p, f[7] = d, f[11] = m, f[15] = y, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                clone() {
                    return new iG().fromArray(this.elements)
                }
                copy(t) {
                    let e = this.elements,
                        i = t.elements;
                    return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this
                }
                copyPosition(t) {
                    let e = this.elements,
                        i = t.elements;
                    return e[12] = i[12], e[13] = i[13], e[14] = i[14], this
                }
                setFromMatrix3(t) {
                    let e = t.elements;
                    return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
                }
                extractBasis(t, e, i) {
                    return 0 === this.determinant() ? (t.set(1, 0, 0), e.set(0, 1, 0), i.set(0, 0, 1)) : (t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2)), this
                }
                makeBasis(t, e, i) {
                    return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this
                }
                extractRotation(t) {
                    if (0 === t.determinant()) return this.identity();
                    let e = this.elements,
                        i = t.elements,
                        s = 1 / iH.setFromMatrixColumn(t, 0).length(),
                        r = 1 / iH.setFromMatrixColumn(t, 1).length(),
                        n = 1 / iH.setFromMatrixColumn(t, 2).length();
                    return e[0] = i[0] * s, e[1] = i[1] * s, e[2] = i[2] * s, e[3] = 0, e[4] = i[4] * r, e[5] = i[5] * r, e[6] = i[6] * r, e[7] = 0, e[8] = i[8] * n, e[9] = i[9] * n, e[10] = i[10] * n, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                }
                makeRotationFromEuler(t) {
                    let e = this.elements,
                        i = t.x,
                        s = t.y,
                        r = t.z,
                        n = Math.cos(i),
                        a = Math.sin(i),
                        o = Math.cos(s),
                        h = Math.sin(s),
                        l = Math.cos(r),
                        u = Math.sin(r);
                    if ("XYZ" === t.order) {
                        let t = n * l,
                            i = n * u,
                            s = a * l,
                            r = a * u;
                        e[0] = o * l, e[4] = -o * u, e[8] = h, e[1] = i + s * h, e[5] = t - r * h, e[9] = -a * o, e[2] = r - t * h, e[6] = s + i * h, e[10] = n * o
                    } else if ("YXZ" === t.order) {
                        let t = o * l,
                            i = o * u,
                            s = h * l,
                            r = h * u;
                        e[0] = t + r * a, e[4] = s * a - i, e[8] = n * h, e[1] = n * u, e[5] = n * l, e[9] = -a, e[2] = i * a - s, e[6] = r + t * a, e[10] = n * o
                    } else if ("ZXY" === t.order) {
                        let t = o * l,
                            i = o * u,
                            s = h * l,
                            r = h * u;
                        e[0] = t - r * a, e[4] = -n * u, e[8] = s + i * a, e[1] = i + s * a, e[5] = n * l, e[9] = r - t * a, e[2] = -n * h, e[6] = a, e[10] = n * o
                    } else if ("ZYX" === t.order) {
                        let t = n * l,
                            i = n * u,
                            s = a * l,
                            r = a * u;
                        e[0] = o * l, e[4] = s * h - i, e[8] = t * h + r, e[1] = o * u, e[5] = r * h + t, e[9] = i * h - s, e[2] = -h, e[6] = a * o, e[10] = n * o
                    } else if ("YZX" === t.order) {
                        let t = n * o,
                            i = n * h,
                            s = a * o,
                            r = a * h;
                        e[0] = o * l, e[4] = r - t * u, e[8] = s * u + i, e[1] = u, e[5] = n * l, e[9] = -a * l, e[2] = -h * l, e[6] = i * u + s, e[10] = t - r * u
                    } else if ("XZY" === t.order) {
                        let t = n * o,
                            i = n * h,
                            s = a * o,
                            r = a * h;
                        e[0] = o * l, e[4] = -u, e[8] = h * l, e[1] = t * u + r, e[5] = n * l, e[9] = i * u - s, e[2] = s * u - i, e[6] = a * l, e[10] = r * u + t
                    }
                    return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                }
                makeRotationFromQuaternion(t) {
                    return this.compose(i$, t, iK)
                }
                lookAt(t, e, i) {
                    let s = this.elements;
                    return i2.subVectors(t, e), 0 === i2.lengthSq() && (i2.z = 1), i2.normalize(), i0.crossVectors(i, i2), 0 === i0.lengthSq() && (1 === Math.abs(i.z) ? i2.x += 1e-4 : i2.z += 1e-4, i2.normalize(), i0.crossVectors(i, i2)), i0.normalize(), i1.crossVectors(i2, i0), s[0] = i0.x, s[4] = i1.x, s[8] = i2.x, s[1] = i0.y, s[5] = i1.y, s[9] = i2.y, s[2] = i0.z, s[6] = i1.z, s[10] = i2.z, this
                }
                multiply(t) {
                    return this.multiplyMatrices(this, t)
                }
                premultiply(t) {
                    return this.multiplyMatrices(t, this)
                }
                multiplyMatrices(t, e) {
                    let i = t.elements,
                        s = e.elements,
                        r = this.elements,
                        n = i[0],
                        a = i[4],
                        o = i[8],
                        h = i[12],
                        l = i[1],
                        u = i[5],
                        c = i[9],
                        p = i[13],
                        d = i[2],
                        m = i[6],
                        y = i[10],
                        f = i[14],
                        g = i[3],
                        x = i[7],
                        b = i[11],
                        M = i[15],
                        v = s[0],
                        w = s[4],
                        S = s[8],
                        _ = s[12],
                        z = s[1],
                        A = s[5],
                        T = s[9],
                        C = s[13],
                        O = s[2],
                        k = s[6],
                        B = s[10],
                        N = s[14],
                        I = s[3],
                        P = s[7],
                        R = s[11],
                        V = s[15];
                    return r[0] = n * v + a * z + o * O + h * I, r[4] = n * w + a * A + o * k + h * P, r[8] = n * S + a * T + o * B + h * R, r[12] = n * _ + a * C + o * N + h * V, r[1] = l * v + u * z + c * O + p * I, r[5] = l * w + u * A + c * k + p * P, r[9] = l * S + u * T + c * B + p * R, r[13] = l * _ + u * C + c * N + p * V, r[2] = d * v + m * z + y * O + f * I, r[6] = d * w + m * A + y * k + f * P, r[10] = d * S + m * T + y * B + f * R, r[14] = d * _ + m * C + y * N + f * V, r[3] = g * v + x * z + b * O + M * I, r[7] = g * w + x * A + b * k + M * P, r[11] = g * S + x * T + b * B + M * R, r[15] = g * _ + x * C + b * N + M * V, this
                }
                multiplyScalar(t) {
                    let e = this.elements;
                    return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
                }
                determinant() {
                    let t = this.elements,
                        e = t[0],
                        i = t[4],
                        s = t[8],
                        r = t[12],
                        n = t[1],
                        a = t[5],
                        o = t[9],
                        h = t[13],
                        l = t[2],
                        u = t[6],
                        c = t[10],
                        p = t[14],
                        d = t[3],
                        m = t[7],
                        y = t[11],
                        f = t[15],
                        g = o * p - h * c,
                        x = a * p - h * u,
                        b = a * c - o * u,
                        M = n * p - h * l,
                        v = n * c - o * l,
                        w = n * u - a * l;
                    return e * (m * g - y * x + f * b) - i * (d * g - y * M + f * v) + s * (d * x - m * M + f * w) - r * (d * b - m * v + y * w)
                }
                transpose() {
                    let t;
                    let e = this.elements;
                    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
                }
                setPosition(t, e, i) {
                    let s = this.elements;
                    return t.isVector3 ? (s[12] = t.x, s[13] = t.y, s[14] = t.z) : (s[12] = t, s[13] = e, s[14] = i), this
                }
                invert() {
                    let t = this.elements,
                        e = t[0],
                        i = t[1],
                        s = t[2],
                        r = t[3],
                        n = t[4],
                        a = t[5],
                        o = t[6],
                        h = t[7],
                        l = t[8],
                        u = t[9],
                        c = t[10],
                        p = t[11],
                        d = t[12],
                        m = t[13],
                        y = t[14],
                        f = t[15],
                        g = u * y * h - m * c * h + m * o * p - a * y * p - u * o * f + a * c * f,
                        x = d * c * h - l * y * h - d * o * p + n * y * p + l * o * f - n * c * f,
                        b = l * m * h - d * u * h + d * a * p - n * m * p - l * a * f + n * u * f,
                        M = d * u * o - l * m * o - d * a * c + n * m * c + l * a * y - n * u * y,
                        v = e * g + i * x + s * b + r * M;
                    if (0 === v) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                    let w = 1 / v;
                    return t[0] = g * w, t[1] = (m * c * r - u * y * r - m * s * p + i * y * p + u * s * f - i * c * f) * w, t[2] = (a * y * r - m * o * r + m * s * h - i * y * h - a * s * f + i * o * f) * w, t[3] = (u * o * r - a * c * r - u * s * h + i * c * h + a * s * p - i * o * p) * w, t[4] = x * w, t[5] = (l * y * r - d * c * r + d * s * p - e * y * p - l * s * f + e * c * f) * w, t[6] = (d * o * r - n * y * r - d * s * h + e * y * h + n * s * f - e * o * f) * w, t[7] = (n * c * r - l * o * r + l * s * h - e * c * h - n * s * p + e * o * p) * w, t[8] = b * w, t[9] = (d * u * r - l * m * r - d * i * p + e * m * p + l * i * f - e * u * f) * w, t[10] = (n * m * r - d * a * r + d * i * h - e * m * h - n * i * f + e * a * f) * w, t[11] = (l * a * r - n * u * r - l * i * h + e * u * h + n * i * p - e * a * p) * w, t[12] = M * w, t[13] = (l * m * s - d * u * s + d * i * c - e * m * c - l * i * y + e * u * y) * w, t[14] = (d * a * s - n * m * s - d * i * o + e * m * o + n * i * y - e * a * y) * w, t[15] = (n * u * s - l * a * s + l * i * o - e * u * o - n * i * c + e * a * c) * w, this
                }
                scale(t) {
                    let e = this.elements,
                        i = t.x,
                        s = t.y,
                        r = t.z;
                    return e[0] *= i, e[4] *= s, e[8] *= r, e[1] *= i, e[5] *= s, e[9] *= r, e[2] *= i, e[6] *= s, e[10] *= r, e[3] *= i, e[7] *= s, e[11] *= r, this
                }
                getMaxScaleOnAxis() {
                    let t = this.elements;
                    return Math.sqrt(Math.max(t[0] * t[0] + t[1] * t[1] + t[2] * t[2], t[4] * t[4] + t[5] * t[5] + t[6] * t[6], t[8] * t[8] + t[9] * t[9] + t[10] * t[10]))
                }
                makeTranslation(t, e, i) {
                    return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this
                }
                makeRotationX(t) {
                    let e = Math.cos(t),
                        i = Math.sin(t);
                    return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this
                }
                makeRotationY(t) {
                    let e = Math.cos(t),
                        i = Math.sin(t);
                    return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this
                }
                makeRotationZ(t) {
                    let e = Math.cos(t),
                        i = Math.sin(t);
                    return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                makeRotationAxis(t, e) {
                    let i = Math.cos(e),
                        s = Math.sin(e),
                        r = 1 - i,
                        n = t.x,
                        a = t.y,
                        o = t.z,
                        h = r * n,
                        l = r * a;
                    return this.set(h * n + i, h * a - s * o, h * o + s * a, 0, h * a + s * o, l * a + i, l * o - s * n, 0, h * o - s * a, l * o + s * n, r * o * o + i, 0, 0, 0, 0, 1), this
                }
                makeScale(t, e, i) {
                    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
                }
                makeShear(t, e, i, s, r, n) {
                    return this.set(1, i, r, 0, t, 1, n, 0, e, s, 1, 0, 0, 0, 0, 1), this
                }
                compose(t, e, i) {
                    let s = this.elements,
                        r = e._x,
                        n = e._y,
                        a = e._z,
                        o = e._w,
                        h = r + r,
                        l = n + n,
                        u = a + a,
                        c = r * h,
                        p = r * l,
                        d = r * u,
                        m = n * l,
                        y = n * u,
                        f = a * u,
                        g = o * h,
                        x = o * l,
                        b = o * u,
                        M = i.x,
                        v = i.y,
                        w = i.z;
                    return s[0] = (1 - (m + f)) * M, s[1] = (p + b) * M, s[2] = (d - x) * M, s[3] = 0, s[4] = (p - b) * v, s[5] = (1 - (c + f)) * v, s[6] = (y + g) * v, s[7] = 0, s[8] = (d + x) * w, s[9] = (y - g) * w, s[10] = (1 - (c + m)) * w, s[11] = 0, s[12] = t.x, s[13] = t.y, s[14] = t.z, s[15] = 1, this
                }
                decompose(t, e, i) {
                    let s = this.elements;
                    if (t.x = s[12], t.y = s[13], t.z = s[14], 0 === this.determinant()) return i.set(1, 1, 1), e.identity(), this;
                    let r = iH.set(s[0], s[1], s[2]).length(),
                        n = iH.set(s[4], s[5], s[6]).length(),
                        a = iH.set(s[8], s[9], s[10]).length();
                    0 > this.determinant() && (r = -r), iQ.copy(this);
                    let o = 1 / r,
                        h = 1 / n,
                        l = 1 / a;
                    return iQ.elements[0] *= o, iQ.elements[1] *= o, iQ.elements[2] *= o, iQ.elements[4] *= h, iQ.elements[5] *= h, iQ.elements[6] *= h, iQ.elements[8] *= l, iQ.elements[9] *= l, iQ.elements[10] *= l, e.setFromRotationMatrix(iQ), i.x = r, i.y = n, i.z = a, this
                }
                makePerspective(t, e, i, s, r, n, a = eE, o = !1) {
                    let h, l;
                    let u = this.elements;
                    if (o) h = r / (n - r), l = n * r / (n - r);
                    else if (a === eE) h = -(n + r) / (n - r), l = -2 * n * r / (n - r);
                    else if (2001 === a) h = -n / (n - r), l = -n * r / (n - r);
                    else throw Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
                    return u[0] = 2 * r / (e - t), u[4] = 0, u[8] = (e + t) / (e - t), u[12] = 0, u[1] = 0, u[5] = 2 * r / (i - s), u[9] = (i + s) / (i - s), u[13] = 0, u[2] = 0, u[6] = 0, u[10] = h, u[14] = l, u[3] = 0, u[7] = 0, u[11] = -1, u[15] = 0, this
                }
                makeOrthographic(t, e, i, s, r, n, a = eE, o = !1) {
                    let h, l;
                    let u = this.elements;
                    if (o) h = 1 / (n - r), l = n / (n - r);
                    else if (a === eE) h = -2 / (n - r), l = -(n + r) / (n - r);
                    else if (2001 === a) h = -1 / (n - r), l = -r / (n - r);
                    else throw Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
                    return u[0] = 2 / (e - t), u[4] = 0, u[8] = 0, u[12] = -(e + t) / (e - t), u[1] = 0, u[5] = 2 / (i - s), u[9] = 0, u[13] = -(i + s) / (i - s), u[2] = 0, u[6] = 0, u[10] = h, u[14] = l, u[3] = 0, u[7] = 0, u[11] = 0, u[15] = 1, this
                }
                equals(t) {
                    let e = this.elements,
                        i = t.elements;
                    for (let t = 0; t < 16; t++)
                        if (e[t] !== i[t]) return !1;
                    return !0
                }
                fromArray(t, e = 0) {
                    for (let i = 0; i < 16; i++) this.elements[i] = t[i + e];
                    return this
                }
                toArray(t = [], e = 0) {
                    let i = this.elements;
                    return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t
                }
            }
            let iH = new e9,
                iQ = new iG,
                i$ = new e9(0, 0, 0),
                iK = new e9(1, 1, 1),
                i0 = new e9,
                i1 = new e9,
                i2 = new e9,
                i3 = new iG,
                i5 = new e7;
            class i4 {
                constructor(t = 0, e = 0, i = 0, s = i4.DEFAULT_ORDER) {
                    this.isEuler = !0, this._x = t, this._y = e, this._z = i, this._order = s
                }
                get x() {
                    return this._x
                }
                set x(t) {
                    this._x = t, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(t) {
                    this._y = t, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(t) {
                    this._z = t, this._onChangeCallback()
                }
                get order() {
                    return this._order
                }
                set order(t) {
                    this._order = t, this._onChangeCallback()
                }
                set(t, e, i, s = this._order) {
                    return this._x = t, this._y = e, this._z = i, this._order = s, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                }
                copy(t) {
                    return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
                }
                setFromRotationMatrix(t, e = this._order, i = !0) {
                    let s = t.elements,
                        r = s[0],
                        n = s[4],
                        a = s[8],
                        o = s[1],
                        h = s[5],
                        l = s[9],
                        u = s[2],
                        c = s[6],
                        p = s[10];
                    switch (e) {
                        case "XYZ":
                            this._y = Math.asin(e0(a, -1, 1)), .9999999 > Math.abs(a) ? (this._x = Math.atan2(-l, p), this._z = Math.atan2(-n, r)) : (this._x = Math.atan2(c, h), this._z = 0);
                            break;
                        case "YXZ":
                            this._x = Math.asin(-e0(l, -1, 1)), .9999999 > Math.abs(l) ? (this._y = Math.atan2(a, p), this._z = Math.atan2(o, h)) : (this._y = Math.atan2(-u, r), this._z = 0);
                            break;
                        case "ZXY":
                            this._x = Math.asin(e0(c, -1, 1)), .9999999 > Math.abs(c) ? (this._y = Math.atan2(-u, p), this._z = Math.atan2(-n, h)) : (this._y = 0, this._z = Math.atan2(o, r));
                            break;
                        case "ZYX":
                            this._y = Math.asin(-e0(u, -1, 1)), .9999999 > Math.abs(u) ? (this._x = Math.atan2(c, p), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-n, h));
                            break;
                        case "YZX":
                            this._z = Math.asin(e0(o, -1, 1)), .9999999 > Math.abs(o) ? (this._x = Math.atan2(-l, h), this._y = Math.atan2(-u, r)) : (this._x = 0, this._y = Math.atan2(a, p));
                            break;
                        case "XZY":
                            this._z = Math.asin(-e0(n, -1, 1)), .9999999 > Math.abs(n) ? (this._x = Math.atan2(c, h), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-l, p), this._y = 0);
                            break;
                        default:
                            eJ("Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                    }
                    return this._order = e, !0 === i && this._onChangeCallback(), this
                }
                setFromQuaternion(t, e, i) {
                    return i3.makeRotationFromQuaternion(t), this.setFromRotationMatrix(i3, e, i)
                }
                setFromVector3(t, e = this._order) {
                    return this.set(t.x, t.y, t.z, e)
                }
                reorder(t) {
                    return i5.setFromEuler(this), this.setFromQuaternion(i5, t)
                }
                equals(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                }
                fromArray(t) {
                    return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
                }
                _onChange(t) {
                    return this._onChangeCallback = t, this
                }
                _onChangeCallback() {}*[Symbol.iterator]() {
                    yield this._x, yield this._y, yield this._z, yield this._order
                }
            }
            i4.DEFAULT_ORDER = "XYZ";
            class i6 {
                constructor() {
                    this.mask = 1
                }
                set(t) {
                    this.mask = (1 << t | 0) >>> 0
                }
                enable(t) {
                    this.mask |= 1 << t | 0
                }
                enableAll() {
                    this.mask = -1
                }
                toggle(t) {
                    this.mask ^= 1 << t | 0
                }
                disable(t) {
                    this.mask &= ~(1 << t | 0)
                }
                disableAll() {
                    this.mask = 0
                }
                test(t) {
                    return (this.mask & t.mask) != 0
                }
                isEnabled(t) {
                    return (this.mask & (1 << t | 0)) != 0
                }
            }
            let i7 = 0,
                i9 = new e9,
                i8 = new e7,
                st = new iG,
                se = new e9,
                si = new e9,
                ss = new e9,
                sr = new e7,
                sn = new e9(1, 0, 0),
                sa = new e9(0, 1, 0),
                so = new e9(0, 0, 1),
                sh = {
                    type: "added"
                },
                sl = {
                    type: "removed"
                },
                su = {
                    type: "childadded",
                    child: null
                },
                sc = {
                    type: "childremoved",
                    child: null
                };
            class sp extends eX {
                constructor() {
                    super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
                        value: i7++
                    }), this.uuid = eK(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = sp.DEFAULT_UP.clone();
                    let t = new e9,
                        e = new i4,
                        i = new e7,
                        s = new e9(1, 1, 1);
                    e._onChange(function() {
                        i.setFromEuler(e, !1)
                    }), i._onChange(function() {
                        e.setFromQuaternion(i, void 0, !1)
                    }), Object.defineProperties(this, {
                        position: {
                            configurable: !0,
                            enumerable: !0,
                            value: t
                        },
                        rotation: {
                            configurable: !0,
                            enumerable: !0,
                            value: e
                        },
                        quaternion: {
                            configurable: !0,
                            enumerable: !0,
                            value: i
                        },
                        scale: {
                            configurable: !0,
                            enumerable: !0,
                            value: s
                        },
                        modelViewMatrix: {
                            value: new iG
                        },
                        normalMatrix: {
                            value: new ie
                        }
                    }), this.matrix = new iG, this.matrixWorld = new iG, this.matrixAutoUpdate = sp.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = sp.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new i6, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.customDepthMaterial = void 0, this.customDistanceMaterial = void 0, this.userData = {}
                }
                onBeforeShadow() {}
                onAfterShadow() {}
                onBeforeRender() {}
                onAfterRender() {}
                applyMatrix4(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
                }
                applyQuaternion(t) {
                    return this.quaternion.premultiply(t), this
                }
                setRotationFromAxisAngle(t, e) {
                    this.quaternion.setFromAxisAngle(t, e)
                }
                setRotationFromEuler(t) {
                    this.quaternion.setFromEuler(t, !0)
                }
                setRotationFromMatrix(t) {
                    this.quaternion.setFromRotationMatrix(t)
                }
                setRotationFromQuaternion(t) {
                    this.quaternion.copy(t)
                }
                rotateOnAxis(t, e) {
                    return i8.setFromAxisAngle(t, e), this.quaternion.multiply(i8), this
                }
                rotateOnWorldAxis(t, e) {
                    return i8.setFromAxisAngle(t, e), this.quaternion.premultiply(i8), this
                }
                rotateX(t) {
                    return this.rotateOnAxis(sn, t)
                }
                rotateY(t) {
                    return this.rotateOnAxis(sa, t)
                }
                rotateZ(t) {
                    return this.rotateOnAxis(so, t)
                }
                translateOnAxis(t, e) {
                    return i9.copy(t).applyQuaternion(this.quaternion), this.position.add(i9.multiplyScalar(e)), this
                }
                translateX(t) {
                    return this.translateOnAxis(sn, t)
                }
                translateY(t) {
                    return this.translateOnAxis(sa, t)
                }
                translateZ(t) {
                    return this.translateOnAxis(so, t)
                }
                localToWorld(t) {
                    return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld)
                }
                worldToLocal(t) {
                    return this.updateWorldMatrix(!0, !1), t.applyMatrix4(st.copy(this.matrixWorld).invert())
                }
                lookAt(t, e, i) {
                    t.isVector3 ? se.copy(t) : se.set(t, e, i);
                    let s = this.parent;
                    this.updateWorldMatrix(!0, !1), si.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? st.lookAt(si, se, this.up) : st.lookAt(se, si, this.up), this.quaternion.setFromRotationMatrix(st), s && (st.extractRotation(s.matrixWorld), i8.setFromRotationMatrix(st), this.quaternion.premultiply(i8.invert()))
                }
                add(t) {
                    if (arguments.length > 1) {
                        for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                        return this
                    }
                    return t === this ? eq("Object3D.add: object can't be added as a child of itself.", t) : t && t.isObject3D ? (t.removeFromParent(), t.parent = this, this.children.push(t), t.dispatchEvent(sh), su.child = t, this.dispatchEvent(su), su.child = null) : eq("Object3D.add: object not an instance of THREE.Object3D.", t), this
                }
                remove(t) {
                    if (arguments.length > 1) {
                        for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                        return this
                    }
                    let e = this.children.indexOf(t);
                    return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(sl), sc.child = t, this.dispatchEvent(sc), sc.child = null), this
                }
                removeFromParent() {
                    let t = this.parent;
                    return null !== t && t.remove(this), this
                }
                clear() {
                    return this.remove(...this.children)
                }
                attach(t) {
                    return this.updateWorldMatrix(!0, !1), st.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), st.multiply(t.parent.matrixWorld)), t.applyMatrix4(st), t.removeFromParent(), t.parent = this, this.children.push(t), t.updateWorldMatrix(!1, !0), t.dispatchEvent(sh), su.child = t, this.dispatchEvent(su), su.child = null, this
                }
                getObjectById(t) {
                    return this.getObjectByProperty("id", t)
                }
                getObjectByName(t) {
                    return this.getObjectByProperty("name", t)
                }
                getObjectByProperty(t, e) {
                    if (this[t] === e) return this;
                    for (let i = 0, s = this.children.length; i < s; i++) {
                        let s = this.children[i].getObjectByProperty(t, e);
                        if (void 0 !== s) return s
                    }
                }
                getObjectsByProperty(t, e, i = []) {
                    this[t] === e && i.push(this);
                    let s = this.children;
                    for (let r = 0, n = s.length; r < n; r++) s[r].getObjectsByProperty(t, e, i);
                    return i
                }
                getWorldPosition(t) {
                    return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
                }
                getWorldQuaternion(t) {
                    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(si, t, ss), t
                }
                getWorldScale(t) {
                    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(si, sr, t), t
                }
                getWorldDirection(t) {
                    this.updateWorldMatrix(!0, !1);
                    let e = this.matrixWorld.elements;
                    return t.set(e[8], e[9], e[10]).normalize()
                }
                raycast() {}
                traverse(t) {
                    t(this);
                    let e = this.children;
                    for (let i = 0, s = e.length; i < s; i++) e[i].traverse(t)
                }
                traverseVisible(t) {
                    if (!1 === this.visible) return;
                    t(this);
                    let e = this.children;
                    for (let i = 0, s = e.length; i < s; i++) e[i].traverseVisible(t)
                }
                traverseAncestors(t) {
                    let e = this.parent;
                    null !== e && (t(e), e.traverseAncestors(t))
                }
                updateMatrix() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                }
                updateMatrixWorld(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (!0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, t = !0);
                    let e = this.children;
                    for (let i = 0, s = e.length; i < s; i++) e[i].updateMatrixWorld(t)
                }
                updateWorldMatrix(t, e) {
                    let i = this.parent;
                    if (!0 === t && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), !0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), !0 === e) {
                        let t = this.children;
                        for (let e = 0, i = t.length; e < i; e++) t[e].updateWorldMatrix(!1, !0)
                    }
                }
                toJSON(t) {
                    let e = void 0 === t || "string" == typeof t,
                        i = {};
                    e && (t = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {},
                        skeletons: {},
                        animations: {},
                        nodes: {}
                    }, i.metadata = {
                        version: 4.7,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    let s = {};

                    function r(e, i) {
                        return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)), i.uuid
                    }
                    if (s.uuid = this.uuid, s.type = this.type, "" !== this.name && (s.name = this.name), !0 === this.castShadow && (s.castShadow = !0), !0 === this.receiveShadow && (s.receiveShadow = !0), !1 === this.visible && (s.visible = !1), !1 === this.frustumCulled && (s.frustumCulled = !1), 0 !== this.renderOrder && (s.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (s.userData = this.userData), s.layers = this.layers.mask, s.matrix = this.matrix.toArray(), s.up = this.up.toArray(), !1 === this.matrixAutoUpdate && (s.matrixAutoUpdate = !1), this.isInstancedMesh && (s.type = "InstancedMesh", s.count = this.count, s.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (s.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (s.type = "BatchedMesh", s.perObjectFrustumCulled = this.perObjectFrustumCulled, s.sortObjects = this.sortObjects, s.drawRanges = this._drawRanges, s.reservedRanges = this._reservedRanges, s.geometryInfo = this._geometryInfo.map(t => ({ ...t,
                            boundingBox: t.boundingBox ? t.boundingBox.toJSON() : void 0,
                            boundingSphere: t.boundingSphere ? t.boundingSphere.toJSON() : void 0
                        })), s.instanceInfo = this._instanceInfo.map(t => ({ ...t
                        })), s.availableInstanceIds = this._availableInstanceIds.slice(), s.availableGeometryIds = this._availableGeometryIds.slice(), s.nextIndexStart = this._nextIndexStart, s.nextVertexStart = this._nextVertexStart, s.geometryCount = this._geometryCount, s.maxInstanceCount = this._maxInstanceCount, s.maxVertexCount = this._maxVertexCount, s.maxIndexCount = this._maxIndexCount, s.geometryInitialized = this._geometryInitialized, s.matricesTexture = this._matricesTexture.toJSON(t), s.indirectTexture = this._indirectTexture.toJSON(t), null !== this._colorsTexture && (s.colorsTexture = this._colorsTexture.toJSON(t)), null !== this.boundingSphere && (s.boundingSphere = this.boundingSphere.toJSON()), null !== this.boundingBox && (s.boundingBox = this.boundingBox.toJSON())), this.isScene) this.background && (this.background.isColor ? s.background = this.background.toJSON() : this.background.isTexture && (s.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (s.environment = this.environment.toJSON(t).uuid);
                    else if (this.isMesh || this.isLine || this.isPoints) {
                        s.geometry = r(t.geometries, this.geometry);
                        let e = this.geometry.parameters;
                        if (void 0 !== e && void 0 !== e.shapes) {
                            let i = e.shapes;
                            if (Array.isArray(i))
                                for (let e = 0, s = i.length; e < s; e++) {
                                    let s = i[e];
                                    r(t.shapes, s)
                                } else r(t.shapes, i)
                        }
                    }
                    if (this.isSkinnedMesh && (s.bindMode = this.bindMode, s.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(t.skeletons, this.skeleton), s.skeleton = this.skeleton.uuid)), void 0 !== this.material) {
                        if (Array.isArray(this.material)) {
                            let e = [];
                            for (let i = 0, s = this.material.length; i < s; i++) e.push(r(t.materials, this.material[i]));
                            s.material = e
                        } else s.material = r(t.materials, this.material)
                    }
                    if (this.children.length > 0) {
                        s.children = [];
                        for (let e = 0; e < this.children.length; e++) s.children.push(this.children[e].toJSON(t).object)
                    }
                    if (this.animations.length > 0) {
                        s.animations = [];
                        for (let e = 0; e < this.animations.length; e++) {
                            let i = this.animations[e];
                            s.animations.push(r(t.animations, i))
                        }
                    }
                    if (e) {
                        let e = n(t.geometries),
                            s = n(t.materials),
                            r = n(t.textures),
                            a = n(t.images),
                            o = n(t.shapes),
                            h = n(t.skeletons),
                            l = n(t.animations),
                            u = n(t.nodes);
                        e.length > 0 && (i.geometries = e), s.length > 0 && (i.materials = s), r.length > 0 && (i.textures = r), a.length > 0 && (i.images = a), o.length > 0 && (i.shapes = o), h.length > 0 && (i.skeletons = h), l.length > 0 && (i.animations = l), u.length > 0 && (i.nodes = u)
                    }
                    return i.object = s, i;

                    function n(t) {
                        let e = [];
                        for (let i in t) {
                            let s = t[i];
                            delete s.metadata, e.push(s)
                        }
                        return e
                    }
                }
                clone(t) {
                    return new this.constructor().copy(this, t)
                }
                copy(t, e = !0) {
                    if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.animations = t.animations.slice(), this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                        for (let e = 0; e < t.children.length; e++) {
                            let i = t.children[e];
                            this.add(i.clone())
                        }
                    return this
                }
            }
            sp.DEFAULT_UP = new e9(0, 1, 0), sp.DEFAULT_MATRIX_AUTO_UPDATE = !0, sp.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
            let sd = new e9,
                sm = new e9,
                sy = new e9,
                sf = new e9,
                sg = new e9,
                sx = new e9,
                sb = new e9,
                sM = new e9,
                sv = new e9,
                sw = new e9,
                sS = new ig,
                s_ = new ig,
                sz = new ig;
            class sA {
                constructor(t = new e9, e = new e9, i = new e9) {
                    this.a = t, this.b = e, this.c = i
                }
                static getNormal(t, e, i, s) {
                    s.subVectors(i, e), sd.subVectors(t, e), s.cross(sd);
                    let r = s.lengthSq();
                    return r > 0 ? s.multiplyScalar(1 / Math.sqrt(r)) : s.set(0, 0, 0)
                }
                static getBarycoord(t, e, i, s, r) {
                    sd.subVectors(s, e), sm.subVectors(i, e), sy.subVectors(t, e);
                    let n = sd.dot(sd),
                        a = sd.dot(sm),
                        o = sd.dot(sy),
                        h = sm.dot(sm),
                        l = sm.dot(sy),
                        u = n * h - a * a;
                    if (0 === u) return r.set(0, 0, 0), null;
                    let c = 1 / u,
                        p = (h * o - a * l) * c,
                        d = (n * l - a * o) * c;
                    return r.set(1 - p - d, d, p)
                }
                static containsPoint(t, e, i, s) {
                    return null !== this.getBarycoord(t, e, i, s, sf) && sf.x >= 0 && sf.y >= 0 && sf.x + sf.y <= 1
                }
                static getInterpolation(t, e, i, s, r, n, a, o) {
                    return null === this.getBarycoord(t, e, i, s, sf) ? (o.x = 0, o.y = 0, "z" in o && (o.z = 0), "w" in o && (o.w = 0), null) : (o.setScalar(0), o.addScaledVector(r, sf.x), o.addScaledVector(n, sf.y), o.addScaledVector(a, sf.z), o)
                }
                static getInterpolatedAttribute(t, e, i, s, r, n) {
                    return sS.setScalar(0), s_.setScalar(0), sz.setScalar(0), sS.fromBufferAttribute(t, e), s_.fromBufferAttribute(t, i), sz.fromBufferAttribute(t, s), n.setScalar(0), n.addScaledVector(sS, r.x), n.addScaledVector(s_, r.y), n.addScaledVector(sz, r.z), n
                }
                static isFrontFacing(t, e, i, s) {
                    return sd.subVectors(i, e), sm.subVectors(t, e), 0 > sd.cross(sm).dot(s)
                }
                set(t, e, i) {
                    return this.a.copy(t), this.b.copy(e), this.c.copy(i), this
                }
                setFromPointsAndIndices(t, e, i, s) {
                    return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[s]), this
                }
                setFromAttributeAndIndices(t, e, i, s) {
                    return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, i), this.c.fromBufferAttribute(t, s), this
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(t) {
                    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                }
                getArea() {
                    return sd.subVectors(this.c, this.b), sm.subVectors(this.a, this.b), .5 * sd.cross(sm).length()
                }
                getMidpoint(t) {
                    return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                }
                getNormal(t) {
                    return sA.getNormal(this.a, this.b, this.c, t)
                }
                getPlane(t) {
                    return t.setFromCoplanarPoints(this.a, this.b, this.c)
                }
                getBarycoord(t, e) {
                    return sA.getBarycoord(t, this.a, this.b, this.c, e)
                }
                getInterpolation(t, e, i, s, r) {
                    return sA.getInterpolation(t, this.a, this.b, this.c, e, i, s, r)
                }
                containsPoint(t) {
                    return sA.containsPoint(t, this.a, this.b, this.c)
                }
                isFrontFacing(t) {
                    return sA.isFrontFacing(this.a, this.b, this.c, t)
                }
                intersectsBox(t) {
                    return t.intersectsTriangle(this)
                }
                closestPointToPoint(t, e) {
                    let i, s;
                    let r = this.a,
                        n = this.b,
                        a = this.c;
                    sg.subVectors(n, r), sx.subVectors(a, r), sM.subVectors(t, r);
                    let o = sg.dot(sM),
                        h = sx.dot(sM);
                    if (o <= 0 && h <= 0) return e.copy(r);
                    sv.subVectors(t, n);
                    let l = sg.dot(sv),
                        u = sx.dot(sv);
                    if (l >= 0 && u <= l) return e.copy(n);
                    let c = o * u - l * h;
                    if (c <= 0 && o >= 0 && l <= 0) return i = o / (o - l), e.copy(r).addScaledVector(sg, i);
                    sw.subVectors(t, a);
                    let p = sg.dot(sw),
                        d = sx.dot(sw);
                    if (d >= 0 && p <= d) return e.copy(a);
                    let m = p * h - o * d;
                    if (m <= 0 && h >= 0 && d <= 0) return s = h / (h - d), e.copy(r).addScaledVector(sx, s);
                    let y = l * d - p * u;
                    if (y <= 0 && u - l >= 0 && p - d >= 0) return sb.subVectors(a, n), s = (u - l) / (u - l + (p - d)), e.copy(n).addScaledVector(sb, s);
                    let f = 1 / (y + m + c);
                    return i = m * f, s = c * f, e.copy(r).addScaledVector(sg, i).addScaledVector(sx, s)
                }
                equals(t) {
                    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                }
            }
            let sT = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                },
                sC = {
                    h: 0,
                    s: 0,
                    l: 0
                },
                sO = {
                    h: 0,
                    s: 0,
                    l: 0
                };

            function sk(t, e, i) {
                return (i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6) ? t + (e - t) * 6 * i : i < .5 ? e : i < 2 / 3 ? t + (e - t) * 6 * (2 / 3 - i) : t
            }
            class sB {
                constructor(t, e, i) {
                    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(t, e, i)
                }
                set(t, e, i) {
                    return void 0 === e && void 0 === i ? t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t) : this.setRGB(t, e, i), this
                }
                setScalar(t) {
                    return this.r = t, this.g = t, this.b = t, this
                }
                setHex(t, e = ez) {
                    return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, ia.colorSpaceToWorking(this, e), this
                }
                setRGB(t, e, i, s = ia.workingColorSpace) {
                    return this.r = t, this.g = e, this.b = i, ia.colorSpaceToWorking(this, s), this
                }
                setHSL(t, e, i, s = ia.workingColorSpace) {
                    if (t = e1(t, 1), e = e0(e, 0, 1), i = e0(i, 0, 1), 0 === e) this.r = this.g = this.b = i;
                    else {
                        let s = i <= .5 ? i * (1 + e) : i + e - i * e,
                            r = 2 * i - s;
                        this.r = sk(r, s, t + 1 / 3), this.g = sk(r, s, t), this.b = sk(r, s, t - 1 / 3)
                    }
                    return ia.colorSpaceToWorking(this, s), this
                }
                setStyle(t, e = ez) {
                    let i;

                    function s(e) {
                        void 0 !== e && 1 > parseFloat(e) && eJ("Color: Alpha component of " + t + " will be ignored.")
                    }
                    if (i = /^(\w+)\(([^\)]*)\)/.exec(t)) {
                        let r;
                        let n = i[1],
                            a = i[2];
                        switch (n) {
                            case "rgb":
                            case "rgba":
                                if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return s(r[4]), this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, e);
                                if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return s(r[4]), this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, e);
                                break;
                            case "hsl":
                            case "hsla":
                                if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return s(r[4]), this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, e);
                                break;
                            default:
                                eJ("Color: Unknown color model " + t)
                        }
                    } else if (i = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                        let s = i[1],
                            r = s.length;
                        if (3 === r) return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, e);
                        if (6 === r) return this.setHex(parseInt(s, 16), e);
                        eJ("Color: Invalid hex color " + t)
                    } else if (t && t.length > 0) return this.setColorName(t, e);
                    return this
                }
                setColorName(t, e = ez) {
                    let i = sT[t.toLowerCase()];
                    return void 0 !== i ? this.setHex(i, e) : eJ("Color: Unknown color " + t), this
                }
                clone() {
                    return new this.constructor(this.r, this.g, this.b)
                }
                copy(t) {
                    return this.r = t.r, this.g = t.g, this.b = t.b, this
                }
                copySRGBToLinear(t) {
                    return this.r = io(t.r), this.g = io(t.g), this.b = io(t.b), this
                }
                copyLinearToSRGB(t) {
                    return this.r = ih(t.r), this.g = ih(t.g), this.b = ih(t.b), this
                }
                convertSRGBToLinear() {
                    return this.copySRGBToLinear(this), this
                }
                convertLinearToSRGB() {
                    return this.copyLinearToSRGB(this), this
                }
                getHex(t = ez) {
                    return ia.workingToColorSpace(sN.copy(this), t), 65536 * Math.round(e0(255 * sN.r, 0, 255)) + 256 * Math.round(e0(255 * sN.g, 0, 255)) + Math.round(e0(255 * sN.b, 0, 255))
                }
                getHexString(t = ez) {
                    return ("000000" + this.getHex(t).toString(16)).slice(-6)
                }
                getHSL(t, e = ia.workingColorSpace) {
                    let i, s;
                    ia.workingToColorSpace(sN.copy(this), e);
                    let r = sN.r,
                        n = sN.g,
                        a = sN.b,
                        o = Math.max(r, n, a),
                        h = Math.min(r, n, a),
                        l = (h + o) / 2;
                    if (h === o) i = 0, s = 0;
                    else {
                        let t = o - h;
                        switch (s = l <= .5 ? t / (o + h) : t / (2 - o - h), o) {
                            case r:
                                i = (n - a) / t + (n < a ? 6 : 0);
                                break;
                            case n:
                                i = (a - r) / t + 2;
                                break;
                            case a:
                                i = (r - n) / t + 4
                        }
                        i /= 6
                    }
                    return t.h = i, t.s = s, t.l = l, t
                }
                getRGB(t, e = ia.workingColorSpace) {
                    return ia.workingToColorSpace(sN.copy(this), e), t.r = sN.r, t.g = sN.g, t.b = sN.b, t
                }
                getStyle(t = ez) {
                    ia.workingToColorSpace(sN.copy(this), t);
                    let e = sN.r,
                        i = sN.g,
                        s = sN.b;
                    return t !== ez ? `color(${t} ${e.toFixed(3)} ${i.toFixed(3)} ${s.toFixed(3)})` : `rgb(${Math.round(255*e)},${Math.round(255*i)},${Math.round(255*s)})`
                }
                offsetHSL(t, e, i) {
                    return this.getHSL(sC), this.setHSL(sC.h + t, sC.s + e, sC.l + i)
                }
                add(t) {
                    return this.r += t.r, this.g += t.g, this.b += t.b, this
                }
                addColors(t, e) {
                    return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
                }
                addScalar(t) {
                    return this.r += t, this.g += t, this.b += t, this
                }
                sub(t) {
                    return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
                }
                multiply(t) {
                    return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
                }
                multiplyScalar(t) {
                    return this.r *= t, this.g *= t, this.b *= t, this
                }
                lerp(t, e) {
                    return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
                }
                lerpColors(t, e, i) {
                    return this.r = t.r + (e.r - t.r) * i, this.g = t.g + (e.g - t.g) * i, this.b = t.b + (e.b - t.b) * i, this
                }
                lerpHSL(t, e) {
                    this.getHSL(sC), t.getHSL(sO);
                    let i = e2(sC.h, sO.h, e),
                        s = e2(sC.s, sO.s, e),
                        r = e2(sC.l, sO.l, e);
                    return this.setHSL(i, s, r), this
                }
                setFromVector3(t) {
                    return this.r = t.x, this.g = t.y, this.b = t.z, this
                }
                applyMatrix3(t) {
                    let e = this.r,
                        i = this.g,
                        s = this.b,
                        r = t.elements;
                    return this.r = r[0] * e + r[3] * i + r[6] * s, this.g = r[1] * e + r[4] * i + r[7] * s, this.b = r[2] * e + r[5] * i + r[8] * s, this
                }
                equals(t) {
                    return t.r === this.r && t.g === this.g && t.b === this.b
                }
                fromArray(t, e = 0) {
                    return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
                }
                fromBufferAttribute(t, e) {
                    return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this
                }
                toJSON() {
                    return this.getHex()
                }*[Symbol.iterator]() {
                    yield this.r, yield this.g, yield this.b
                }
            }
            let sN = new sB;
            sB.NAMES = sT;
            let sI = 0;
            class sP extends eX {
                constructor() {
                    super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
                        value: sI++
                    }), this.uuid = eK(), this.name = "", this.type = "Material", this.blending = g, this.side = d, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = B, this.blendDst = N, this.blendEquation = w, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new sB(0, 0, 0), this.blendAlpha = 0, this.depthFunc = q, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.allowOverride = !0, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
                }
                get alphaTest() {
                    return this._alphaTest
                }
                set alphaTest(t) {
                    this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t
                }
                onBeforeRender() {}
                onBeforeCompile() {}
                customProgramCacheKey() {
                    return this.onBeforeCompile.toString()
                }
                setValues(t) {
                    if (void 0 !== t)
                        for (let e in t) {
                            let i = t[e];
                            if (void 0 === i) {
                                eJ(`Material: parameter '${e}' has value of undefined.`);
                                continue
                            }
                            let s = this[e];
                            if (void 0 === s) {
                                eJ(`Material: '${e}' is not a property of THREE.${this.type}.`);
                                continue
                            }
                            s && s.isColor ? s.set(i) : s && s.isVector3 && i && i.isVector3 ? s.copy(i) : this[e] = i
                        }
                }
                toJSON(t) {
                    let e = void 0 === t || "string" == typeof t;
                    e && (t = {
                        textures: {},
                        images: {}
                    });
                    let i = {
                        metadata: {
                            version: 4.7,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };

                    function s(t) {
                        let e = [];
                        for (let i in t) {
                            let s = t[i];
                            delete s.metadata, e.push(s)
                        }
                        return e
                    }
                    if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), void 0 !== this.sheen && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), void 0 !== this.emissiveIntensity && 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.sheenColorMap && this.sheenColorMap.isTexture && (i.sheenColorMap = this.sheenColorMap.toJSON(t).uuid), this.sheenRoughnessMap && this.sheenRoughnessMap.isTexture && (i.sheenRoughnessMap = this.sheenRoughnessMap.toJSON(t).uuid), void 0 !== this.dispersion && (i.dispersion = this.dispersion), void 0 !== this.iridescence && (i.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (i.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), void 0 !== this.anisotropy && (i.anisotropy = this.anisotropy), void 0 !== this.anisotropyRotation && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(t).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(t).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (i.combine = this.combine)), void 0 !== this.envMapRotation && (i.envMapRotation = this.envMapRotation.toArray()), void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (i.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (i.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (i.size = this.size), null !== this.shadowSide && (i.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== g && (i.blending = this.blending), this.side !== d && (i.side = this.side), !0 === this.vertexColors && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), !0 === this.transparent && (i.transparent = !0), this.blendSrc !== B && (i.blendSrc = this.blendSrc), this.blendDst !== N && (i.blendDst = this.blendDst), this.blendEquation !== w && (i.blendEquation = this.blendEquation), null !== this.blendSrcAlpha && (i.blendSrcAlpha = this.blendSrcAlpha), null !== this.blendDstAlpha && (i.blendDstAlpha = this.blendDstAlpha), null !== this.blendEquationAlpha && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), 0 !== this.blendAlpha && (i.blendAlpha = this.blendAlpha), this.depthFunc !== q && (i.depthFunc = this.depthFunc), !1 === this.depthTest && (i.depthTest = this.depthTest), !1 === this.depthWrite && (i.depthWrite = this.depthWrite), !1 === this.colorWrite && (i.colorWrite = this.colorWrite), 255 !== this.stencilWriteMask && (i.stencilWriteMask = this.stencilWriteMask), 519 !== this.stencilFunc && (i.stencilFunc = this.stencilFunc), 0 !== this.stencilRef && (i.stencilRef = this.stencilRef), 255 !== this.stencilFuncMask && (i.stencilFuncMask = this.stencilFuncMask), 7680 !== this.stencilFail && (i.stencilFail = this.stencilFail), 7680 !== this.stencilZFail && (i.stencilZFail = this.stencilZFail), 7680 !== this.stencilZPass && (i.stencilZPass = this.stencilZPass), !0 === this.stencilWrite && (i.stencilWrite = this.stencilWrite), void 0 !== this.rotation && 0 !== this.rotation && (i.rotation = this.rotation), !0 === this.polygonOffset && (i.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), !0 === this.dithering && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), !0 === this.alphaHash && (i.alphaHash = !0), !0 === this.alphaToCoverage && (i.alphaToCoverage = !0), !0 === this.premultipliedAlpha && (i.premultipliedAlpha = !0), !0 === this.forceSinglePass && (i.forceSinglePass = !0), !1 === this.allowOverride && (i.allowOverride = !1), !0 === this.wireframe && (i.wireframe = !0), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (i.flatShading = !0), !1 === this.visible && (i.visible = !1), !1 === this.toneMapped && (i.toneMapped = !1), !1 === this.fog && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData), e) {
                        let e = s(t.textures),
                            r = s(t.images);
                        e.length > 0 && (i.textures = e), r.length > 0 && (i.images = r)
                    }
                    return i
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(t) {
                    this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.blendColor.copy(t.blendColor), this.blendAlpha = t.blendAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
                    let e = t.clippingPlanes,
                        i = null;
                    if (null !== e) {
                        let t = e.length;
                        i = Array(t);
                        for (let s = 0; s !== t; ++s) i[s] = e[s].clone()
                    }
                    return this.clippingPlanes = i, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaHash = t.alphaHash, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.allowOverride = t.allowOverride, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                set needsUpdate(t) {
                    !0 === t && this.version++
                }
            }
            class sR extends sP {
                constructor(t) {
                    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new sB(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new i4, this.combine = H, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this
                }
            }
            let sV = new e9,
                sL = new e6,
                sE = 0;
            class sF {
                constructor(t, e, i = !1) {
                    if (Array.isArray(t)) throw TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    this.isBufferAttribute = !0, Object.defineProperty(this, "id", {
                        value: sE++
                    }), this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = i, this.usage = 35044, this.updateRanges = [], this.gpuType = tC, this.version = 0
                }
                onUploadCallback() {}
                set needsUpdate(t) {
                    !0 === t && this.version++
                }
                setUsage(t) {
                    return this.usage = t, this
                }
                addUpdateRange(t, e) {
                    this.updateRanges.push({
                        start: t,
                        count: e
                    })
                }
                clearUpdateRanges() {
                    this.updateRanges.length = 0
                }
                copy(t) {
                    return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this.gpuType = t.gpuType, this
                }
                copyAt(t, e, i) {
                    t *= this.itemSize, i *= e.itemSize;
                    for (let s = 0, r = this.itemSize; s < r; s++) this.array[t + s] = e.array[i + s];
                    return this
                }
                copyArray(t) {
                    return this.array.set(t), this
                }
                applyMatrix3(t) {
                    if (2 === this.itemSize)
                        for (let e = 0, i = this.count; e < i; e++) sL.fromBufferAttribute(this, e), sL.applyMatrix3(t), this.setXY(e, sL.x, sL.y);
                    else if (3 === this.itemSize)
                        for (let e = 0, i = this.count; e < i; e++) sV.fromBufferAttribute(this, e), sV.applyMatrix3(t), this.setXYZ(e, sV.x, sV.y, sV.z);
                    return this
                }
                applyMatrix4(t) {
                    for (let e = 0, i = this.count; e < i; e++) sV.fromBufferAttribute(this, e), sV.applyMatrix4(t), this.setXYZ(e, sV.x, sV.y, sV.z);
                    return this
                }
                applyNormalMatrix(t) {
                    for (let e = 0, i = this.count; e < i; e++) sV.fromBufferAttribute(this, e), sV.applyNormalMatrix(t), this.setXYZ(e, sV.x, sV.y, sV.z);
                    return this
                }
                transformDirection(t) {
                    for (let e = 0, i = this.count; e < i; e++) sV.fromBufferAttribute(this, e), sV.transformDirection(t), this.setXYZ(e, sV.x, sV.y, sV.z);
                    return this
                }
                set(t, e = 0) {
                    return this.array.set(t, e), this
                }
                getComponent(t, e) {
                    let i = this.array[t * this.itemSize + e];
                    return this.normalized && (i = e3(i, this.array)), i
                }
                setComponent(t, e, i) {
                    return this.normalized && (i = e5(i, this.array)), this.array[t * this.itemSize + e] = i, this
                }
                getX(t) {
                    let e = this.array[t * this.itemSize];
                    return this.normalized && (e = e3(e, this.array)), e
                }
                setX(t, e) {
                    return this.normalized && (e = e5(e, this.array)), this.array[t * this.itemSize] = e, this
                }
                getY(t) {
                    let e = this.array[t * this.itemSize + 1];
                    return this.normalized && (e = e3(e, this.array)), e
                }
                setY(t, e) {
                    return this.normalized && (e = e5(e, this.array)), this.array[t * this.itemSize + 1] = e, this
                }
                getZ(t) {
                    let e = this.array[t * this.itemSize + 2];
                    return this.normalized && (e = e3(e, this.array)), e
                }
                setZ(t, e) {
                    return this.normalized && (e = e5(e, this.array)), this.array[t * this.itemSize + 2] = e, this
                }
                getW(t) {
                    let e = this.array[t * this.itemSize + 3];
                    return this.normalized && (e = e3(e, this.array)), e
                }
                setW(t, e) {
                    return this.normalized && (e = e5(e, this.array)), this.array[t * this.itemSize + 3] = e, this
                }
                setXY(t, e, i) {
                    return t *= this.itemSize, this.normalized && (e = e5(e, this.array), i = e5(i, this.array)), this.array[t + 0] = e, this.array[t + 1] = i, this
                }
                setXYZ(t, e, i, s) {
                    return t *= this.itemSize, this.normalized && (e = e5(e, this.array), i = e5(i, this.array), s = e5(s, this.array)), this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = s, this
                }
                setXYZW(t, e, i, s, r) {
                    return t *= this.itemSize, this.normalized && (e = e5(e, this.array), i = e5(i, this.array), s = e5(s, this.array), r = e5(r, this.array)), this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = s, this.array[t + 3] = r, this
                }
                onUpload(t) {
                    return this.onUploadCallback = t, this
                }
                clone() {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                }
                toJSON() {
                    let t = {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: Array.from(this.array),
                        normalized: this.normalized
                    };
                    return "" !== this.name && (t.name = this.name), 35044 !== this.usage && (t.usage = this.usage), t
                }
            }
            class sD extends sF {
                constructor(t, e, i) {
                    super(new Uint16Array(t), e, i)
                }
            }
            class sj extends sF {
                constructor(t, e, i) {
                    super(new Uint32Array(t), e, i)
                }
            }
            class sU extends sF {
                constructor(t, e, i) {
                    super(new Float32Array(t), e, i)
                }
            }
            let sW = 0,
                sJ = new iG,
                sq = new sp,
                sZ = new e9,
                sY = new iw,
                sX = new iw,
                sG = new e9;
            class sH extends eX {
                constructor() {
                    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
                        value: sW++
                    }), this.uuid = eK(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.indirectOffset = 0, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                        start: 0,
                        count: 1 / 0
                    }, this.userData = {}
                }
                getIndex() {
                    return this.index
                }
                setIndex(t) {
                    return Array.isArray(t) ? this.index = new(eF(t) ? sj : sD)(t, 1) : this.index = t, this
                }
                setIndirect(t, e = 0) {
                    return this.indirect = t, this.indirectOffset = e, this
                }
                getIndirect() {
                    return this.indirect
                }
                getAttribute(t) {
                    return this.attributes[t]
                }
                setAttribute(t, e) {
                    return this.attributes[t] = e, this
                }
                deleteAttribute(t) {
                    return delete this.attributes[t], this
                }
                hasAttribute(t) {
                    return void 0 !== this.attributes[t]
                }
                addGroup(t, e, i = 0) {
                    this.groups.push({
                        start: t,
                        count: e,
                        materialIndex: i
                    })
                }
                clearGroups() {
                    this.groups = []
                }
                setDrawRange(t, e) {
                    this.drawRange.start = t, this.drawRange.count = e
                }
                applyMatrix4(t) {
                    let e = this.attributes.position;
                    void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                    let i = this.attributes.normal;
                    if (void 0 !== i) {
                        let e = new ie().getNormalMatrix(t);
                        i.applyNormalMatrix(e), i.needsUpdate = !0
                    }
                    let s = this.attributes.tangent;
                    return void 0 !== s && (s.transformDirection(t), s.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                }
                applyQuaternion(t) {
                    return sJ.makeRotationFromQuaternion(t), this.applyMatrix4(sJ), this
                }
                rotateX(t) {
                    return sJ.makeRotationX(t), this.applyMatrix4(sJ), this
                }
                rotateY(t) {
                    return sJ.makeRotationY(t), this.applyMatrix4(sJ), this
                }
                rotateZ(t) {
                    return sJ.makeRotationZ(t), this.applyMatrix4(sJ), this
                }
                translate(t, e, i) {
                    return sJ.makeTranslation(t, e, i), this.applyMatrix4(sJ), this
                }
                scale(t, e, i) {
                    return sJ.makeScale(t, e, i), this.applyMatrix4(sJ), this
                }
                lookAt(t) {
                    return sq.lookAt(t), sq.updateMatrix(), this.applyMatrix4(sq.matrix), this
                }
                center() {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(sZ).negate(), this.translate(sZ.x, sZ.y, sZ.z), this
                }
                setFromPoints(t) {
                    let e = this.getAttribute("position");
                    if (void 0 === e) {
                        let e = [];
                        for (let i = 0, s = t.length; i < s; i++) {
                            let s = t[i];
                            e.push(s.x, s.y, s.z || 0)
                        }
                        this.setAttribute("position", new sU(e, 3))
                    } else {
                        let i = Math.min(t.length, e.count);
                        for (let s = 0; s < i; s++) {
                            let i = t[s];
                            e.setXYZ(s, i.x, i.y, i.z || 0)
                        }
                        t.length > e.count && eJ("BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), e.needsUpdate = !0
                    }
                    return this
                }
                computeBoundingBox() {
                    null === this.boundingBox && (this.boundingBox = new iw);
                    let t = this.attributes.position,
                        e = this.morphAttributes.position;
                    if (t && t.isGLBufferAttribute) {
                        eq("BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new e9(-1 / 0, -1 / 0, -1 / 0), new e9(Infinity, Infinity, Infinity));
                        return
                    }
                    if (void 0 !== t) {
                        if (this.boundingBox.setFromBufferAttribute(t), e)
                            for (let t = 0, i = e.length; t < i; t++) {
                                let i = e[t];
                                sY.setFromBufferAttribute(i), this.morphTargetsRelative ? (sG.addVectors(this.boundingBox.min, sY.min), this.boundingBox.expandByPoint(sG), sG.addVectors(this.boundingBox.max, sY.max), this.boundingBox.expandByPoint(sG)) : (this.boundingBox.expandByPoint(sY.min), this.boundingBox.expandByPoint(sY.max))
                            }
                    } else this.boundingBox.makeEmpty();
                    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && eq('BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                }
                computeBoundingSphere() {
                    null === this.boundingSphere && (this.boundingSphere = new iD);
                    let t = this.attributes.position,
                        e = this.morphAttributes.position;
                    if (t && t.isGLBufferAttribute) {
                        eq("BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new e9, 1 / 0);
                        return
                    }
                    if (t) {
                        let i = this.boundingSphere.center;
                        if (sY.setFromBufferAttribute(t), e)
                            for (let t = 0, i = e.length; t < i; t++) {
                                let i = e[t];
                                sX.setFromBufferAttribute(i), this.morphTargetsRelative ? (sG.addVectors(sY.min, sX.min), sY.expandByPoint(sG), sG.addVectors(sY.max, sX.max), sY.expandByPoint(sG)) : (sY.expandByPoint(sX.min), sY.expandByPoint(sX.max))
                            }
                        sY.getCenter(i);
                        let s = 0;
                        for (let e = 0, r = t.count; e < r; e++) sG.fromBufferAttribute(t, e), s = Math.max(s, i.distanceToSquared(sG));
                        if (e)
                            for (let r = 0, n = e.length; r < n; r++) {
                                let n = e[r],
                                    a = this.morphTargetsRelative;
                                for (let e = 0, r = n.count; e < r; e++) sG.fromBufferAttribute(n, e), a && (sZ.fromBufferAttribute(t, e), sG.add(sZ)), s = Math.max(s, i.distanceToSquared(sG))
                            }
                        this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && eq('BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                }
                computeTangents() {
                    let t = this.index,
                        e = this.attributes;
                    if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) {
                        eq("BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                        return
                    }
                    let i = e.position,
                        s = e.normal,
                        r = e.uv;
                    !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new sF(new Float32Array(4 * i.count), 4));
                    let n = this.getAttribute("tangent"),
                        a = [],
                        o = [];
                    for (let t = 0; t < i.count; t++) a[t] = new e9, o[t] = new e9;
                    let h = new e9,
                        l = new e9,
                        u = new e9,
                        c = new e6,
                        p = new e6,
                        d = new e6,
                        m = new e9,
                        y = new e9,
                        f = this.groups;
                    0 === f.length && (f = [{
                        start: 0,
                        count: t.count
                    }]);
                    for (let e = 0, s = f.length; e < s; ++e) {
                        let s = f[e],
                            n = s.start,
                            g = s.count;
                        for (let e = n, s = n + g; e < s; e += 3) ! function(t, e, s) {
                            h.fromBufferAttribute(i, t), l.fromBufferAttribute(i, e), u.fromBufferAttribute(i, s), c.fromBufferAttribute(r, t), p.fromBufferAttribute(r, e), d.fromBufferAttribute(r, s), l.sub(h), u.sub(h), p.sub(c), d.sub(c);
                            let n = 1 / (p.x * d.y - d.x * p.y);
                            isFinite(n) && (m.copy(l).multiplyScalar(d.y).addScaledVector(u, -p.y).multiplyScalar(n), y.copy(u).multiplyScalar(p.x).addScaledVector(l, -d.x).multiplyScalar(n), a[t].add(m), a[e].add(m), a[s].add(m), o[t].add(y), o[e].add(y), o[s].add(y))
                        }(t.getX(e + 0), t.getX(e + 1), t.getX(e + 2))
                    }
                    let g = new e9,
                        x = new e9,
                        b = new e9,
                        M = new e9;

                    function v(t) {
                        b.fromBufferAttribute(s, t), M.copy(b);
                        let e = a[t];
                        g.copy(e), g.sub(b.multiplyScalar(b.dot(e))).normalize(), x.crossVectors(M, e);
                        let i = x.dot(o[t]);
                        n.setXYZW(t, g.x, g.y, g.z, i < 0 ? -1 : 1)
                    }
                    for (let e = 0, i = f.length; e < i; ++e) {
                        let i = f[e],
                            s = i.start,
                            r = i.count;
                        for (let e = s, i = s + r; e < i; e += 3) v(t.getX(e + 0)), v(t.getX(e + 1)), v(t.getX(e + 2))
                    }
                }
                computeVertexNormals() {
                    let t = this.index,
                        e = this.getAttribute("position");
                    if (void 0 !== e) {
                        let i = this.getAttribute("normal");
                        if (void 0 === i) i = new sF(new Float32Array(3 * e.count), 3), this.setAttribute("normal", i);
                        else
                            for (let t = 0, e = i.count; t < e; t++) i.setXYZ(t, 0, 0, 0);
                        let s = new e9,
                            r = new e9,
                            n = new e9,
                            a = new e9,
                            o = new e9,
                            h = new e9,
                            l = new e9,
                            u = new e9;
                        if (t)
                            for (let c = 0, p = t.count; c < p; c += 3) {
                                let p = t.getX(c + 0),
                                    d = t.getX(c + 1),
                                    m = t.getX(c + 2);
                                s.fromBufferAttribute(e, p), r.fromBufferAttribute(e, d), n.fromBufferAttribute(e, m), l.subVectors(n, r), u.subVectors(s, r), l.cross(u), a.fromBufferAttribute(i, p), o.fromBufferAttribute(i, d), h.fromBufferAttribute(i, m), a.add(l), o.add(l), h.add(l), i.setXYZ(p, a.x, a.y, a.z), i.setXYZ(d, o.x, o.y, o.z), i.setXYZ(m, h.x, h.y, h.z)
                            } else
                                for (let t = 0, a = e.count; t < a; t += 3) s.fromBufferAttribute(e, t + 0), r.fromBufferAttribute(e, t + 1), n.fromBufferAttribute(e, t + 2), l.subVectors(n, r), u.subVectors(s, r), l.cross(u), i.setXYZ(t + 0, l.x, l.y, l.z), i.setXYZ(t + 1, l.x, l.y, l.z), i.setXYZ(t + 2, l.x, l.y, l.z);
                        this.normalizeNormals(), i.needsUpdate = !0
                    }
                }
                normalizeNormals() {
                    let t = this.attributes.normal;
                    for (let e = 0, i = t.count; e < i; e++) sG.fromBufferAttribute(t, e), sG.normalize(), t.setXYZ(e, sG.x, sG.y, sG.z)
                }
                toNonIndexed() {
                    function t(t, e) {
                        let i = t.array,
                            s = t.itemSize,
                            r = t.normalized,
                            n = new i.constructor(e.length * s),
                            a = 0,
                            o = 0;
                        for (let r = 0, h = e.length; r < h; r++) {
                            a = t.isInterleavedBufferAttribute ? e[r] * t.data.stride + t.offset : e[r] * s;
                            for (let t = 0; t < s; t++) n[o++] = i[a++]
                        }
                        return new sF(n, s, r)
                    }
                    if (null === this.index) return eJ("BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                    let e = new sH,
                        i = this.index.array,
                        s = this.attributes;
                    for (let r in s) {
                        let n = t(s[r], i);
                        e.setAttribute(r, n)
                    }
                    let r = this.morphAttributes;
                    for (let s in r) {
                        let n = [],
                            a = r[s];
                        for (let e = 0, s = a.length; e < s; e++) {
                            let s = t(a[e], i);
                            n.push(s)
                        }
                        e.morphAttributes[s] = n
                    }
                    e.morphTargetsRelative = this.morphTargetsRelative;
                    let n = this.groups;
                    for (let t = 0, i = n.length; t < i; t++) {
                        let i = n[t];
                        e.addGroup(i.start, i.count, i.materialIndex)
                    }
                    return e
                }
                toJSON() {
                    let t = {
                        metadata: {
                            version: 4.7,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                        let e = this.parameters;
                        for (let i in e) void 0 !== e[i] && (t[i] = e[i]);
                        return t
                    }
                    t.data = {
                        attributes: {}
                    };
                    let e = this.index;
                    null !== e && (t.data.index = {
                        type: e.array.constructor.name,
                        array: Array.prototype.slice.call(e.array)
                    });
                    let i = this.attributes;
                    for (let e in i) {
                        let s = i[e];
                        t.data.attributes[e] = s.toJSON(t.data)
                    }
                    let s = {},
                        r = !1;
                    for (let e in this.morphAttributes) {
                        let i = this.morphAttributes[e],
                            n = [];
                        for (let e = 0, s = i.length; e < s; e++) {
                            let s = i[e];
                            n.push(s.toJSON(t.data))
                        }
                        n.length > 0 && (s[e] = n, r = !0)
                    }
                    r && (t.data.morphAttributes = s, t.data.morphTargetsRelative = this.morphTargetsRelative);
                    let n = this.groups;
                    n.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(n)));
                    let a = this.boundingSphere;
                    return null !== a && (t.data.boundingSphere = a.toJSON()), t
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(t) {
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                    let e = {};
                    this.name = t.name;
                    let i = t.index;
                    null !== i && this.setIndex(i.clone());
                    let s = t.attributes;
                    for (let t in s) {
                        let i = s[t];
                        this.setAttribute(t, i.clone(e))
                    }
                    let r = t.morphAttributes;
                    for (let t in r) {
                        let i = [],
                            s = r[t];
                        for (let t = 0, r = s.length; t < r; t++) i.push(s[t].clone(e));
                        this.morphAttributes[t] = i
                    }
                    this.morphTargetsRelative = t.morphTargetsRelative;
                    let n = t.groups;
                    for (let t = 0, e = n.length; t < e; t++) {
                        let e = n[t];
                        this.addGroup(e.start, e.count, e.materialIndex)
                    }
                    let a = t.boundingBox;
                    null !== a && (this.boundingBox = a.clone());
                    let o = t.boundingSphere;
                    return null !== o && (this.boundingSphere = o.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            let sQ = new iG,
                s$ = new iX,
                sK = new iD,
                s0 = new e9,
                s1 = new e9,
                s2 = new e9,
                s3 = new e9,
                s5 = new e9,
                s4 = new e9,
                s6 = new e9,
                s7 = new e9;
            class s9 extends sp {
                constructor(t = new sH, e = new sR) {
                    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = t, this.material = e, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.count = 1, this.updateMorphTargets()
                }
                copy(t, e) {
                    return super.copy(t, e), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this
                }
                updateMorphTargets() {
                    let t = this.geometry.morphAttributes,
                        e = Object.keys(t);
                    if (e.length > 0) {
                        let i = t[e[0]];
                        if (void 0 !== i) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let t = 0, e = i.length; t < e; t++) {
                                let e = i[t].name || String(t);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                            }
                        }
                    }
                }
                getVertexPosition(t, e) {
                    let i = this.geometry,
                        s = i.attributes.position,
                        r = i.morphAttributes.position,
                        n = i.morphTargetsRelative;
                    e.fromBufferAttribute(s, t);
                    let a = this.morphTargetInfluences;
                    if (r && a) {
                        s4.set(0, 0, 0);
                        for (let i = 0, s = r.length; i < s; i++) {
                            let s = a[i],
                                o = r[i];
                            0 !== s && (s5.fromBufferAttribute(o, t), n ? s4.addScaledVector(s5, s) : s4.addScaledVector(s5.sub(e), s))
                        }
                        e.add(s4)
                    }
                    return e
                }
                raycast(t, e) {
                    let i = this.geometry,
                        s = this.material,
                        r = this.matrixWorld;
                    if (void 0 !== s) {
                        if (null === i.boundingSphere && i.computeBoundingSphere(), sK.copy(i.boundingSphere), sK.applyMatrix4(r), s$.copy(t.ray).recast(t.near), !1 === sK.containsPoint(s$.origin) && (null === s$.intersectSphere(sK, s0) || s$.origin.distanceToSquared(s0) > (t.far - t.near) ** 2) || (sQ.copy(r).invert(), s$.copy(t.ray).applyMatrix4(sQ), null !== i.boundingBox && !1 === s$.intersectsBox(i.boundingBox))) return;
                        this._computeIntersections(t, e, s$)
                    }
                }
                _computeIntersections(t, e, i) {
                    let s;
                    let r = this.geometry,
                        n = this.material,
                        a = r.index,
                        o = r.attributes.position,
                        h = r.attributes.uv,
                        l = r.attributes.uv1,
                        u = r.attributes.normal,
                        c = r.groups,
                        p = r.drawRange;
                    if (null !== a) {
                        if (Array.isArray(n))
                            for (let r = 0, o = c.length; r < o; r++) {
                                let o = c[r],
                                    d = n[o.materialIndex],
                                    m = Math.max(o.start, p.start),
                                    y = Math.min(a.count, Math.min(o.start + o.count, p.start + p.count));
                                for (let r = m; r < y; r += 3)(s = s8(this, d, t, i, h, l, u, a.getX(r), a.getX(r + 1), a.getX(r + 2))) && (s.faceIndex = Math.floor(r / 3), s.face.materialIndex = o.materialIndex, e.push(s))
                            } else {
                                let r = Math.max(0, p.start),
                                    o = Math.min(a.count, p.start + p.count);
                                for (let c = r; c < o; c += 3)(s = s8(this, n, t, i, h, l, u, a.getX(c), a.getX(c + 1), a.getX(c + 2))) && (s.faceIndex = Math.floor(c / 3), e.push(s))
                            }
                    } else if (void 0 !== o) {
                        if (Array.isArray(n))
                            for (let r = 0, a = c.length; r < a; r++) {
                                let a = c[r],
                                    d = n[a.materialIndex],
                                    m = Math.max(a.start, p.start),
                                    y = Math.min(o.count, Math.min(a.start + a.count, p.start + p.count));
                                for (let r = m; r < y; r += 3)(s = s8(this, d, t, i, h, l, u, r, r + 1, r + 2)) && (s.faceIndex = Math.floor(r / 3), s.face.materialIndex = a.materialIndex, e.push(s))
                            } else {
                                let r = Math.max(0, p.start),
                                    a = Math.min(o.count, p.start + p.count);
                                for (let o = r; o < a; o += 3)(s = s8(this, n, t, i, h, l, u, o, o + 1, o + 2)) && (s.faceIndex = Math.floor(o / 3), e.push(s))
                            }
                    }
                }
            }

            function s8(t, e, i, s, r, n, a, o, h, l) {
                t.getVertexPosition(o, s1), t.getVertexPosition(h, s2), t.getVertexPosition(l, s3);
                let u = function(t, e, i, s, r, n, a, o) {
                    if (null === (e.side === m ? s.intersectTriangle(a, n, r, !0, o) : s.intersectTriangle(r, n, a, e.side === d, o))) return null;
                    s7.copy(o), s7.applyMatrix4(t.matrixWorld);
                    let h = i.ray.origin.distanceTo(s7);
                    return h < i.near || h > i.far ? null : {
                        distance: h,
                        point: s7.clone(),
                        object: t
                    }
                }(t, e, i, s, s1, s2, s3, s6);
                if (u) {
                    let t = new e9;
                    sA.getBarycoord(s6, s1, s2, s3, t), r && (u.uv = sA.getInterpolatedAttribute(r, o, h, l, t, new e6)), n && (u.uv1 = sA.getInterpolatedAttribute(n, o, h, l, t, new e6)), a && (u.normal = sA.getInterpolatedAttribute(a, o, h, l, t, new e9), u.normal.dot(s.direction) > 0 && u.normal.multiplyScalar(-1));
                    let e = {
                        a: o,
                        b: h,
                        c: l,
                        normal: new e9,
                        materialIndex: 0
                    };
                    sA.getNormal(s1, s2, s3, e.normal), u.face = e, u.barycoord = t
                }
                return u
            }
            class rt extends sH {
                constructor(t = 1, e = 1, i = 1, s = 1, r = 1, n = 1) {
                    super(), this.type = "BoxGeometry", this.parameters = {
                        width: t,
                        height: e,
                        depth: i,
                        widthSegments: s,
                        heightSegments: r,
                        depthSegments: n
                    };
                    let a = this;
                    s = Math.floor(s), r = Math.floor(r);
                    let o = [],
                        h = [],
                        l = [],
                        u = [],
                        c = 0,
                        p = 0;

                    function d(t, e, i, s, r, n, d, m, y, f, g) {
                        let x = n / y,
                            b = d / f,
                            M = n / 2,
                            v = d / 2,
                            w = m / 2,
                            S = y + 1,
                            _ = f + 1,
                            z = 0,
                            A = 0,
                            T = new e9;
                        for (let n = 0; n < _; n++) {
                            let a = n * b - v;
                            for (let o = 0; o < S; o++) {
                                let c = o * x - M;
                                T[t] = c * s, T[e] = a * r, T[i] = w, h.push(T.x, T.y, T.z), T[t] = 0, T[e] = 0, T[i] = m > 0 ? 1 : -1, l.push(T.x, T.y, T.z), u.push(o / y), u.push(1 - n / f), z += 1
                            }
                        }
                        for (let t = 0; t < f; t++)
                            for (let e = 0; e < y; e++) {
                                let i = c + e + S * t,
                                    s = c + e + S * (t + 1),
                                    r = c + (e + 1) + S * (t + 1),
                                    n = c + (e + 1) + S * t;
                                o.push(i, s, n), o.push(s, r, n), A += 6
                            }
                        a.addGroup(p, A, g), p += A, c += z
                    }
                    d("z", "y", "x", -1, -1, i, e, t, n = Math.floor(n), r, 0), d("z", "y", "x", 1, -1, i, e, -t, n, r, 1), d("x", "z", "y", 1, 1, t, i, e, s, n, 2), d("x", "z", "y", 1, -1, t, i, -e, s, n, 3), d("x", "y", "z", 1, -1, t, e, i, s, r, 4), d("x", "y", "z", -1, -1, t, e, -i, s, r, 5), this.setIndex(o), this.setAttribute("position", new sU(h, 3)), this.setAttribute("normal", new sU(l, 3)), this.setAttribute("uv", new sU(u, 2))
                }
                copy(t) {
                    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                }
                static fromJSON(t) {
                    return new rt(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
                }
            }

            function re(t) {
                let e = {};
                for (let i in t)
                    for (let s in e[i] = {}, t[i]) {
                        let r = t[i][s];
                        r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (eJ("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[i][s] = null) : e[i][s] = r.clone() : Array.isArray(r) ? e[i][s] = r.slice() : e[i][s] = r
                    }
                return e
            }

            function ri(t) {
                let e = {};
                for (let i = 0; i < t.length; i++) {
                    let s = re(t[i]);
                    for (let t in s) e[t] = s[t]
                }
                return e
            }

            function rs(t) {
                let e = t.getRenderTarget();
                return null === e ? t.outputColorSpace : !0 === e.isXRRenderTarget ? e.texture.colorSpace : ia.workingColorSpace
            }
            let rr = {
                clone: re,
                merge: ri
            };
            class rn extends sP {
                constructor(t) {
                    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
                        clipCullDistance: !1,
                        multiDraw: !1
                    }, this.defaultAttributeValues = {
                        color: [1, 1, 1],
                        uv: [0, 0],
                        uv1: [0, 0]
                    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = re(t.uniforms), this.uniformsGroups = function(t) {
                        let e = [];
                        for (let i = 0; i < t.length; i++) e.push(t[i].clone());
                        return e
                    }(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this.defaultAttributeValues = Object.assign({}, t.defaultAttributeValues), this.index0AttributeName = t.index0AttributeName, this.uniformsNeedUpdate = t.uniformsNeedUpdate, this
                }
                toJSON(t) {
                    let e = super.toJSON(t);
                    for (let i in e.glslVersion = this.glslVersion, e.uniforms = {}, this.uniforms) {
                        let s = this.uniforms[i].value;
                        s && s.isTexture ? e.uniforms[i] = {
                            type: "t",
                            value: s.toJSON(t).uuid
                        } : s && s.isColor ? e.uniforms[i] = {
                            type: "c",
                            value: s.getHex()
                        } : s && s.isVector2 ? e.uniforms[i] = {
                            type: "v2",
                            value: s.toArray()
                        } : s && s.isVector3 ? e.uniforms[i] = {
                            type: "v3",
                            value: s.toArray()
                        } : s && s.isVector4 ? e.uniforms[i] = {
                            type: "v4",
                            value: s.toArray()
                        } : s && s.isMatrix3 ? e.uniforms[i] = {
                            type: "m3",
                            value: s.toArray()
                        } : s && s.isMatrix4 ? e.uniforms[i] = {
                            type: "m4",
                            value: s.toArray()
                        } : e.uniforms[i] = {
                            value: s
                        }
                    }
                    Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.lights = this.lights, e.clipping = this.clipping;
                    let i = {};
                    for (let t in this.extensions) !0 === this.extensions[t] && (i[t] = !0);
                    return Object.keys(i).length > 0 && (e.extensions = i), e
                }
            }
            class ra extends sp {
                constructor() {
                    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new iG, this.projectionMatrix = new iG, this.projectionMatrixInverse = new iG, this.coordinateSystem = eE, this._reversedDepth = !1
                }
                get reversedDepth() {
                    return this._reversedDepth
                }
                copy(t, e) {
                    return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this.coordinateSystem = t.coordinateSystem, this
                }
                getWorldDirection(t) {
                    return super.getWorldDirection(t).negate()
                }
                updateMatrixWorld(t) {
                    super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                }
                updateWorldMatrix(t, e) {
                    super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            let ro = new e9,
                rh = new e6,
                rl = new e6;
            class ru extends ra {
                constructor(t = 50, e = 1, i = .1, s = 2e3) {
                    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = i, this.far = s, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
                }
                copy(t, e) {
                    return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
                }
                setFocalLength(t) {
                    let e = .5 * this.getFilmHeight() / t;
                    this.fov = 2 * e$ * Math.atan(e), this.updateProjectionMatrix()
                }
                getFocalLength() {
                    let t = Math.tan(.5 * eQ * this.fov);
                    return .5 * this.getFilmHeight() / t
                }
                getEffectiveFOV() {
                    return 2 * e$ * Math.atan(Math.tan(.5 * eQ * this.fov) / this.zoom)
                }
                getFilmWidth() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                }
                getFilmHeight() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                }
                getViewBounds(t, e, i) {
                    ro.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), e.set(ro.x, ro.y).multiplyScalar(-t / ro.z), ro.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), i.set(ro.x, ro.y).multiplyScalar(-t / ro.z)
                }
                getViewSize(t, e) {
                    return this.getViewBounds(t, rh, rl), e.subVectors(rl, rh)
                }
                setViewOffset(t, e, i, s, r, n) {
                    this.aspect = t / e, null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = s, this.view.width = r, this.view.height = n, this.updateProjectionMatrix()
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                }
                updateProjectionMatrix() {
                    let t = this.near,
                        e = t * Math.tan(.5 * eQ * this.fov) / this.zoom,
                        i = 2 * e,
                        s = this.aspect * i,
                        r = -.5 * s,
                        n = this.view;
                    if (null !== this.view && this.view.enabled) {
                        let t = n.fullWidth,
                            a = n.fullHeight;
                        r += n.offsetX * s / t, e -= n.offsetY * i / a, s *= n.width / t, i *= n.height / a
                    }
                    let a = this.filmOffset;
                    0 !== a && (r += t * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + s, e, e - i, t, this.far, this.coordinateSystem, this.reversedDepth), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                }
                toJSON(t) {
                    let e = super.toJSON(t);
                    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
                }
            }
            class rc extends sp {
                constructor(t, e, i) {
                    super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
                    let s = new ru(-90, 1, t, e);
                    s.layers = this.layers, this.add(s);
                    let r = new ru(-90, 1, t, e);
                    r.layers = this.layers, this.add(r);
                    let n = new ru(-90, 1, t, e);
                    n.layers = this.layers, this.add(n);
                    let a = new ru(-90, 1, t, e);
                    a.layers = this.layers, this.add(a);
                    let o = new ru(-90, 1, t, e);
                    o.layers = this.layers, this.add(o);
                    let h = new ru(-90, 1, t, e);
                    h.layers = this.layers, this.add(h)
                }
                updateCoordinateSystem() {
                    let t = this.coordinateSystem,
                        e = this.children.concat(),
                        [i, s, r, n, a, o] = e;
                    for (let t of e) this.remove(t);
                    if (t === eE) i.up.set(0, 1, 0), i.lookAt(1, 0, 0), s.up.set(0, 1, 0), s.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), n.up.set(0, 0, 1), n.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), o.up.set(0, 1, 0), o.lookAt(0, 0, -1);
                    else if (2001 === t) i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), s.up.set(0, -1, 0), s.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), n.up.set(0, 0, -1), n.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), o.up.set(0, -1, 0), o.lookAt(0, 0, -1);
                    else throw Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + t);
                    for (let t of e) this.add(t), t.updateMatrixWorld()
                }
                update(t, e) {
                    null === this.parent && this.updateMatrixWorld();
                    let {
                        renderTarget: i,
                        activeMipmapLevel: s
                    } = this;
                    this.coordinateSystem !== t.coordinateSystem && (this.coordinateSystem = t.coordinateSystem, this.updateCoordinateSystem());
                    let [r, n, a, o, h, l] = this.children, u = t.getRenderTarget(), c = t.getActiveCubeFace(), p = t.getActiveMipmapLevel(), d = t.xr.enabled;
                    t.xr.enabled = !1;
                    let m = i.texture.generateMipmaps;
                    i.texture.generateMipmaps = !1, t.setRenderTarget(i, 0, s), t.render(e, r), t.setRenderTarget(i, 1, s), t.render(e, n), t.setRenderTarget(i, 2, s), t.render(e, a), t.setRenderTarget(i, 3, s), t.render(e, o), t.setRenderTarget(i, 4, s), t.render(e, h), i.texture.generateMipmaps = m, t.setRenderTarget(i, 5, s), t.render(e, l), t.setRenderTarget(u, c, p), t.xr.enabled = d, i.texture.needsPMREMUpdate = !0
                }
            }
            class rp extends iy {
                constructor(t = [], e = th, i, s, r, n, a, o, h, l) {
                    super(t, e, i, s, r, n, a, o, h, l), this.isCubeTexture = !0, this.flipY = !1
                }
                get images() {
                    return this.image
                }
                set images(t) {
                    this.image = t
                }
            }
            class rd extends ib {
                constructor(t = 1, e = {}) {
                    super(t, t, e), this.isWebGLCubeRenderTarget = !0;
                    let i = {
                        width: t,
                        height: t,
                        depth: 1
                    };
                    this.texture = new rp([i, i, i, i, i, i]), this._setTextureOptions(e), this.texture.isRenderTargetTexture = !0
                }
                fromEquirectangularTexture(t, e) {
                    this.texture.type = e.type, this.texture.colorSpace = e.colorSpace, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
                    let i = {
                            uniforms: {
                                tEquirect: {
                                    value: null
                                }
                            },
                            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
                        },
                        s = new rt(5, 5, 5),
                        r = new rn({
                            name: "CubemapFromEquirect",
                            uniforms: re(i.uniforms),
                            vertexShader: i.vertexShader,
                            fragmentShader: i.fragmentShader,
                            side: m,
                            blending: f
                        });
                    r.uniforms.tEquirect.value = e;
                    let n = new s9(s, r),
                        a = e.minFilter;
                    return e.minFilter === tv && (e.minFilter = tb), new rc(1, 10, this).update(t, n), e.minFilter = a, n.geometry.dispose(), n.material.dispose(), this
                }
                clear(t, e = !0, i = !0, s = !0) {
                    let r = t.getRenderTarget();
                    for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, i, s);
                    t.setRenderTarget(r)
                }
            }
            class rm extends sp {
                constructor() {
                    super(), this.isGroup = !0, this.type = "Group"
                }
            }
            let ry = {
                type: "move"
            };
            class rf {
                constructor() {
                    this._targetRay = null, this._grip = null, this._hand = null
                }
                getHandSpace() {
                    return null === this._hand && (this._hand = new rm, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                        pinching: !1
                    }), this._hand
                }
                getTargetRaySpace() {
                    return null === this._targetRay && (this._targetRay = new rm, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new e9, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new e9), this._targetRay
                }
                getGripSpace() {
                    return null === this._grip && (this._grip = new rm, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new e9, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new e9), this._grip
                }
                dispatchEvent(t) {
                    return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
                }
                connect(t) {
                    if (t && t.hand) {
                        let e = this._hand;
                        if (e)
                            for (let i of t.hand.values()) this._getHandJoint(e, i)
                    }
                    return this.dispatchEvent({
                        type: "connected",
                        data: t
                    }), this
                }
                disconnect(t) {
                    return this.dispatchEvent({
                        type: "disconnected",
                        data: t
                    }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
                }
                update(t, e, i) {
                    let s = null,
                        r = null,
                        n = null,
                        a = this._targetRay,
                        o = this._grip,
                        h = this._hand;
                    if (t && "visible-blurred" !== e.session.visibilityState) {
                        if (h && t.hand) {
                            for (let s of (n = !0, t.hand.values())) {
                                let t = e.getJointPose(s, i),
                                    r = this._getHandJoint(h, s);
                                null !== t && (r.matrix.fromArray(t.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.matrixWorldNeedsUpdate = !0, r.jointRadius = t.radius), r.visible = null !== t
                            }
                            let s = h.joints["index-finger-tip"],
                                r = h.joints["thumb-tip"],
                                a = s.position.distanceTo(r.position);
                            h.inputState.pinching && a > .025 ? (h.inputState.pinching = !1, this.dispatchEvent({
                                type: "pinchend",
                                handedness: t.handedness,
                                target: this
                            })) : !h.inputState.pinching && a <= .015 && (h.inputState.pinching = !0, this.dispatchEvent({
                                type: "pinchstart",
                                handedness: t.handedness,
                                target: this
                            }))
                        } else null !== o && t.gripSpace && null !== (r = e.getPose(t.gripSpace, i)) && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1);
                        null !== a && (null === (s = e.getPose(t.targetRaySpace, i)) && null !== r && (s = r), null !== s && (a.matrix.fromArray(s.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(s.linearVelocity)) : a.hasLinearVelocity = !1, s.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(s.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(ry)))
                    }
                    return null !== a && (a.visible = null !== s), null !== o && (o.visible = null !== r), null !== h && (h.visible = null !== n), this
                }
                _getHandJoint(t, e) {
                    if (void 0 === t.joints[e.jointName]) {
                        let i = new rm;
                        i.matrixAutoUpdate = !1, i.visible = !1, t.joints[e.jointName] = i, t.add(i)
                    }
                    return t.joints[e.jointName]
                }
            }
            class rg {
                constructor(t, e = 25e-5) {
                    this.isFogExp2 = !0, this.name = "", this.color = new sB(t), this.density = e
                }
                clone() {
                    return new rg(this.color, this.density)
                }
                toJSON() {
                    return {
                        type: "FogExp2",
                        name: this.name,
                        color: this.color.getHex(),
                        density: this.density
                    }
                }
            }
            class rx extends sp {
                constructor() {
                    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new i4, this.environmentIntensity = 1, this.environmentRotation = new i4, this.overrideMaterial = null, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                        detail: this
                    }))
                }
                copy(t, e) {
                    return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, this.backgroundRotation.copy(t.backgroundRotation), this.environmentIntensity = t.environmentIntensity, this.environmentRotation.copy(t.environmentRotation), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this
                }
                toJSON(t) {
                    let e = super.toJSON(t);
                    return null !== this.fog && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (e.object.backgroundIntensity = this.backgroundIntensity), e.object.backgroundRotation = this.backgroundRotation.toArray(), 1 !== this.environmentIntensity && (e.object.environmentIntensity = this.environmentIntensity), e.object.environmentRotation = this.environmentRotation.toArray(), e
                }
            }
            class rb {
                constructor(t, e) {
                    this.isInterleavedBuffer = !0, this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = 35044, this.updateRanges = [], this.version = 0, this.uuid = eK()
                }
                onUploadCallback() {}
                set needsUpdate(t) {
                    !0 === t && this.version++
                }
                setUsage(t) {
                    return this.usage = t, this
                }
                addUpdateRange(t, e) {
                    this.updateRanges.push({
                        start: t,
                        count: e
                    })
                }
                clearUpdateRanges() {
                    this.updateRanges.length = 0
                }
                copy(t) {
                    return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this
                }
                copyAt(t, e, i) {
                    t *= this.stride, i *= e.stride;
                    for (let s = 0, r = this.stride; s < r; s++) this.array[t + s] = e.array[i + s];
                    return this
                }
                set(t, e = 0) {
                    return this.array.set(t, e), this
                }
                clone(t) {
                    void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = eK()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                    let e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
                        i = new this.constructor(e, this.stride);
                    return i.setUsage(this.usage), i
                }
                onUpload(t) {
                    return this.onUploadCallback = t, this
                }
                toJSON(t) {
                    return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = eK()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
                        uuid: this.uuid,
                        buffer: this.array.buffer._uuid,
                        type: this.array.constructor.name,
                        stride: this.stride
                    }
                }
            }
            let rM = new e9;
            class rv {
                constructor(t, e, i, s = !1) {
                    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = t, this.itemSize = e, this.offset = i, this.normalized = s
                }
                get count() {
                    return this.data.count
                }
                get array() {
                    return this.data.array
                }
                set needsUpdate(t) {
                    this.data.needsUpdate = t
                }
                applyMatrix4(t) {
                    for (let e = 0, i = this.data.count; e < i; e++) rM.fromBufferAttribute(this, e), rM.applyMatrix4(t), this.setXYZ(e, rM.x, rM.y, rM.z);
                    return this
                }
                applyNormalMatrix(t) {
                    for (let e = 0, i = this.count; e < i; e++) rM.fromBufferAttribute(this, e), rM.applyNormalMatrix(t), this.setXYZ(e, rM.x, rM.y, rM.z);
                    return this
                }
                transformDirection(t) {
                    for (let e = 0, i = this.count; e < i; e++) rM.fromBufferAttribute(this, e), rM.transformDirection(t), this.setXYZ(e, rM.x, rM.y, rM.z);
                    return this
                }
                getComponent(t, e) {
                    let i = this.array[t * this.data.stride + this.offset + e];
                    return this.normalized && (i = e3(i, this.array)), i
                }
                setComponent(t, e, i) {
                    return this.normalized && (i = e5(i, this.array)), this.data.array[t * this.data.stride + this.offset + e] = i, this
                }
                setX(t, e) {
                    return this.normalized && (e = e5(e, this.array)), this.data.array[t * this.data.stride + this.offset] = e, this
                }
                setY(t, e) {
                    return this.normalized && (e = e5(e, this.array)), this.data.array[t * this.data.stride + this.offset + 1] = e, this
                }
                setZ(t, e) {
                    return this.normalized && (e = e5(e, this.array)), this.data.array[t * this.data.stride + this.offset + 2] = e, this
                }
                setW(t, e) {
                    return this.normalized && (e = e5(e, this.array)), this.data.array[t * this.data.stride + this.offset + 3] = e, this
                }
                getX(t) {
                    let e = this.data.array[t * this.data.stride + this.offset];
                    return this.normalized && (e = e3(e, this.array)), e
                }
                getY(t) {
                    let e = this.data.array[t * this.data.stride + this.offset + 1];
                    return this.normalized && (e = e3(e, this.array)), e
                }
                getZ(t) {
                    let e = this.data.array[t * this.data.stride + this.offset + 2];
                    return this.normalized && (e = e3(e, this.array)), e
                }
                getW(t) {
                    let e = this.data.array[t * this.data.stride + this.offset + 3];
                    return this.normalized && (e = e3(e, this.array)), e
                }
                setXY(t, e, i) {
                    return t = t * this.data.stride + this.offset, this.normalized && (e = e5(e, this.array), i = e5(i, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = i, this
                }
                setXYZ(t, e, i, s) {
                    return t = t * this.data.stride + this.offset, this.normalized && (e = e5(e, this.array), i = e5(i, this.array), s = e5(s, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = s, this
                }
                setXYZW(t, e, i, s, r) {
                    return t = t * this.data.stride + this.offset, this.normalized && (e = e5(e, this.array), i = e5(i, this.array), s = e5(s, this.array), r = e5(r, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = s, this.data.array[t + 3] = r, this
                }
                clone(t) {
                    if (void 0 !== t) return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new rv(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized); {
                        eW("InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                        let t = [];
                        for (let e = 0; e < this.count; e++) {
                            let i = e * this.data.stride + this.offset;
                            for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[i + e])
                        }
                        return new sF(new this.array.constructor(t), this.itemSize, this.normalized)
                    }
                }
                toJSON(t) {
                    if (void 0 !== t) return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
                        isInterleavedBufferAttribute: !0,
                        itemSize: this.itemSize,
                        data: this.data.uuid,
                        offset: this.offset,
                        normalized: this.normalized
                    }; {
                        eW("InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                        let t = [];
                        for (let e = 0; e < this.count; e++) {
                            let i = e * this.data.stride + this.offset;
                            for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[i + e])
                        }
                        return {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: t,
                            normalized: this.normalized
                        }
                    }
                }
            }
            let rw = new e9,
                rS = new ig,
                r_ = new ig,
                rz = new e9,
                rA = new iG,
                rT = new e9,
                rC = new iD,
                rO = new iG,
                rk = new iX;
            class rB extends s9 {
                constructor(t, e) {
                    super(t, e), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = to, this.bindMatrix = new iG, this.bindMatrixInverse = new iG, this.boundingBox = null, this.boundingSphere = null
                }
                computeBoundingBox() {
                    let t = this.geometry;
                    null === this.boundingBox && (this.boundingBox = new iw), this.boundingBox.makeEmpty();
                    let e = t.getAttribute("position");
                    for (let t = 0; t < e.count; t++) this.getVertexPosition(t, rT), this.boundingBox.expandByPoint(rT)
                }
                computeBoundingSphere() {
                    let t = this.geometry;
                    null === this.boundingSphere && (this.boundingSphere = new iD), this.boundingSphere.makeEmpty();
                    let e = t.getAttribute("position");
                    for (let t = 0; t < e.count; t++) this.getVertexPosition(t, rT), this.boundingSphere.expandByPoint(rT)
                }
                copy(t, e) {
                    return super.copy(t, e), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
                }
                raycast(t, e) {
                    let i = this.material,
                        s = this.matrixWorld;
                    if (void 0 !== i && (null === this.boundingSphere && this.computeBoundingSphere(), rC.copy(this.boundingSphere), rC.applyMatrix4(s), !1 !== t.ray.intersectsSphere(rC))) {
                        if (rO.copy(s).invert(), rk.copy(t.ray).applyMatrix4(rO), null !== this.boundingBox && !1 === rk.intersectsBox(this.boundingBox)) return;
                        this._computeIntersections(t, e, rk)
                    }
                }
                getVertexPosition(t, e) {
                    return super.getVertexPosition(t, e), this.applyBoneTransform(t, e), e
                }
                bind(t, e) {
                    this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
                }
                pose() {
                    this.skeleton.pose()
                }
                normalizeSkinWeights() {
                    let t = new ig,
                        e = this.geometry.attributes.skinWeight;
                    for (let i = 0, s = e.count; i < s; i++) {
                        t.fromBufferAttribute(e, i);
                        let s = 1 / t.manhattanLength();
                        s !== 1 / 0 ? t.multiplyScalar(s) : t.set(1, 0, 0, 0), e.setXYZW(i, t.x, t.y, t.z, t.w)
                    }
                }
                updateMatrixWorld(t) {
                    super.updateMatrixWorld(t), this.bindMode === to ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : eJ("SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                }
                applyBoneTransform(t, e) {
                    let i = this.skeleton,
                        s = this.geometry;
                    rS.fromBufferAttribute(s.attributes.skinIndex, t), r_.fromBufferAttribute(s.attributes.skinWeight, t), rw.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
                    for (let t = 0; t < 4; t++) {
                        let s = r_.getComponent(t);
                        if (0 !== s) {
                            let r = rS.getComponent(t);
                            rA.multiplyMatrices(i.bones[r].matrixWorld, i.boneInverses[r]), e.addScaledVector(rz.copy(rw).applyMatrix4(rA), s)
                        }
                    }
                    return e.applyMatrix4(this.bindMatrixInverse)
                }
            }
            class rN extends sp {
                constructor() {
                    super(), this.isBone = !0, this.type = "Bone"
                }
            }
            class rI extends iy {
                constructor(t = null, e = 1, i = 1, s, r, n, a, o, h = tf, l = tf, u, c) {
                    super(null, n, a, o, h, l, s, r, u, c), this.isDataTexture = !0, this.image = {
                        data: t,
                        width: e,
                        height: i
                    }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                }
            }
            let rP = new iG,
                rR = new iG;
            class rV {
                constructor(t = [], e = []) {
                    this.uuid = eK(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.previousBoneMatrices = null, this.boneTexture = null, this.init()
                }
                init() {
                    let t = this.bones,
                        e = this.boneInverses;
                    if (this.boneMatrices = new Float32Array(16 * t.length), 0 === e.length) this.calculateInverses();
                    else if (t.length !== e.length) {
                        eJ("Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                        for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new iG)
                    }
                }
                calculateInverses() {
                    this.boneInverses.length = 0;
                    for (let t = 0, e = this.bones.length; t < e; t++) {
                        let e = new iG;
                        this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(e)
                    }
                }
                pose() {
                    for (let t = 0, e = this.bones.length; t < e; t++) {
                        let e = this.bones[t];
                        e && e.matrixWorld.copy(this.boneInverses[t]).invert()
                    }
                    for (let t = 0, e = this.bones.length; t < e; t++) {
                        let e = this.bones[t];
                        e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
                    }
                }
                update() {
                    let t = this.bones,
                        e = this.boneInverses,
                        i = this.boneMatrices,
                        s = this.boneTexture;
                    for (let s = 0, r = t.length; s < r; s++) {
                        let r = t[s] ? t[s].matrixWorld : rR;
                        rP.multiplyMatrices(r, e[s]), rP.toArray(i, 16 * s)
                    }
                    null !== s && (s.needsUpdate = !0)
                }
                clone() {
                    return new rV(this.bones, this.boneInverses)
                }
                computeBoneTexture() {
                    let t = Math.sqrt(4 * this.bones.length),
                        e = new Float32Array((t = Math.max(t = 4 * Math.ceil(t / 4), 4)) * t * 4);
                    e.set(this.boneMatrices);
                    let i = new rI(e, t, t, tL, tC);
                    return i.needsUpdate = !0, this.boneMatrices = e, this.boneTexture = i, this
                }
                getBoneByName(t) {
                    for (let e = 0, i = this.bones.length; e < i; e++) {
                        let i = this.bones[e];
                        if (i.name === t) return i
                    }
                }
                dispose() {
                    null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
                }
                fromJSON(t, e) {
                    this.uuid = t.uuid;
                    for (let i = 0, s = t.bones.length; i < s; i++) {
                        let s = t.bones[i],
                            r = e[s];
                        void 0 === r && (eJ("Skeleton: No bone found with UUID:", s), r = new rN), this.bones.push(r), this.boneInverses.push(new iG().fromArray(t.boneInverses[i]))
                    }
                    return this.init(), this
                }
                toJSON() {
                    let t = {
                        metadata: {
                            version: 4.7,
                            type: "Skeleton",
                            generator: "Skeleton.toJSON"
                        },
                        bones: [],
                        boneInverses: []
                    };
                    t.uuid = this.uuid;
                    let e = this.bones,
                        i = this.boneInverses;
                    for (let s = 0, r = e.length; s < r; s++) {
                        let r = e[s];
                        t.bones.push(r.uuid);
                        let n = i[s];
                        t.boneInverses.push(n.toArray())
                    }
                    return t
                }
            }
            class rL extends sF {
                constructor(t, e, i, s = 1) {
                    super(t, e, i), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = s
                }
                copy(t) {
                    return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
                }
                toJSON() {
                    let t = super.toJSON();
                    return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
                }
            }
            let rE = new iG,
                rF = new iG,
                rD = [],
                rj = new iw,
                rU = new iG,
                rW = new s9,
                rJ = new iD;
            class rq extends s9 {
                constructor(t, e, i) {
                    super(t, e), this.isInstancedMesh = !0, this.instanceMatrix = new rL(new Float32Array(16 * i), 16), this.instanceColor = null, this.morphTexture = null, this.count = i, this.boundingBox = null, this.boundingSphere = null;
                    for (let t = 0; t < i; t++) this.setMatrixAt(t, rU)
                }
                computeBoundingBox() {
                    let t = this.geometry,
                        e = this.count;
                    null === this.boundingBox && (this.boundingBox = new iw), null === t.boundingBox && t.computeBoundingBox(), this.boundingBox.makeEmpty();
                    for (let i = 0; i < e; i++) this.getMatrixAt(i, rE), rj.copy(t.boundingBox).applyMatrix4(rE), this.boundingBox.union(rj)
                }
                computeBoundingSphere() {
                    let t = this.geometry,
                        e = this.count;
                    null === this.boundingSphere && (this.boundingSphere = new iD), null === t.boundingSphere && t.computeBoundingSphere(), this.boundingSphere.makeEmpty();
                    for (let i = 0; i < e; i++) this.getMatrixAt(i, rE), rJ.copy(t.boundingSphere).applyMatrix4(rE), this.boundingSphere.union(rJ)
                }
                copy(t, e) {
                    return super.copy(t, e), this.instanceMatrix.copy(t.instanceMatrix), null !== t.morphTexture && (this.morphTexture = t.morphTexture.clone()), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
                }
                getColorAt(t, e) {
                    e.fromArray(this.instanceColor.array, 3 * t)
                }
                getMatrixAt(t, e) {
                    e.fromArray(this.instanceMatrix.array, 16 * t)
                }
                getMorphAt(t, e) {
                    let i = e.morphTargetInfluences,
                        s = this.morphTexture.source.data.data,
                        r = t * (i.length + 1) + 1;
                    for (let t = 0; t < i.length; t++) i[t] = s[r + t]
                }
                raycast(t, e) {
                    let i = this.matrixWorld,
                        s = this.count;
                    if (rW.geometry = this.geometry, rW.material = this.material, void 0 !== rW.material && (null === this.boundingSphere && this.computeBoundingSphere(), rJ.copy(this.boundingSphere), rJ.applyMatrix4(i), !1 !== t.ray.intersectsSphere(rJ)))
                        for (let r = 0; r < s; r++) {
                            this.getMatrixAt(r, rE), rF.multiplyMatrices(i, rE), rW.matrixWorld = rF, rW.raycast(t, rD);
                            for (let t = 0, i = rD.length; t < i; t++) {
                                let i = rD[t];
                                i.instanceId = r, i.object = this, e.push(i)
                            }
                            rD.length = 0
                        }
                }
                setColorAt(t, e) {
                    null === this.instanceColor && (this.instanceColor = new rL(new Float32Array(3 * this.instanceMatrix.count).fill(1), 3)), e.toArray(this.instanceColor.array, 3 * t)
                }
                setMatrixAt(t, e) {
                    e.toArray(this.instanceMatrix.array, 16 * t)
                }
                setMorphAt(t, e) {
                    let i = e.morphTargetInfluences,
                        s = i.length + 1;
                    null === this.morphTexture && (this.morphTexture = new rI(new Float32Array(s * this.count), s, this.count, tD, tC));
                    let r = this.morphTexture.source.data.data,
                        n = 0;
                    for (let t = 0; t < i.length; t++) n += i[t];
                    let a = this.geometry.morphTargetsRelative ? 1 : 1 - n,
                        o = s * t;
                    r[o] = a, r.set(i, o + 1)
                }
                updateMorphTargets() {}
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    }), null !== this.morphTexture && (this.morphTexture.dispose(), this.morphTexture = null)
                }
            }
            let rZ = new e9,
                rY = new e9,
                rX = new ie;
            class rG {
                constructor(t = new e9(1, 0, 0), e = 0) {
                    this.isPlane = !0, this.normal = t, this.constant = e
                }
                set(t, e) {
                    return this.normal.copy(t), this.constant = e, this
                }
                setComponents(t, e, i, s) {
                    return this.normal.set(t, e, i), this.constant = s, this
                }
                setFromNormalAndCoplanarPoint(t, e) {
                    return this.normal.copy(t), this.constant = -e.dot(this.normal), this
                }
                setFromCoplanarPoints(t, e, i) {
                    let s = rZ.subVectors(i, e).cross(rY.subVectors(t, e)).normalize();
                    return this.setFromNormalAndCoplanarPoint(s, t), this
                }
                copy(t) {
                    return this.normal.copy(t.normal), this.constant = t.constant, this
                }
                normalize() {
                    let t = 1 / this.normal.length();
                    return this.normal.multiplyScalar(t), this.constant *= t, this
                }
                negate() {
                    return this.constant *= -1, this.normal.negate(), this
                }
                distanceToPoint(t) {
                    return this.normal.dot(t) + this.constant
                }
                distanceToSphere(t) {
                    return this.distanceToPoint(t.center) - t.radius
                }
                projectPoint(t, e) {
                    return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t))
                }
                intersectLine(t, e) {
                    let i = t.delta(rZ),
                        s = this.normal.dot(i);
                    if (0 === s) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                    let r = -(t.start.dot(this.normal) + this.constant) / s;
                    return r < 0 || r > 1 ? null : e.copy(t.start).addScaledVector(i, r)
                }
                intersectsLine(t) {
                    let e = this.distanceToPoint(t.start),
                        i = this.distanceToPoint(t.end);
                    return e < 0 && i > 0 || i < 0 && e > 0
                }
                intersectsBox(t) {
                    return t.intersectsPlane(this)
                }
                intersectsSphere(t) {
                    return t.intersectsPlane(this)
                }
                coplanarPoint(t) {
                    return t.copy(this.normal).multiplyScalar(-this.constant)
                }
                applyMatrix4(t, e) {
                    let i = e || rX.getNormalMatrix(t),
                        s = this.coplanarPoint(rZ).applyMatrix4(t),
                        r = this.normal.applyMatrix3(i).normalize();
                    return this.constant = -s.dot(r), this
                }
                translate(t) {
                    return this.constant -= t.dot(this.normal), this
                }
                equals(t) {
                    return t.normal.equals(this.normal) && t.constant === this.constant
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            let rH = new iD,
                rQ = new e6(.5, .5),
                r$ = new e9;
            class rK {
                constructor(t = new rG, e = new rG, i = new rG, s = new rG, r = new rG, n = new rG) {
                    this.planes = [t, e, i, s, r, n]
                }
                set(t, e, i, s, r, n) {
                    let a = this.planes;
                    return a[0].copy(t), a[1].copy(e), a[2].copy(i), a[3].copy(s), a[4].copy(r), a[5].copy(n), this
                }
                copy(t) {
                    let e = this.planes;
                    for (let i = 0; i < 6; i++) e[i].copy(t.planes[i]);
                    return this
                }
                setFromProjectionMatrix(t, e = eE, i = !1) {
                    let s = this.planes,
                        r = t.elements,
                        n = r[0],
                        a = r[1],
                        o = r[2],
                        h = r[3],
                        l = r[4],
                        u = r[5],
                        c = r[6],
                        p = r[7],
                        d = r[8],
                        m = r[9],
                        y = r[10],
                        f = r[11],
                        g = r[12],
                        x = r[13],
                        b = r[14],
                        M = r[15];
                    if (s[0].setComponents(h - n, p - l, f - d, M - g).normalize(), s[1].setComponents(h + n, p + l, f + d, M + g).normalize(), s[2].setComponents(h + a, p + u, f + m, M + x).normalize(), s[3].setComponents(h - a, p - u, f - m, M - x).normalize(), i) s[4].setComponents(o, c, y, b).normalize(), s[5].setComponents(h - o, p - c, f - y, M - b).normalize();
                    else if (s[4].setComponents(h - o, p - c, f - y, M - b).normalize(), e === eE) s[5].setComponents(h + o, p + c, f + y, M + b).normalize();
                    else if (2001 === e) s[5].setComponents(o, c, y, b).normalize();
                    else throw Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
                    return this
                }
                intersectsObject(t) {
                    if (void 0 !== t.boundingSphere) null === t.boundingSphere && t.computeBoundingSphere(), rH.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
                    else {
                        let e = t.geometry;
                        null === e.boundingSphere && e.computeBoundingSphere(), rH.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)
                    }
                    return this.intersectsSphere(rH)
                }
                intersectsSprite(t) {
                    rH.center.set(0, 0, 0);
                    let e = rQ.distanceTo(t.center);
                    return rH.radius = .7071067811865476 + e, rH.applyMatrix4(t.matrixWorld), this.intersectsSphere(rH)
                }
                intersectsSphere(t) {
                    let e = this.planes,
                        i = t.center,
                        s = -t.radius;
                    for (let t = 0; t < 6; t++)
                        if (e[t].distanceToPoint(i) < s) return !1;
                    return !0
                }
                intersectsBox(t) {
                    let e = this.planes;
                    for (let i = 0; i < 6; i++) {
                        let s = e[i];
                        if (r$.x = s.normal.x > 0 ? t.max.x : t.min.x, r$.y = s.normal.y > 0 ? t.max.y : t.min.y, r$.z = s.normal.z > 0 ? t.max.z : t.min.z, 0 > s.distanceToPoint(r$)) return !1
                    }
                    return !0
                }
                containsPoint(t) {
                    let e = this.planes;
                    for (let i = 0; i < 6; i++)
                        if (0 > e[i].distanceToPoint(t)) return !1;
                    return !0
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            let r0 = new iG,
                r1 = new rK;
            class r2 {
                constructor() {
                    this.coordinateSystem = eE
                }
                intersectsObject(t, e) {
                    if (!e.isArrayCamera || 0 === e.cameras.length) return !1;
                    for (let i = 0; i < e.cameras.length; i++) {
                        let s = e.cameras[i];
                        if (r0.multiplyMatrices(s.projectionMatrix, s.matrixWorldInverse), r1.setFromProjectionMatrix(r0, s.coordinateSystem, s.reversedDepth), r1.intersectsObject(t)) return !0
                    }
                    return !1
                }
                intersectsSprite(t, e) {
                    if (!e || !e.cameras || 0 === e.cameras.length) return !1;
                    for (let i = 0; i < e.cameras.length; i++) {
                        let s = e.cameras[i];
                        if (r0.multiplyMatrices(s.projectionMatrix, s.matrixWorldInverse), r1.setFromProjectionMatrix(r0, s.coordinateSystem, s.reversedDepth), r1.intersectsSprite(t)) return !0
                    }
                    return !1
                }
                intersectsSphere(t, e) {
                    if (!e || !e.cameras || 0 === e.cameras.length) return !1;
                    for (let i = 0; i < e.cameras.length; i++) {
                        let s = e.cameras[i];
                        if (r0.multiplyMatrices(s.projectionMatrix, s.matrixWorldInverse), r1.setFromProjectionMatrix(r0, s.coordinateSystem, s.reversedDepth), r1.intersectsSphere(t)) return !0
                    }
                    return !1
                }
                intersectsBox(t, e) {
                    if (!e || !e.cameras || 0 === e.cameras.length) return !1;
                    for (let i = 0; i < e.cameras.length; i++) {
                        let s = e.cameras[i];
                        if (r0.multiplyMatrices(s.projectionMatrix, s.matrixWorldInverse), r1.setFromProjectionMatrix(r0, s.coordinateSystem, s.reversedDepth), r1.intersectsBox(t)) return !0
                    }
                    return !1
                }
                containsPoint(t, e) {
                    if (!e || !e.cameras || 0 === e.cameras.length) return !1;
                    for (let i = 0; i < e.cameras.length; i++) {
                        let s = e.cameras[i];
                        if (r0.multiplyMatrices(s.projectionMatrix, s.matrixWorldInverse), r1.setFromProjectionMatrix(r0, s.coordinateSystem, s.reversedDepth), r1.containsPoint(t)) return !0
                    }
                    return !1
                }
                clone() {
                    return new r2
                }
            }
            class r3 extends sP {
                constructor(t) {
                    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new sB(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.fog = t.fog, this
                }
            }
            let r5 = new e9,
                r4 = new e9,
                r6 = new iG,
                r7 = new iX,
                r9 = new iD,
                r8 = new e9,
                nt = new e9;
            class ne extends sp {
                constructor(t = new sH, e = new r3) {
                    super(), this.isLine = !0, this.type = "Line", this.geometry = t, this.material = e, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets()
                }
                copy(t, e) {
                    return super.copy(t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this
                }
                computeLineDistances() {
                    let t = this.geometry;
                    if (null === t.index) {
                        let e = t.attributes.position,
                            i = [0];
                        for (let t = 1, s = e.count; t < s; t++) r5.fromBufferAttribute(e, t - 1), r4.fromBufferAttribute(e, t), i[t] = i[t - 1], i[t] += r5.distanceTo(r4);
                        t.setAttribute("lineDistance", new sU(i, 1))
                    } else eJ("Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    return this
                }
                raycast(t, e) {
                    let i = this.geometry,
                        s = this.matrixWorld,
                        r = t.params.Line.threshold,
                        n = i.drawRange;
                    if (null === i.boundingSphere && i.computeBoundingSphere(), r9.copy(i.boundingSphere), r9.applyMatrix4(s), r9.radius += r, !1 === t.ray.intersectsSphere(r9)) return;
                    r6.copy(s).invert(), r7.copy(t.ray).applyMatrix4(r6);
                    let a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        o = a * a,
                        h = this.isLineSegments ? 2 : 1,
                        l = i.index,
                        u = i.attributes.position;
                    if (null !== l) {
                        let i = Math.max(0, n.start),
                            s = Math.min(l.count, n.start + n.count);
                        for (let r = i, n = s - 1; r < n; r += h) {
                            let i = ni(this, t, r7, o, l.getX(r), l.getX(r + 1), r);
                            i && e.push(i)
                        }
                        if (this.isLineLoop) {
                            let r = ni(this, t, r7, o, l.getX(s - 1), l.getX(i), s - 1);
                            r && e.push(r)
                        }
                    } else {
                        let i = Math.max(0, n.start),
                            s = Math.min(u.count, n.start + n.count);
                        for (let r = i, n = s - 1; r < n; r += h) {
                            let i = ni(this, t, r7, o, r, r + 1, r);
                            i && e.push(i)
                        }
                        if (this.isLineLoop) {
                            let r = ni(this, t, r7, o, s - 1, i, s - 1);
                            r && e.push(r)
                        }
                    }
                }
                updateMorphTargets() {
                    let t = this.geometry.morphAttributes,
                        e = Object.keys(t);
                    if (e.length > 0) {
                        let i = t[e[0]];
                        if (void 0 !== i) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let t = 0, e = i.length; t < e; t++) {
                                let e = i[t].name || String(t);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                            }
                        }
                    }
                }
            }

            function ni(t, e, i, s, r, n, a) {
                let o = t.geometry.attributes.position;
                if (r5.fromBufferAttribute(o, r), r4.fromBufferAttribute(o, n), i.distanceSqToSegment(r5, r4, r8, nt) > s) return;
                r8.applyMatrix4(t.matrixWorld);
                let h = e.ray.origin.distanceTo(r8);
                if (!(h < e.near) && !(h > e.far)) return {
                    distance: h,
                    point: nt.clone().applyMatrix4(t.matrixWorld),
                    index: a,
                    face: null,
                    faceIndex: null,
                    barycoord: null,
                    object: t
                }
            }
            let ns = new e9,
                nr = new e9;
            class nn extends ne {
                constructor(t, e) {
                    super(t, e), this.isLineSegments = !0, this.type = "LineSegments"
                }
                computeLineDistances() {
                    let t = this.geometry;
                    if (null === t.index) {
                        let e = t.attributes.position,
                            i = [];
                        for (let t = 0, s = e.count; t < s; t += 2) ns.fromBufferAttribute(e, t), nr.fromBufferAttribute(e, t + 1), i[t] = 0 === t ? 0 : i[t - 1], i[t + 1] = i[t] + ns.distanceTo(nr);
                        t.setAttribute("lineDistance", new sU(i, 1))
                    } else eJ("LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    return this
                }
            }
            class na extends ne {
                constructor(t, e) {
                    super(t, e), this.isLineLoop = !0, this.type = "LineLoop"
                }
            }
            class no extends sP {
                constructor(t) {
                    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new sB(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this
                }
            }
            let nh = new iG,
                nl = new iX,
                nu = new iD,
                nc = new e9;
            class np extends sp {
                constructor(t = new sH, e = new no) {
                    super(), this.isPoints = !0, this.type = "Points", this.geometry = t, this.material = e, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets()
                }
                copy(t, e) {
                    return super.copy(t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this
                }
                raycast(t, e) {
                    let i = this.geometry,
                        s = this.matrixWorld,
                        r = t.params.Points.threshold,
                        n = i.drawRange;
                    if (null === i.boundingSphere && i.computeBoundingSphere(), nu.copy(i.boundingSphere), nu.applyMatrix4(s), nu.radius += r, !1 === t.ray.intersectsSphere(nu)) return;
                    nh.copy(s).invert(), nl.copy(t.ray).applyMatrix4(nh);
                    let a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        o = a * a,
                        h = i.index,
                        l = i.attributes.position;
                    if (null !== h) {
                        let i = Math.max(0, n.start),
                            r = Math.min(h.count, n.start + n.count);
                        for (let n = i; n < r; n++) {
                            let i = h.getX(n);
                            nc.fromBufferAttribute(l, i), nd(nc, i, o, s, t, e, this)
                        }
                    } else {
                        let i = Math.max(0, n.start),
                            r = Math.min(l.count, n.start + n.count);
                        for (let n = i; n < r; n++) nc.fromBufferAttribute(l, n), nd(nc, n, o, s, t, e, this)
                    }
                }
                updateMorphTargets() {
                    let t = this.geometry.morphAttributes,
                        e = Object.keys(t);
                    if (e.length > 0) {
                        let i = t[e[0]];
                        if (void 0 !== i) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let t = 0, e = i.length; t < e; t++) {
                                let e = i[t].name || String(t);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                            }
                        }
                    }
                }
            }

            function nd(t, e, i, s, r, n, a) {
                let o = nl.distanceSqToPoint(t);
                if (o < i) {
                    let i = new e9;
                    nl.closestPointToPoint(t, i), i.applyMatrix4(s);
                    let h = r.ray.origin.distanceTo(i);
                    if (h < r.near || h > r.far) return;
                    n.push({
                        distance: h,
                        distanceToRay: Math.sqrt(o),
                        point: i,
                        index: e,
                        face: null,
                        faceIndex: null,
                        barycoord: null,
                        object: a
                    })
                }
            }
            class nm extends iy {
                constructor(t, e, i, s, r, n, a, o, h) {
                    super(t, e, i, s, r, n, a, o, h), this.isCanvasTexture = !0, this.needsUpdate = !0
                }
            }
            class ny extends iy {
                constructor(t, e, i = tT, s, r, n, a = tf, o = tf, h, l = tE, u = 1) {
                    if (l !== tE && l !== tF) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                    super({
                        width: t,
                        height: e,
                        depth: u
                    }, s, r, n, a, o, l, i, h), this.isDepthTexture = !0, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
                }
                copy(t) {
                    return super.copy(t), this.source = new ic(Object.assign({}, t.image)), this.compareFunction = t.compareFunction, this
                }
                toJSON(t) {
                    let e = super.toJSON(t);
                    return null !== this.compareFunction && (e.compareFunction = this.compareFunction), e
                }
            }
            class nf extends ny {
                constructor(t, e = tT, i = th, s, r, n = tf, a = tf, o, h = tE) {
                    let l = {
                        width: t,
                        height: t,
                        depth: 1
                    };
                    super(t, t, e, i, s, r, n, a, o, h), this.image = [l, l, l, l, l, l], this.isCubeDepthTexture = !0, this.isCubeTexture = !0
                }
                get images() {
                    return this.image
                }
                set images(t) {
                    this.image = t
                }
            }
            class ng extends iy {
                constructor(t = null) {
                    super(), this.sourceTexture = t, this.isExternalTexture = !0
                }
                copy(t) {
                    return super.copy(t), this.sourceTexture = t.sourceTexture, this
                }
            }
            class nx extends sH {
                constructor(t = 1, e = 1, i = 4, s = 8, r = 1) {
                    super(), this.type = "CapsuleGeometry", this.parameters = {
                        radius: t,
                        height: e,
                        capSegments: i,
                        radialSegments: s,
                        heightSegments: r
                    }, e = Math.max(0, e), i = Math.max(1, Math.floor(i)), s = Math.max(3, Math.floor(s));
                    let n = [],
                        a = [],
                        o = [],
                        h = [],
                        l = e / 2,
                        u = Math.PI / 2 * t,
                        c = e,
                        p = 2 * u + c,
                        d = 2 * i + (r = Math.max(1, Math.floor(r))),
                        m = s + 1,
                        y = new e9,
                        f = new e9;
                    for (let g = 0; g <= d; g++) {
                        let x = 0,
                            b = 0,
                            M = 0,
                            v = 0;
                        if (g <= i) {
                            let e = g / i,
                                s = e * Math.PI / 2;
                            b = -l - t * Math.cos(s), M = t * Math.sin(s), v = -t * Math.cos(s), x = e * u
                        } else if (g <= i + r) {
                            let s = (g - i) / r;
                            b = -l + s * e, M = t, v = 0, x = u + s * c
                        } else {
                            let e = (g - i - r) / i,
                                s = e * Math.PI / 2;
                            b = l + t * Math.sin(s), M = t * Math.cos(s), v = t * Math.sin(s), x = u + c + e * u
                        }
                        let w = Math.max(0, Math.min(1, x / p)),
                            S = 0;
                        0 === g ? S = .5 / s : g === d && (S = -.5 / s);
                        for (let t = 0; t <= s; t++) {
                            let e = t / s,
                                i = e * Math.PI * 2,
                                r = Math.sin(i),
                                n = Math.cos(i);
                            f.x = -M * n, f.y = b, f.z = M * r, a.push(f.x, f.y, f.z), y.set(-M * n, v, M * r), y.normalize(), o.push(y.x, y.y, y.z), h.push(e + S, w)
                        }
                        if (g > 0) {
                            let t = (g - 1) * m;
                            for (let e = 0; e < s; e++) {
                                let i = t + e,
                                    s = t + e + 1,
                                    r = g * m + e,
                                    a = g * m + e + 1;
                                n.push(i, s, r), n.push(s, a, r)
                            }
                        }
                    }
                    this.setIndex(n), this.setAttribute("position", new sU(a, 3)), this.setAttribute("normal", new sU(o, 3)), this.setAttribute("uv", new sU(h, 2))
                }
                copy(t) {
                    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                }
                static fromJSON(t) {
                    return new nx(t.radius, t.height, t.capSegments, t.radialSegments, t.heightSegments)
                }
            }
            class nb extends sH {
                constructor(t = 1, e = 32, i = 0, s = 2 * Math.PI) {
                    super(), this.type = "CircleGeometry", this.parameters = {
                        radius: t,
                        segments: e,
                        thetaStart: i,
                        thetaLength: s
                    }, e = Math.max(3, e);
                    let r = [],
                        n = [],
                        a = [],
                        o = [],
                        h = new e9,
                        l = new e6;
                    n.push(0, 0, 0), a.push(0, 0, 1), o.push(.5, .5);
                    for (let r = 0, u = 3; r <= e; r++, u += 3) {
                        let c = i + r / e * s;
                        h.x = t * Math.cos(c), h.y = t * Math.sin(c), n.push(h.x, h.y, h.z), a.push(0, 0, 1), l.x = (n[u] / t + 1) / 2, l.y = (n[u + 1] / t + 1) / 2, o.push(l.x, l.y)
                    }
                    for (let t = 1; t <= e; t++) r.push(t, t + 1, 0);
                    this.setIndex(r), this.setAttribute("position", new sU(n, 3)), this.setAttribute("normal", new sU(a, 3)), this.setAttribute("uv", new sU(o, 2))
                }
                copy(t) {
                    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                }
                static fromJSON(t) {
                    return new nb(t.radius, t.segments, t.thetaStart, t.thetaLength)
                }
            }
            class nM extends sH {
                constructor(t = 1, e = 1, i = 1, s = 32, r = 1, n = !1, a = 0, o = 2 * Math.PI) {
                    super(), this.type = "CylinderGeometry", this.parameters = {
                        radiusTop: t,
                        radiusBottom: e,
                        height: i,
                        radialSegments: s,
                        heightSegments: r,
                        openEnded: n,
                        thetaStart: a,
                        thetaLength: o
                    };
                    let h = this;
                    s = Math.floor(s), r = Math.floor(r);
                    let l = [],
                        u = [],
                        c = [],
                        p = [],
                        d = 0,
                        m = [],
                        y = i / 2,
                        f = 0;

                    function g(i) {
                        let r = d,
                            n = new e6,
                            m = new e9,
                            g = 0,
                            x = !0 === i ? t : e,
                            b = !0 === i ? 1 : -1;
                        for (let t = 1; t <= s; t++) u.push(0, y * b, 0), c.push(0, b, 0), p.push(.5, .5), d++;
                        let M = d;
                        for (let t = 0; t <= s; t++) {
                            let e = t / s * o + a,
                                i = Math.cos(e),
                                r = Math.sin(e);
                            m.x = x * r, m.y = y * b, m.z = x * i, u.push(m.x, m.y, m.z), c.push(0, b, 0), n.x = .5 * i + .5, n.y = .5 * r * b + .5, p.push(n.x, n.y), d++
                        }
                        for (let t = 0; t < s; t++) {
                            let e = r + t,
                                s = M + t;
                            !0 === i ? l.push(s, s + 1, e) : l.push(s + 1, s, e), g += 3
                        }
                        h.addGroup(f, g, !0 === i ? 1 : 2), f += g
                    }(function() {
                        let n = new e9,
                            g = new e9,
                            x = 0,
                            b = (e - t) / i;
                        for (let h = 0; h <= r; h++) {
                            let l = [],
                                f = h / r,
                                x = f * (e - t) + t;
                            for (let t = 0; t <= s; t++) {
                                let e = t / s,
                                    r = e * o + a,
                                    h = Math.sin(r),
                                    m = Math.cos(r);
                                g.x = x * h, g.y = -f * i + y, g.z = x * m, u.push(g.x, g.y, g.z), n.set(h, b, m).normalize(), c.push(n.x, n.y, n.z), p.push(e, 1 - f), l.push(d++)
                            }
                            m.push(l)
                        }
                        for (let i = 0; i < s; i++)
                            for (let s = 0; s < r; s++) {
                                let n = m[s][i],
                                    a = m[s + 1][i],
                                    o = m[s + 1][i + 1],
                                    h = m[s][i + 1];
                                (t > 0 || 0 !== s) && (l.push(n, a, h), x += 3), (e > 0 || s !== r - 1) && (l.push(a, o, h), x += 3)
                            }
                        h.addGroup(f, x, 0), f += x
                    })(), !1 === n && (t > 0 && g(!0), e > 0 && g(!1)), this.setIndex(l), this.setAttribute("position", new sU(u, 3)), this.setAttribute("normal", new sU(c, 3)), this.setAttribute("uv", new sU(p, 2))
                }
                copy(t) {
                    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                }
                static fromJSON(t) {
                    return new nM(t.radiusTop, t.radiusBottom, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength)
                }
            }
            class nv extends nM {
                constructor(t = 1, e = 1, i = 32, s = 1, r = !1, n = 0, a = 2 * Math.PI) {
                    super(0, t, e, i, s, r, n, a), this.type = "ConeGeometry", this.parameters = {
                        radius: t,
                        height: e,
                        radialSegments: i,
                        heightSegments: s,
                        openEnded: r,
                        thetaStart: n,
                        thetaLength: a
                    }
                }
                static fromJSON(t) {
                    return new nv(t.radius, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength)
                }
            }
            class nw extends sH {
                constructor(t = [], e = [], i = 1, s = 0) {
                    super(), this.type = "PolyhedronGeometry", this.parameters = {
                        vertices: t,
                        indices: e,
                        radius: i,
                        detail: s
                    };
                    let r = [],
                        n = [];

                    function a(t) {
                        r.push(t.x, t.y, t.z)
                    }

                    function o(e, i) {
                        let s = 3 * e;
                        i.x = t[s + 0], i.y = t[s + 1], i.z = t[s + 2]
                    }

                    function h(t, e, i, s) {
                        s < 0 && 1 === t.x && (n[e] = t.x - 1), 0 === i.x && 0 === i.z && (n[e] = s / 2 / Math.PI + .5)
                    }

                    function l(t) {
                        return Math.atan2(t.z, -t.x)
                    }(function(t) {
                        let i = new e9,
                            s = new e9,
                            r = new e9;
                        for (let n = 0; n < e.length; n += 3) o(e[n + 0], i), o(e[n + 1], s), o(e[n + 2], r),
                            function(t, e, i, s) {
                                let r = s + 1,
                                    n = [];
                                for (let s = 0; s <= r; s++) {
                                    n[s] = [];
                                    let a = t.clone().lerp(i, s / r),
                                        o = e.clone().lerp(i, s / r),
                                        h = r - s;
                                    for (let t = 0; t <= h; t++) 0 === t && s === r ? n[s][t] = a : n[s][t] = a.clone().lerp(o, t / h)
                                }
                                for (let t = 0; t < r; t++)
                                    for (let e = 0; e < 2 * (r - t) - 1; e++) {
                                        let i = Math.floor(e / 2);
                                        e % 2 == 0 ? (a(n[t][i + 1]), a(n[t + 1][i]), a(n[t][i])) : (a(n[t][i + 1]), a(n[t + 1][i + 1]), a(n[t + 1][i]))
                                    }
                            }(i, s, r, t)
                    })(s),
                    function(t) {
                        let e = new e9;
                        for (let i = 0; i < r.length; i += 3) e.x = r[i + 0], e.y = r[i + 1], e.z = r[i + 2], e.normalize().multiplyScalar(t), r[i + 0] = e.x, r[i + 1] = e.y, r[i + 2] = e.z
                    }(i),
                    function() {
                        let t = new e9;
                        for (let e = 0; e < r.length; e += 3) {
                            t.x = r[e + 0], t.y = r[e + 1], t.z = r[e + 2];
                            let i = l(t) / 2 / Math.PI + .5,
                                s = Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI + .5;
                            n.push(i, 1 - s)
                        }(function() {
                            let t = new e9,
                                e = new e9,
                                i = new e9,
                                s = new e9,
                                a = new e6,
                                o = new e6,
                                u = new e6;
                            for (let c = 0, p = 0; c < r.length; c += 9, p += 6) {
                                t.set(r[c + 0], r[c + 1], r[c + 2]), e.set(r[c + 3], r[c + 4], r[c + 5]), i.set(r[c + 6], r[c + 7], r[c + 8]), a.set(n[p + 0], n[p + 1]), o.set(n[p + 2], n[p + 3]), u.set(n[p + 4], n[p + 5]), s.copy(t).add(e).add(i).divideScalar(3);
                                let d = l(s);
                                h(a, p + 0, t, d), h(o, p + 2, e, d), h(u, p + 4, i, d)
                            }
                        })(),
                        function() {
                            for (let t = 0; t < n.length; t += 6) {
                                let e = n[t + 0],
                                    i = n[t + 2],
                                    s = n[t + 4],
                                    r = Math.max(e, i, s),
                                    a = Math.min(e, i, s);
                                r > .9 && a < .1 && (e < .2 && (n[t + 0] += 1), i < .2 && (n[t + 2] += 1), s < .2 && (n[t + 4] += 1))
                            }
                        }()
                    }(), this.setAttribute("position", new sU(r, 3)), this.setAttribute("normal", new sU(r.slice(), 3)), this.setAttribute("uv", new sU(n, 2)), 0 === s ? this.computeVertexNormals() : this.normalizeNormals()
                }
                copy(t) {
                    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                }
                static fromJSON(t) {
                    return new nw(t.vertices, t.indices, t.radius, t.detail)
                }
            }
            class nS extends nw {
                constructor(t = 1, e = 0) {
                    let i = (1 + Math.sqrt(5)) / 2,
                        s = 1 / i;
                    super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -s, -i, 0, -s, i, 0, s, -i, 0, s, i, -s, -i, 0, -s, i, 0, s, -i, 0, s, i, 0, -i, 0, -s, i, 0, -s, -i, 0, s, i, 0, s], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronGeometry", this.parameters = {
                        radius: t,
                        detail: e
                    }
                }
                static fromJSON(t) {
                    return new nS(t.radius, t.detail)
                }
            }
            class n_ {
                constructor() {
                    this.type = "Curve", this.arcLengthDivisions = 200, this.needsUpdate = !1, this.cacheArcLengths = null
                }
                getPoint() {
                    eJ("Curve: .getPoint() not implemented.")
                }
                getPointAt(t, e) {
                    let i = this.getUtoTmapping(t);
                    return this.getPoint(i, e)
                }
                getPoints(t = 5) {
                    let e = [];
                    for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                    return e
                }
                getSpacedPoints(t = 5) {
                    let e = [];
                    for (let i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
                    return e
                }
                getLength() {
                    let t = this.getLengths();
                    return t[t.length - 1]
                }
                getLengths(t = this.arcLengthDivisions) {
                    if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    let e = [],
                        i, s = this.getPoint(0),
                        r = 0;
                    e.push(0);
                    for (let n = 1; n <= t; n++) e.push(r += (i = this.getPoint(n / t)).distanceTo(s)), s = i;
                    return this.cacheArcLengths = e, e
                }
                updateArcLengths() {
                    this.needsUpdate = !0, this.getLengths()
                }
                getUtoTmapping(t, e = null) {
                    let i;
                    let s = this.getLengths(),
                        r = 0,
                        n = s.length;
                    i = e || t * s[n - 1];
                    let a = 0,
                        o = n - 1,
                        h;
                    for (; a <= o;)
                        if ((h = s[r = Math.floor(a + (o - a) / 2)] - i) < 0) a = r + 1;
                        else if (h > 0) o = r - 1;
                    else {
                        o = r;
                        break
                    }
                    if (s[r = o] === i) return r / (n - 1);
                    let l = s[r],
                        u = s[r + 1];
                    return (r + (i - l) / (u - l)) / (n - 1)
                }
                getTangent(t, e) {
                    let i = t - 1e-4,
                        s = t + 1e-4;
                    i < 0 && (i = 0), s > 1 && (s = 1);
                    let r = this.getPoint(i),
                        n = this.getPoint(s),
                        a = e || (r.isVector2 ? new e6 : new e9);
                    return a.copy(n).sub(r).normalize(), a
                }
                getTangentAt(t, e) {
                    let i = this.getUtoTmapping(t);
                    return this.getTangent(i, e)
                }
                computeFrenetFrames(t, e = !1) {
                    let i = new e9,
                        s = [],
                        r = [],
                        n = [],
                        a = new e9,
                        o = new iG;
                    for (let e = 0; e <= t; e++) {
                        let i = e / t;
                        s[e] = this.getTangentAt(i, new e9)
                    }
                    r[0] = new e9, n[0] = new e9;
                    let h = Number.MAX_VALUE,
                        l = Math.abs(s[0].x),
                        u = Math.abs(s[0].y),
                        c = Math.abs(s[0].z);
                    l <= h && (h = l, i.set(1, 0, 0)), u <= h && (h = u, i.set(0, 1, 0)), c <= h && i.set(0, 0, 1), a.crossVectors(s[0], i).normalize(), r[0].crossVectors(s[0], a), n[0].crossVectors(s[0], r[0]);
                    for (let e = 1; e <= t; e++) {
                        if (r[e] = r[e - 1].clone(), n[e] = n[e - 1].clone(), a.crossVectors(s[e - 1], s[e]), a.length() > Number.EPSILON) {
                            a.normalize();
                            let t = Math.acos(e0(s[e - 1].dot(s[e]), -1, 1));
                            r[e].applyMatrix4(o.makeRotationAxis(a, t))
                        }
                        n[e].crossVectors(s[e], r[e])
                    }
                    if (!0 === e) {
                        let e = Math.acos(e0(r[0].dot(r[t]), -1, 1));
                        e /= t, s[0].dot(a.crossVectors(r[0], r[t])) > 0 && (e = -e);
                        for (let i = 1; i <= t; i++) r[i].applyMatrix4(o.makeRotationAxis(s[i], e * i)), n[i].crossVectors(s[i], r[i])
                    }
                    return {
                        tangents: s,
                        normals: r,
                        binormals: n
                    }
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                copy(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                }
                toJSON() {
                    let t = {
                        metadata: {
                            version: 4.7,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
                }
                fromJSON(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                }
            }
            class nz extends n_ {
                constructor(t = 0, e = 0, i = 1, s = 1, r = 0, n = 2 * Math.PI, a = !1, o = 0) {
                    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = i, this.yRadius = s, this.aStartAngle = r, this.aEndAngle = n, this.aClockwise = a, this.aRotation = o
                }
                getPoint(t, e = new e6) {
                    let i = 2 * Math.PI,
                        s = this.aEndAngle - this.aStartAngle,
                        r = Math.abs(s) < Number.EPSILON;
                    for (; s < 0;) s += i;
                    for (; s > i;) s -= i;
                    s < Number.EPSILON && (s = r ? 0 : i), !0 !== this.aClockwise || r || (s === i ? s = -i : s -= i);
                    let n = this.aStartAngle + t * s,
                        a = this.aX + this.xRadius * Math.cos(n),
                        o = this.aY + this.yRadius * Math.sin(n);
                    if (0 !== this.aRotation) {
                        let t = Math.cos(this.aRotation),
                            e = Math.sin(this.aRotation),
                            i = a - this.aX,
                            s = o - this.aY;
                        a = i * t - s * e + this.aX, o = i * e + s * t + this.aY
                    }
                    return e.set(a, o)
                }
                copy(t) {
                    return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
                }
                toJSON() {
                    let t = super.toJSON();
                    return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
                }
            }
            class nA extends nz {
                constructor(t, e, i, s, r, n) {
                    super(t, e, i, i, s, r, n), this.isArcCurve = !0, this.type = "ArcCurve"
                }
            }

            function nT() {
                let t = 0,
                    e = 0,
                    i = 0,
                    s = 0;

                function r(r, n, a, o) {
                    t = r, e = a, i = -3 * r + 3 * n - 2 * a - o, s = 2 * r - 2 * n + a + o
                }
                return {
                    initCatmullRom: function(t, e, i, s, n) {
                        r(e, i, n * (i - t), n * (s - e))
                    },
                    initNonuniformCatmullRom: function(t, e, i, s, n, a, o) {
                        let h = (e - t) / n - (i - t) / (n + a) + (i - e) / a,
                            l = (i - e) / a - (s - e) / (a + o) + (s - i) / o;
                        r(e, i, h *= a, l *= a)
                    },
                    calc: function(r) {
                        let n = r * r;
                        return t + e * r + i * n + n * r * s
                    }
                }
            }
            let nC = new e9,
                nO = new nT,
                nk = new nT,
                nB = new nT;
            class nN extends n_ {
                constructor(t = [], e = !1, i = "centripetal", s = .5) {
                    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = i, this.tension = s
                }
                getPoint(t, e = new e9) {
                    let i, s;
                    let r = this.points,
                        n = r.length,
                        a = (n - (this.closed ? 0 : 1)) * t,
                        o = Math.floor(a),
                        h = a - o;
                    this.closed ? o += o > 0 ? 0 : (Math.floor(Math.abs(o) / n) + 1) * n : 0 === h && o === n - 1 && (o = n - 2, h = 1), this.closed || o > 0 ? i = r[(o - 1) % n] : (nC.subVectors(r[0], r[1]).add(r[0]), i = nC);
                    let l = r[o % n],
                        u = r[(o + 1) % n];
                    if (this.closed || o + 2 < n ? s = r[(o + 2) % n] : (nC.subVectors(r[n - 1], r[n - 2]).add(r[n - 1]), s = nC), "centripetal" === this.curveType || "chordal" === this.curveType) {
                        let t = "chordal" === this.curveType ? .5 : .25,
                            e = Math.pow(i.distanceToSquared(l), t),
                            r = Math.pow(l.distanceToSquared(u), t),
                            n = Math.pow(u.distanceToSquared(s), t);
                        r < 1e-4 && (r = 1), e < 1e-4 && (e = r), n < 1e-4 && (n = r), nO.initNonuniformCatmullRom(i.x, l.x, u.x, s.x, e, r, n), nk.initNonuniformCatmullRom(i.y, l.y, u.y, s.y, e, r, n), nB.initNonuniformCatmullRom(i.z, l.z, u.z, s.z, e, r, n)
                    } else "catmullrom" === this.curveType && (nO.initCatmullRom(i.x, l.x, u.x, s.x, this.tension), nk.initCatmullRom(i.y, l.y, u.y, s.y, this.tension), nB.initCatmullRom(i.z, l.z, u.z, s.z, this.tension));
                    return e.set(nO.calc(h), nk.calc(h), nB.calc(h)), e
                }
                copy(t) {
                    super.copy(t), this.points = [];
                    for (let e = 0, i = t.points.length; e < i; e++) {
                        let i = t.points[e];
                        this.points.push(i.clone())
                    }
                    return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                }
                toJSON() {
                    let t = super.toJSON();
                    t.points = [];
                    for (let e = 0, i = this.points.length; e < i; e++) {
                        let i = this.points[e];
                        t.points.push(i.toArray())
                    }
                    return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
                }
                fromJSON(t) {
                    super.fromJSON(t), this.points = [];
                    for (let e = 0, i = t.points.length; e < i; e++) {
                        let i = t.points[e];
                        this.points.push(new e9().fromArray(i))
                    }
                    return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                }
            }

            function nI(t, e, i, s, r) {
                let n = (s - e) * .5,
                    a = (r - i) * .5,
                    o = t * t;
                return t * o * (2 * i - 2 * s + n + a) + (-3 * i + 3 * s - 2 * n - a) * o + n * t + i
            }

            function nP(t, e, i, s) {
                return function(t, e) {
                    let i = 1 - t;
                    return i * i * e
                }(t, e) + 2 * (1 - t) * t * i + t * t * s
            }

            function nR(t, e, i, s, r) {
                return function(t, e) {
                    let i = 1 - t;
                    return i * i * i * e
                }(t, e) + function(t, e) {
                    let i = 1 - t;
                    return 3 * i * i * t * e
                }(t, i) + 3 * (1 - t) * t * t * s + t * t * t * r
            }
            class nV extends n_ {
                constructor(t = new e6, e = new e6, i = new e6, s = new e6) {
                    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = i, this.v3 = s
                }
                getPoint(t, e = new e6) {
                    let i = this.v0,
                        s = this.v1,
                        r = this.v2,
                        n = this.v3;
                    return e.set(nR(t, i.x, s.x, r.x, n.x), nR(t, i.y, s.y, r.y, n.y)), e
                }
                copy(t) {
                    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
                }
                toJSON() {
                    let t = super.toJSON();
                    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
                }
            }
            class nL extends n_ {
                constructor(t = new e9, e = new e9, i = new e9, s = new e9) {
                    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = i, this.v3 = s
                }
                getPoint(t, e = new e9) {
                    let i = this.v0,
                        s = this.v1,
                        r = this.v2,
                        n = this.v3;
                    return e.set(nR(t, i.x, s.x, r.x, n.x), nR(t, i.y, s.y, r.y, n.y), nR(t, i.z, s.z, r.z, n.z)), e
                }
                copy(t) {
                    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
                }
                toJSON() {
                    let t = super.toJSON();
                    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
                }
            }
            class nE extends n_ {
                constructor(t = new e6, e = new e6) {
                    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = t, this.v2 = e
                }
                getPoint(t, e = new e6) {
                    return 1 === t ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1), e.multiplyScalar(t).add(this.v1)), e
                }
                getPointAt(t, e) {
                    return this.getPoint(t, e)
                }
                getTangent(t, e = new e6) {
                    return e.subVectors(this.v2, this.v1).normalize()
                }
                getTangentAt(t, e) {
                    return this.getTangent(t, e)
                }
                copy(t) {
                    return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                }
                toJSON() {
                    let t = super.toJSON();
                    return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                }
            }
            class nF extends n_ {
                constructor(t = new e9, e = new e9) {
                    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = t, this.v2 = e
                }
                getPoint(t, e = new e9) {
                    return 1 === t ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1), e.multiplyScalar(t).add(this.v1)), e
                }
                getPointAt(t, e) {
                    return this.getPoint(t, e)
                }
                getTangent(t, e = new e9) {
                    return e.subVectors(this.v2, this.v1).normalize()
                }
                getTangentAt(t, e) {
                    return this.getTangent(t, e)
                }
                copy(t) {
                    return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                }
                toJSON() {
                    let t = super.toJSON();
                    return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                }
            }
            class nD extends n_ {
                constructor(t = new e6, e = new e6, i = new e6) {
                    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = i
                }
                getPoint(t, e = new e6) {
                    let i = this.v0,
                        s = this.v1,
                        r = this.v2;
                    return e.set(nP(t, i.x, s.x, r.x), nP(t, i.y, s.y, r.y)), e
                }
                copy(t) {
                    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                }
                toJSON() {
                    let t = super.toJSON();
                    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                }
            }
            class nj extends n_ {
                constructor(t = new e9, e = new e9, i = new e9) {
                    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = i
                }
                getPoint(t, e = new e9) {
                    let i = this.v0,
                        s = this.v1,
                        r = this.v2;
                    return e.set(nP(t, i.x, s.x, r.x), nP(t, i.y, s.y, r.y), nP(t, i.z, s.z, r.z)), e
                }
                copy(t) {
                    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                }
                toJSON() {
                    let t = super.toJSON();
                    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                }
            }
            class nU extends n_ {
                constructor(t = []) {
                    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = t
                }
                getPoint(t, e = new e6) {
                    let i = this.points,
                        s = (i.length - 1) * t,
                        r = Math.floor(s),
                        n = s - r,
                        a = i[0 === r ? r : r - 1],
                        o = i[r],
                        h = i[r > i.length - 2 ? i.length - 1 : r + 1],
                        l = i[r > i.length - 3 ? i.length - 1 : r + 2];
                    return e.set(nI(n, a.x, o.x, h.x, l.x), nI(n, a.y, o.y, h.y, l.y)), e
                }
                copy(t) {
                    super.copy(t), this.points = [];
                    for (let e = 0, i = t.points.length; e < i; e++) {
                        let i = t.points[e];
                        this.points.push(i.clone())
                    }
                    return this
                }
                toJSON() {
                    let t = super.toJSON();
                    t.points = [];
                    for (let e = 0, i = this.points.length; e < i; e++) {
                        let i = this.points[e];
                        t.points.push(i.toArray())
                    }
                    return t
                }
                fromJSON(t) {
                    super.fromJSON(t), this.points = [];
                    for (let e = 0, i = t.points.length; e < i; e++) {
                        let i = t.points[e];
                        this.points.push(new e6().fromArray(i))
                    }
                    return this
                }
            }
            var nW = Object.freeze({
                __proto__: null,
                ArcCurve: nA,
                CatmullRomCurve3: nN,
                CubicBezierCurve: nV,
                CubicBezierCurve3: nL,
                EllipseCurve: nz,
                LineCurve: nE,
                LineCurve3: nF,
                QuadraticBezierCurve: nD,
                QuadraticBezierCurve3: nj,
                SplineCurve: nU
            });
            class nJ extends n_ {
                constructor() {
                    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
                }
                add(t) {
                    this.curves.push(t)
                }
                closePath() {
                    let t = this.curves[0].getPoint(0),
                        e = this.curves[this.curves.length - 1].getPoint(1);
                    if (!t.equals(e)) {
                        let i = !0 === t.isVector2 ? "LineCurve" : "LineCurve3";
                        this.curves.push(new nW[i](e, t))
                    }
                    return this
                }
                getPoint(t, e) {
                    let i = t * this.getLength(),
                        s = this.getCurveLengths(),
                        r = 0;
                    for (; r < s.length;) {
                        if (s[r] >= i) {
                            let t = s[r] - i,
                                n = this.curves[r],
                                a = n.getLength(),
                                o = 0 === a ? 0 : 1 - t / a;
                            return n.getPointAt(o, e)
                        }
                        r++
                    }
                    return null
                }
                getLength() {
                    let t = this.getCurveLengths();
                    return t[t.length - 1]
                }
                updateArcLengths() {
                    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                }
                getCurveLengths() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    let t = [],
                        e = 0;
                    for (let i = 0, s = this.curves.length; i < s; i++) t.push(e += this.curves[i].getLength());
                    return this.cacheLengths = t, t
                }
                getSpacedPoints(t = 40) {
                    let e = [];
                    for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                    return this.autoClose && e.push(e[0]), e
                }
                getPoints(t = 12) {
                    let e;
                    let i = [];
                    for (let s = 0, r = this.curves; s < r.length; s++) {
                        let n = r[s],
                            a = n.isEllipseCurve ? 2 * t : n.isLineCurve || n.isLineCurve3 ? 1 : n.isSplineCurve ? t * n.points.length : t,
                            o = n.getPoints(a);
                        for (let t = 0; t < o.length; t++) {
                            let s = o[t];
                            e && e.equals(s) || (i.push(s), e = s)
                        }
                    }
                    return this.autoClose && i.length > 1 && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i
                }
                copy(t) {
                    super.copy(t), this.curves = [];
                    for (let e = 0, i = t.curves.length; e < i; e++) {
                        let i = t.curves[e];
                        this.curves.push(i.clone())
                    }
                    return this.autoClose = t.autoClose, this
                }
                toJSON() {
                    let t = super.toJSON();
                    t.autoClose = this.autoClose, t.curves = [];
                    for (let e = 0, i = this.curves.length; e < i; e++) {
                        let i = this.curves[e];
                        t.curves.push(i.toJSON())
                    }
                    return t
                }
                fromJSON(t) {
                    super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
                    for (let e = 0, i = t.curves.length; e < i; e++) {
                        let i = t.curves[e];
                        this.curves.push(new nW[i.type]().fromJSON(i))
                    }
                    return this
                }
            }
            class nq extends nJ {
                constructor(t) {
                    super(), this.type = "Path", this.currentPoint = new e6, t && this.setFromPoints(t)
                }
                setFromPoints(t) {
                    this.moveTo(t[0].x, t[0].y);
                    for (let e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y);
                    return this
                }
                moveTo(t, e) {
                    return this.currentPoint.set(t, e), this
                }
                lineTo(t, e) {
                    let i = new nE(this.currentPoint.clone(), new e6(t, e));
                    return this.curves.push(i), this.currentPoint.set(t, e), this
                }
                quadraticCurveTo(t, e, i, s) {
                    let r = new nD(this.currentPoint.clone(), new e6(t, e), new e6(i, s));
                    return this.curves.push(r), this.currentPoint.set(i, s), this
                }
                bezierCurveTo(t, e, i, s, r, n) {
                    let a = new nV(this.currentPoint.clone(), new e6(t, e), new e6(i, s), new e6(r, n));
                    return this.curves.push(a), this.currentPoint.set(r, n), this
                }
                splineThru(t) {
                    let e = new nU([this.currentPoint.clone()].concat(t));
                    return this.curves.push(e), this.currentPoint.copy(t[t.length - 1]), this
                }
                arc(t, e, i, s, r, n) {
                    let a = this.currentPoint.x,
                        o = this.currentPoint.y;
                    return this.absarc(t + a, e + o, i, s, r, n), this
                }
                absarc(t, e, i, s, r, n) {
                    return this.absellipse(t, e, i, i, s, r, n), this
                }
                ellipse(t, e, i, s, r, n, a, o) {
                    let h = this.currentPoint.x,
                        l = this.currentPoint.y;
                    return this.absellipse(t + h, e + l, i, s, r, n, a, o), this
                }
                absellipse(t, e, i, s, r, n, a, o) {
                    let h = new nz(t, e, i, s, r, n, a, o);
                    if (this.curves.length > 0) {
                        let t = h.getPoint(0);
                        t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                    }
                    this.curves.push(h);
                    let l = h.getPoint(1);
                    return this.currentPoint.copy(l), this
                }
                copy(t) {
                    return super.copy(t), this.currentPoint.copy(t.currentPoint), this
                }
                toJSON() {
                    let t = super.toJSON();
                    return t.currentPoint = this.currentPoint.toArray(), t
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
                }
            }
            class nZ extends nq {
                constructor(t) {
                    super(t), this.uuid = eK(), this.type = "Shape", this.holes = []
                }
                getPointsHoles(t) {
                    let e = [];
                    for (let i = 0, s = this.holes.length; i < s; i++) e[i] = this.holes[i].getPoints(t);
                    return e
                }
                extractPoints(t) {
                    return {
                        shape: this.getPoints(t),
                        holes: this.getPointsHoles(t)
                    }
                }
                copy(t) {
                    super.copy(t), this.holes = [];
                    for (let e = 0, i = t.holes.length; e < i; e++) {
                        let i = t.holes[e];
                        this.holes.push(i.clone())
                    }
                    return this
                }
                toJSON() {
                    let t = super.toJSON();
                    t.uuid = this.uuid, t.holes = [];
                    for (let e = 0, i = this.holes.length; e < i; e++) {
                        let i = this.holes[e];
                        t.holes.push(i.toJSON())
                    }
                    return t
                }
                fromJSON(t) {
                    super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
                    for (let e = 0, i = t.holes.length; e < i; e++) {
                        let i = t.holes[e];
                        this.holes.push(new nq().fromJSON(i))
                    }
                    return this
                }
            }

            function nY(t, e, i, s, r) {
                let n;
                if (r === function(t, e, i, s) {
                        let r = 0;
                        for (let n = e, a = i - s; n < i; n += s) r += (t[a] - t[n]) * (t[n + 1] + t[a + 1]), a = n;
                        return r
                    }(t, e, i, s) > 0)
                    for (let r = e; r < i; r += s) n = n6(r / s | 0, t[r], t[r + 1], n);
                else
                    for (let r = i - s; r >= e; r -= s) n = n6(r / s | 0, t[r], t[r + 1], n);
                return n && n0(n, n.next) && (n7(n), n = n.next), n
            }

            function nX(t, e) {
                if (!t) return t;
                e || (e = t);
                let i = t,
                    s;
                do
                    if (s = !1, !i.steiner && (n0(i, i.next) || 0 === nK(i.prev, i, i.next))) {
                        if (n7(i), (i = e = i.prev) === i.next) break;
                        s = !0
                    } else i = i.next; while (s || i !== e);
                return e
            }

            function nG(t, e) {
                let i = t.x - e.x;
                return 0 === i && 0 == (i = t.y - e.y) && (i = (t.next.y - t.y) / (t.next.x - t.x) - (e.next.y - e.y) / (e.next.x - e.x)), i
            }

            function nH(t, e, i, s, r) {
                return (t = ((t = ((t = ((t = ((t = (t - i) * r | 0) | t << 8) & 16711935) | t << 4) & 252645135) | t << 2) & 858993459) | t << 1) & 1431655765) | (e = ((e = ((e = ((e = ((e = (e - s) * r | 0) | e << 8) & 16711935) | e << 4) & 252645135) | e << 2) & 858993459) | e << 1) & 1431655765) << 1
            }

            function nQ(t, e, i, s, r, n, a, o) {
                return (r - a) * (e - o) >= (t - a) * (n - o) && (t - a) * (s - o) >= (i - a) * (e - o) && (i - a) * (n - o) >= (r - a) * (s - o)
            }

            function n$(t, e, i, s, r, n, a, o) {
                return !(t === a && e === o) && nQ(t, e, i, s, r, n, a, o)
            }

            function nK(t, e, i) {
                return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
            }

            function n0(t, e) {
                return t.x === e.x && t.y === e.y
            }

            function n1(t, e, i, s) {
                let r = n3(nK(t, e, i)),
                    n = n3(nK(t, e, s)),
                    a = n3(nK(i, s, t)),
                    o = n3(nK(i, s, e));
                return !!(r !== n && a !== o || 0 === r && n2(t, i, e) || 0 === n && n2(t, s, e) || 0 === a && n2(i, t, s) || 0 === o && n2(i, e, s))
            }

            function n2(t, e, i) {
                return e.x <= Math.max(t.x, i.x) && e.x >= Math.min(t.x, i.x) && e.y <= Math.max(t.y, i.y) && e.y >= Math.min(t.y, i.y)
            }

            function n3(t) {
                return t > 0 ? 1 : t < 0 ? -1 : 0
            }

            function n5(t, e) {
                return 0 > nK(t.prev, t, t.next) ? nK(t, e, t.next) >= 0 && nK(t, t.prev, e) >= 0 : 0 > nK(t, e, t.prev) || 0 > nK(t, t.next, e)
            }

            function n4(t, e) {
                let i = n9(t.i, t.x, t.y),
                    s = n9(e.i, e.x, e.y),
                    r = t.next,
                    n = e.prev;
                return t.next = e, e.prev = t, i.next = r, r.prev = i, s.next = i, i.prev = s, n.next = s, s.prev = n, s
            }

            function n6(t, e, i, s) {
                let r = n9(t, e, i);
                return s ? (r.next = s.next, r.prev = s, s.next.prev = r, s.next = r) : (r.prev = r, r.next = r), r
            }

            function n7(t) {
                t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
            }

            function n9(t, e, i) {
                return {
                    i: t,
                    x: e,
                    y: i,
                    prev: null,
                    next: null,
                    z: 0,
                    prevZ: null,
                    nextZ: null,
                    steiner: !1
                }
            }
            class n8 {
                static triangulate(t, e, i = 2) {
                    return function(t, e, i = 2) {
                        let s, r, n;
                        let a = e && e.length,
                            o = a ? e[0] * i : t.length,
                            h = nY(t, 0, o, i, !0),
                            l = [];
                        if (!h || h.next === h.prev) return l;
                        if (a && (h = function(t, e, i, s) {
                                let r = [];
                                for (let i = 0, n = e.length; i < n; i++) {
                                    let a = e[i] * s,
                                        o = i < n - 1 ? e[i + 1] * s : t.length,
                                        h = nY(t, a, o, s, !1);
                                    h === h.next && (h.steiner = !0), r.push(function(t) {
                                        let e = t,
                                            i = t;
                                        do(e.x < i.x || e.x === i.x && e.y < i.y) && (i = e), e = e.next; while (e !== t);
                                        return i
                                    }(h))
                                }
                                r.sort(nG);
                                for (let t = 0; t < r.length; t++) i = function(t, e) {
                                    let i = function(t, e) {
                                        let i, s = e,
                                            r = t.x,
                                            n = t.y,
                                            a = -1 / 0;
                                        if (n0(t, s)) return s;
                                        do {
                                            if (n0(t, s.next)) return s.next;
                                            if (n <= s.y && n >= s.next.y && s.next.y !== s.y) {
                                                let t = s.x + (n - s.y) * (s.next.x - s.x) / (s.next.y - s.y);
                                                if (t <= r && t > a && (a = t, i = s.x < s.next.x ? s : s.next, t === r)) return i
                                            }
                                            s = s.next
                                        } while (s !== e);
                                        if (!i) return null;
                                        let o = i,
                                            h = i.x,
                                            l = i.y,
                                            u = 1 / 0;
                                        s = i;
                                        do {
                                            if (r >= s.x && s.x >= h && r !== s.x && nQ(n < l ? r : a, n, h, l, n < l ? a : r, n, s.x, s.y)) {
                                                var c, p;
                                                let e = Math.abs(n - s.y) / (r - s.x);
                                                n5(s, t) && (e < u || e === u && (s.x > i.x || s.x === i.x && (c = i, p = s, 0 > nK(c.prev, c, p.prev) && 0 > nK(p.next, c, c.next)))) && (i = s, u = e)
                                            }
                                            s = s.next
                                        } while (s !== o);
                                        return i
                                    }(t, e);
                                    if (!i) return e;
                                    let s = n4(i, t);
                                    return nX(s, s.next), nX(i, i.next)
                                }(r[t], i);
                                return i
                            }(t, e, h, i)), t.length > 80 * i) {
                            s = t[0], r = t[1];
                            let e = s,
                                a = r;
                            for (let n = i; n < o; n += i) {
                                let i = t[n],
                                    o = t[n + 1];
                                i < s && (s = i), o < r && (r = o), i > e && (e = i), o > a && (a = o)
                            }
                            n = 0 !== (n = Math.max(e - s, a - r)) ? 32767 / n : 0
                        }
                        return function t(e, i, s, r, n, a, o) {
                            if (!e) return;
                            !o && a && function(t, e, i, s) {
                                let r = t;
                                do 0 === r.z && (r.z = nH(r.x, r.y, e, i, s)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next; while (r !== t);
                                r.prevZ.nextZ = null, r.prevZ = null,
                                    function(t) {
                                        let e;
                                        let i = 1;
                                        do {
                                            let s, r = t;
                                            t = null;
                                            let n = null;
                                            for (e = 0; r;) {
                                                e++;
                                                let a = r,
                                                    o = 0;
                                                for (let t = 0; t < i && (o++, a = a.nextZ); t++);
                                                let h = i;
                                                for (; o > 0 || h > 0 && a;) 0 !== o && (0 === h || !a || r.z <= a.z) ? (s = r, r = r.nextZ, o--) : (s = a, a = a.nextZ, h--), n ? n.nextZ = s : t = s, s.prevZ = n, n = s;
                                                r = a
                                            }
                                            n.nextZ = null, i *= 2
                                        } while (e > 1)
                                    }(r)
                            }(e, r, n, a);
                            let h = e;
                            for (; e.prev !== e.next;) {
                                let l = e.prev,
                                    u = e.next;
                                if (a ? function(t, e, i, s) {
                                        let r = t.prev,
                                            n = t.next;
                                        if (nK(r, t, n) >= 0) return !1;
                                        let a = r.x,
                                            o = t.x,
                                            h = n.x,
                                            l = r.y,
                                            u = t.y,
                                            c = n.y,
                                            p = Math.min(a, o, h),
                                            d = Math.min(l, u, c),
                                            m = Math.max(a, o, h),
                                            y = Math.max(l, u, c),
                                            f = nH(p, d, e, i, s),
                                            g = nH(m, y, e, i, s),
                                            x = t.prevZ,
                                            b = t.nextZ;
                                        for (; x && x.z >= f && b && b.z <= g;) {
                                            if (x.x >= p && x.x <= m && x.y >= d && x.y <= y && x !== r && x !== n && n$(a, l, o, u, h, c, x.x, x.y) && nK(x.prev, x, x.next) >= 0 || (x = x.prevZ, b.x >= p && b.x <= m && b.y >= d && b.y <= y && b !== r && b !== n && n$(a, l, o, u, h, c, b.x, b.y) && nK(b.prev, b, b.next) >= 0)) return !1;
                                            b = b.nextZ
                                        }
                                        for (; x && x.z >= f;) {
                                            if (x.x >= p && x.x <= m && x.y >= d && x.y <= y && x !== r && x !== n && n$(a, l, o, u, h, c, x.x, x.y) && nK(x.prev, x, x.next) >= 0) return !1;
                                            x = x.prevZ
                                        }
                                        for (; b && b.z <= g;) {
                                            if (b.x >= p && b.x <= m && b.y >= d && b.y <= y && b !== r && b !== n && n$(a, l, o, u, h, c, b.x, b.y) && nK(b.prev, b, b.next) >= 0) return !1;
                                            b = b.nextZ
                                        }
                                        return !0
                                    }(e, r, n, a) : function(t) {
                                        let e = t.prev,
                                            i = t.next;
                                        if (nK(e, t, i) >= 0) return !1;
                                        let s = e.x,
                                            r = t.x,
                                            n = i.x,
                                            a = e.y,
                                            o = t.y,
                                            h = i.y,
                                            l = Math.min(s, r, n),
                                            u = Math.min(a, o, h),
                                            c = Math.max(s, r, n),
                                            p = Math.max(a, o, h),
                                            d = i.next;
                                        for (; d !== e;) {
                                            if (d.x >= l && d.x <= c && d.y >= u && d.y <= p && n$(s, a, r, o, n, h, d.x, d.y) && nK(d.prev, d, d.next) >= 0) return !1;
                                            d = d.next
                                        }
                                        return !0
                                    }(e)) {
                                    i.push(l.i, e.i, u.i), n7(e), e = u.next, h = u.next;
                                    continue
                                }
                                if ((e = u) === h) {
                                    o ? 1 === o ? t(e = function(t, e) {
                                        let i = t;
                                        do {
                                            let s = i.prev,
                                                r = i.next.next;
                                            !n0(s, r) && n1(s, i, i.next, r) && n5(s, r) && n5(r, s) && (e.push(s.i, i.i, r.i), n7(i), n7(i.next), i = t = r), i = i.next
                                        } while (i !== t);
                                        return nX(i)
                                    }(nX(e), i), i, s, r, n, a, 2) : 2 === o && function(e, i, s, r, n, a) {
                                        let o = e;
                                        do {
                                            let e = o.next.next;
                                            for (; e !== o.prev;) {
                                                var h, l;
                                                if (o.i !== e.i && (h = o, l = e, h.next.i !== l.i && h.prev.i !== l.i && ! function(t, e) {
                                                        let i = t;
                                                        do {
                                                            if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && n1(i, i.next, t, e)) return !0;
                                                            i = i.next
                                                        } while (i !== t);
                                                        return !1
                                                    }(h, l) && (n5(h, l) && n5(l, h) && function(t, e) {
                                                        let i = t,
                                                            s = !1,
                                                            r = (t.x + e.x) / 2,
                                                            n = (t.y + e.y) / 2;
                                                        do i.y > n != i.next.y > n && i.next.y !== i.y && r < (i.next.x - i.x) * (n - i.y) / (i.next.y - i.y) + i.x && (s = !s), i = i.next; while (i !== t);
                                                        return s
                                                    }(h, l) && (nK(h.prev, h, l.prev) || nK(h, l.prev, l)) || n0(h, l) && nK(h.prev, h, h.next) > 0 && nK(l.prev, l, l.next) > 0))) {
                                                    let h = n4(o, e);
                                                    o = nX(o, o.next), h = nX(h, h.next), t(o, i, s, r, n, a, 0), t(h, i, s, r, n, a, 0);
                                                    return
                                                }
                                                e = e.next
                                            }
                                            o = o.next
                                        } while (o !== e)
                                    }(e, i, s, r, n, a) : t(nX(e), i, s, r, n, a, 1);
                                    break
                                }
                            }
                        }(h, l, i, s, r, n, 0), l
                    }(t, e, i)
                }
            }
            class at {
                static area(t) {
                    let e = t.length,
                        i = 0;
                    for (let s = e - 1, r = 0; r < e; s = r++) i += t[s].x * t[r].y - t[r].x * t[s].y;
                    return .5 * i
                }
                static isClockWise(t) {
                    return 0 > at.area(t)
                }
                static triangulateShape(t, e) {
                    let i = [],
                        s = [],
                        r = [];
                    ae(t), ai(i, t);
                    let n = t.length;
                    e.forEach(ae);
                    for (let t = 0; t < e.length; t++) s.push(n), n += e[t].length, ai(i, e[t]);
                    let a = n8.triangulate(i, s);
                    for (let t = 0; t < a.length; t += 3) r.push(a.slice(t, t + 3));
                    return r
                }
            }

            function ae(t) {
                let e = t.length;
                e > 2 && t[e - 1].equals(t[0]) && t.pop()
            }

            function ai(t, e) {
                for (let i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y)
            }
            class as extends sH {
                constructor(t = new nZ([new e6(.5, .5), new e6(-.5, .5), new e6(-.5, -.5), new e6(.5, -.5)]), e = {}) {
                    super(), this.type = "ExtrudeGeometry", this.parameters = {
                        shapes: t,
                        options: e
                    }, t = Array.isArray(t) ? t : [t];
                    let i = this,
                        s = [],
                        r = [];
                    for (let n = 0, a = t.length; n < a; n++) ! function(t) {
                        let n, a, o, h, l;
                        let u = [],
                            c = void 0 !== e.curveSegments ? e.curveSegments : 12,
                            p = void 0 !== e.steps ? e.steps : 1,
                            d = void 0 !== e.depth ? e.depth : 1,
                            m = void 0 === e.bevelEnabled || e.bevelEnabled,
                            y = void 0 !== e.bevelThickness ? e.bevelThickness : .2,
                            f = void 0 !== e.bevelSize ? e.bevelSize : y - .1,
                            g = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                            x = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
                            b = e.extrudePath,
                            M = void 0 !== e.UVGenerator ? e.UVGenerator : ar,
                            v, w = !1;
                        if (b) {
                            v = b.getSpacedPoints(p), w = !0, m = !1;
                            let t = !!b.isCatmullRomCurve3 && b.closed;
                            n = b.computeFrenetFrames(p, t), a = new e9, o = new e9, h = new e9
                        }
                        m || (x = 0, y = 0, f = 0, g = 0);
                        let S = t.extractPoints(c),
                            _ = S.shape,
                            z = S.holes;
                        if (!at.isClockWise(_)) {
                            _ = _.reverse();
                            for (let t = 0, e = z.length; t < e; t++) {
                                let e = z[t];
                                at.isClockWise(e) && (z[t] = e.reverse())
                            }
                        }

                        function A(t) {
                            let e = 1e-10 * 1e-10,
                                i = t[0];
                            for (let s = 1; s <= t.length; s++) {
                                let r = s % t.length,
                                    n = t[r],
                                    a = n.x - i.x,
                                    o = n.y - i.y,
                                    h = a * a + o * o,
                                    l = Math.max(Math.abs(n.x), Math.abs(n.y), Math.abs(i.x), Math.abs(i.y));
                                if (h <= e * l * l) {
                                    t.splice(r, 1), s--;
                                    continue
                                }
                                i = n
                            }
                        }
                        A(_), z.forEach(A);
                        let T = z.length,
                            C = _;
                        for (let t = 0; t < T; t++) {
                            let e = z[t];
                            _ = _.concat(e)
                        }

                        function O(t, e, i) {
                            return e || eq("ExtrudeGeometry: vec does not exist"), t.clone().addScaledVector(e, i)
                        }
                        let k = _.length;

                        function B(t, e, i) {
                            let s, r, n;
                            let a = t.x - e.x,
                                o = t.y - e.y,
                                h = i.x - t.x,
                                l = i.y - t.y,
                                u = a * a + o * o;
                            if (Math.abs(a * l - o * h) > Number.EPSILON) {
                                let c = Math.sqrt(u),
                                    p = Math.sqrt(h * h + l * l),
                                    d = e.x - o / c,
                                    m = e.y + a / c,
                                    y = ((i.x - l / p - d) * l - (i.y + h / p - m) * h) / (a * l - o * h),
                                    f = (s = d + a * y - t.x) * s + (r = m + o * y - t.y) * r;
                                if (f <= 2) return new e6(s, r);
                                n = Math.sqrt(f / 2)
                            } else {
                                let t = !1;
                                a > Number.EPSILON ? h > Number.EPSILON && (t = !0) : a < -Number.EPSILON ? h < -Number.EPSILON && (t = !0) : Math.sign(o) === Math.sign(l) && (t = !0), t ? (s = -o, r = a, n = Math.sqrt(u)) : (s = a, r = o, n = Math.sqrt(u / 2))
                            }
                            return new e6(s / n, r / n)
                        }
                        let N = [];
                        for (let t = 0, e = C.length, i = e - 1, s = t + 1; t < e; t++, i++, s++) i === e && (i = 0), s === e && (s = 0), N[t] = B(C[t], C[i], C[s]);
                        let I = [],
                            P, R = N.concat();
                        for (let t = 0; t < T; t++) {
                            let e = z[t];
                            P = [];
                            for (let t = 0, i = e.length, s = i - 1, r = t + 1; t < i; t++, s++, r++) s === i && (s = 0), r === i && (r = 0), P[t] = B(e[t], e[s], e[r]);
                            I.push(P), R = R.concat(P)
                        }
                        if (0 === x) l = at.triangulateShape(C, z);
                        else {
                            let t = [],
                                e = [];
                            for (let i = 0; i < x; i++) {
                                let s = i / x,
                                    r = y * Math.cos(s * Math.PI / 2),
                                    n = f * Math.sin(s * Math.PI / 2) + g;
                                for (let e = 0, i = C.length; e < i; e++) {
                                    let i = O(C[e], N[e], n);
                                    F(i.x, i.y, -r), 0 === s && t.push(i)
                                }
                                for (let t = 0; t < T; t++) {
                                    let i = z[t];
                                    P = I[t];
                                    let a = [];
                                    for (let t = 0, e = i.length; t < e; t++) {
                                        let e = O(i[t], P[t], n);
                                        F(e.x, e.y, -r), 0 === s && a.push(e)
                                    }
                                    0 === s && e.push(a)
                                }
                            }
                            l = at.triangulateShape(t, e)
                        }
                        let V = l.length,
                            L = f + g;
                        for (let t = 0; t < k; t++) {
                            let e = m ? O(_[t], R[t], L) : _[t];
                            w ? (o.copy(n.normals[0]).multiplyScalar(e.x), a.copy(n.binormals[0]).multiplyScalar(e.y), h.copy(v[0]).add(o).add(a), F(h.x, h.y, h.z)) : F(e.x, e.y, 0)
                        }
                        for (let t = 1; t <= p; t++)
                            for (let e = 0; e < k; e++) {
                                let i = m ? O(_[e], R[e], L) : _[e];
                                w ? (o.copy(n.normals[t]).multiplyScalar(i.x), a.copy(n.binormals[t]).multiplyScalar(i.y), h.copy(v[t]).add(o).add(a), F(h.x, h.y, h.z)) : F(i.x, i.y, d / p * t)
                            }
                        for (let t = x - 1; t >= 0; t--) {
                            let e = t / x,
                                i = y * Math.cos(e * Math.PI / 2),
                                s = f * Math.sin(e * Math.PI / 2) + g;
                            for (let t = 0, e = C.length; t < e; t++) {
                                let e = O(C[t], N[t], s);
                                F(e.x, e.y, d + i)
                            }
                            for (let t = 0, e = z.length; t < e; t++) {
                                let e = z[t];
                                P = I[t];
                                for (let t = 0, r = e.length; t < r; t++) {
                                    let r = O(e[t], P[t], s);
                                    w ? F(r.x, r.y + v[p - 1].y, v[p - 1].x + i) : F(r.x, r.y, d + i)
                                }
                            }
                        }

                        function E(t, e) {
                            let r = t.length;
                            for (; --r >= 0;) {
                                let n = r,
                                    a = r - 1;
                                a < 0 && (a = t.length - 1);
                                for (let t = 0, r = p + 2 * x; t < r; t++) {
                                    let r = k * t,
                                        o = k * (t + 1);
                                    ! function(t, e, r, n) {
                                        j(t), j(e), j(n), j(e), j(r), j(n);
                                        let a = s.length / 3,
                                            o = M.generateSideWallUV(i, s, a - 6, a - 3, a - 2, a - 1);
                                        U(o[0]), U(o[1]), U(o[3]), U(o[1]), U(o[2]), U(o[3])
                                    }(e + n + r, e + a + r, e + a + o, e + n + o)
                                }
                            }
                        }

                        function F(t, e, i) {
                            u.push(t), u.push(e), u.push(i)
                        }

                        function D(t, e, r) {
                            j(t), j(e), j(r);
                            let n = s.length / 3,
                                a = M.generateTopUV(i, s, n - 3, n - 2, n - 1);
                            U(a[0]), U(a[1]), U(a[2])
                        }

                        function j(t) {
                            s.push(u[3 * t + 0]), s.push(u[3 * t + 1]), s.push(u[3 * t + 2])
                        }

                        function U(t) {
                            r.push(t.x), r.push(t.y)
                        }(function() {
                            let t = s.length / 3;
                            if (m) {
                                let t = 0 * k;
                                for (let e = 0; e < V; e++) {
                                    let i = l[e];
                                    D(i[2] + t, i[1] + t, i[0] + t)
                                }
                                t = k * (p + 2 * x);
                                for (let e = 0; e < V; e++) {
                                    let i = l[e];
                                    D(i[0] + t, i[1] + t, i[2] + t)
                                }
                            } else {
                                for (let t = 0; t < V; t++) {
                                    let e = l[t];
                                    D(e[2], e[1], e[0])
                                }
                                for (let t = 0; t < V; t++) {
                                    let e = l[t];
                                    D(e[0] + k * p, e[1] + k * p, e[2] + k * p)
                                }
                            }
                            i.addGroup(t, s.length / 3 - t, 0)
                        })(),
                        function() {
                            let t = s.length / 3,
                                e = 0;
                            E(C, 0), e += C.length;
                            for (let t = 0, i = z.length; t < i; t++) {
                                let i = z[t];
                                E(i, e), e += i.length
                            }
                            i.addGroup(t, s.length / 3 - t, 1)
                        }()
                    }(t[n]);
                    this.setAttribute("position", new sU(s, 3)), this.setAttribute("uv", new sU(r, 2)), this.computeVertexNormals()
                }
                copy(t) {
                    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                }
                toJSON() {
                    let t = super.toJSON();
                    return function(t, e, i) {
                        if (i.shapes = [], Array.isArray(t))
                            for (let e = 0, s = t.length; e < s; e++) {
                                let s = t[e];
                                i.shapes.push(s.uuid)
                            } else i.shapes.push(t.uuid);
                        return i.options = Object.assign({}, e), void 0 !== e.extrudePath && (i.options.extrudePath = e.extrudePath.toJSON()), i
                    }(this.parameters.shapes, this.parameters.options, t)
                }
                static fromJSON(t, e) {
                    let i = [];
                    for (let s = 0, r = t.shapes.length; s < r; s++) {
                        let r = e[t.shapes[s]];
                        i.push(r)
                    }
                    let s = t.options.extrudePath;
                    return void 0 !== s && (t.options.extrudePath = new nW[s.type]().fromJSON(s)), new as(i, t.options)
                }
            }
            let ar = {
                generateTopUV: function(t, e, i, s, r) {
                    let n = e[3 * i],
                        a = e[3 * i + 1],
                        o = e[3 * s],
                        h = e[3 * s + 1],
                        l = e[3 * r],
                        u = e[3 * r + 1];
                    return [new e6(n, a), new e6(o, h), new e6(l, u)]
                },
                generateSideWallUV: function(t, e, i, s, r, n) {
                    let a = e[3 * i],
                        o = e[3 * i + 1],
                        h = e[3 * i + 2],
                        l = e[3 * s],
                        u = e[3 * s + 1],
                        c = e[3 * s + 2],
                        p = e[3 * r],
                        d = e[3 * r + 1],
                        m = e[3 * r + 2],
                        y = e[3 * n],
                        f = e[3 * n + 1],
                        g = e[3 * n + 2];
                    return Math.abs(o - u) < Math.abs(a - l) ? [new e6(a, 1 - h), new e6(l, 1 - c), new e6(p, 1 - m), new e6(y, 1 - g)] : [new e6(o, 1 - h), new e6(u, 1 - c), new e6(d, 1 - m), new e6(f, 1 - g)]
                }
            };
            class an extends nw {
                constructor(t = 1, e = 0) {
                    let i = (1 + Math.sqrt(5)) / 2;
                    super([-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronGeometry", this.parameters = {
                        radius: t,
                        detail: e
                    }
                }
                static fromJSON(t) {
                    return new an(t.radius, t.detail)
                }
            }
            class aa extends sH {
                constructor(t = [new e6(0, -.5), new e6(.5, 0), new e6(0, .5)], e = 12, i = 0, s = 2 * Math.PI) {
                    super(), this.type = "LatheGeometry", this.parameters = {
                        points: t,
                        segments: e,
                        phiStart: i,
                        phiLength: s
                    }, e = Math.floor(e), s = e0(s, 0, 2 * Math.PI);
                    let r = [],
                        n = [],
                        a = [],
                        o = [],
                        h = [],
                        l = 1 / e,
                        u = new e9,
                        c = new e6,
                        p = new e9,
                        d = new e9,
                        m = new e9,
                        y = 0,
                        f = 0;
                    for (let e = 0; e <= t.length - 1; e++) switch (e) {
                        case 0:
                            y = t[e + 1].x - t[e].x, f = t[e + 1].y - t[e].y, p.x = 1 * f, p.y = -y, p.z = 0 * f, m.copy(p), p.normalize(), o.push(p.x, p.y, p.z);
                            break;
                        case t.length - 1:
                            o.push(m.x, m.y, m.z);
                            break;
                        default:
                            y = t[e + 1].x - t[e].x, f = t[e + 1].y - t[e].y, p.x = 1 * f, p.y = -y, p.z = 0 * f, d.copy(p), p.x += m.x, p.y += m.y, p.z += m.z, p.normalize(), o.push(p.x, p.y, p.z), m.copy(d)
                    }
                    for (let r = 0; r <= e; r++) {
                        let p = i + r * l * s,
                            d = Math.sin(p),
                            m = Math.cos(p);
                        for (let i = 0; i <= t.length - 1; i++) {
                            u.x = t[i].x * d, u.y = t[i].y, u.z = t[i].x * m, n.push(u.x, u.y, u.z), c.x = r / e, c.y = i / (t.length - 1), a.push(c.x, c.y);
                            let s = o[3 * i + 0] * d,
                                l = o[3 * i + 1],
                                p = o[3 * i + 0] * m;
                            h.push(s, l, p)
                        }
                    }
                    for (let i = 0; i < e; i++)
                        for (let e = 0; e < t.length - 1; e++) {
                            let s = e + i * t.length,
                                n = s + t.length,
                                a = s + t.length + 1,
                                o = s + 1;
                            r.push(s, n, o), r.push(a, o, n)
                        }
                    this.setIndex(r), this.setAttribute("position", new sU(n, 3)), this.setAttribute("uv", new sU(a, 2)), this.setAttribute("normal", new sU(h, 3))
                }
                copy(t) {
                    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                }
                static fromJSON(t) {
                    return new aa(t.points, t.segments, t.phiStart, t.phiLength)
                }
            }
            class ao extends nw {
                constructor(t = 1, e = 0) {
                    super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronGeometry", this.parameters = {
                        radius: t,
                        detail: e
                    }
                }
                static fromJSON(t) {
                    return new ao(t.radius, t.detail)
                }
            }
            class ah extends sH {
                constructor(t = 1, e = 1, i = 1, s = 1) {
                    super(), this.type = "PlaneGeometry", this.parameters = {
                        width: t,
                        height: e,
                        widthSegments: i,
                        heightSegments: s
                    };
                    let r = t / 2,
                        n = e / 2,
                        a = Math.floor(i),
                        o = Math.floor(s),
                        h = a + 1,
                        l = o + 1,
                        u = t / a,
                        c = e / o,
                        p = [],
                        d = [],
                        m = [],
                        y = [];
                    for (let t = 0; t < l; t++) {
                        let e = t * c - n;
                        for (let i = 0; i < h; i++) {
                            let s = i * u - r;
                            d.push(s, -e, 0), m.push(0, 0, 1), y.push(i / a), y.push(1 - t / o)
                        }
                    }
                    for (let t = 0; t < o; t++)
                        for (let e = 0; e < a; e++) {
                            let i = e + h * t,
                                s = e + h * (t + 1),
                                r = e + 1 + h * (t + 1),
                                n = e + 1 + h * t;
                            p.push(i, s, n), p.push(s, r, n)
                        }
                    this.setIndex(p), this.setAttribute("position", new sU(d, 3)), this.setAttribute("normal", new sU(m, 3)), this.setAttribute("uv", new sU(y, 2))
                }
                copy(t) {
                    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                }
                static fromJSON(t) {
                    return new ah(t.width, t.height, t.widthSegments, t.heightSegments)
                }
            }
            class al extends sH {
                constructor(t = .5, e = 1, i = 32, s = 1, r = 0, n = 2 * Math.PI) {
                    super(), this.type = "RingGeometry", this.parameters = {
                        innerRadius: t,
                        outerRadius: e,
                        thetaSegments: i,
                        phiSegments: s,
                        thetaStart: r,
                        thetaLength: n
                    }, i = Math.max(3, i);
                    let a = [],
                        o = [],
                        h = [],
                        l = [],
                        u = t,
                        c = (e - t) / (s = Math.max(1, s)),
                        p = new e9,
                        d = new e6;
                    for (let t = 0; t <= s; t++) {
                        for (let t = 0; t <= i; t++) {
                            let s = r + t / i * n;
                            p.x = u * Math.cos(s), p.y = u * Math.sin(s), o.push(p.x, p.y, p.z), h.push(0, 0, 1), d.x = (p.x / e + 1) / 2, d.y = (p.y / e + 1) / 2, l.push(d.x, d.y)
                        }
                        u += c
                    }
                    for (let t = 0; t < s; t++) {
                        let e = t * (i + 1);
                        for (let t = 0; t < i; t++) {
                            let s = t + e,
                                r = s + i + 1,
                                n = s + i + 2,
                                o = s + 1;
                            a.push(s, r, o), a.push(r, n, o)
                        }
                    }
                    this.setIndex(a), this.setAttribute("position", new sU(o, 3)), this.setAttribute("normal", new sU(h, 3)), this.setAttribute("uv", new sU(l, 2))
                }
                copy(t) {
                    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                }
                static fromJSON(t) {
                    return new al(t.innerRadius, t.outerRadius, t.thetaSegments, t.phiSegments, t.thetaStart, t.thetaLength)
                }
            }
            class au extends sH {
                constructor(t = new nZ([new e6(0, .5), new e6(-.5, -.5), new e6(.5, -.5)]), e = 12) {
                    super(), this.type = "ShapeGeometry", this.parameters = {
                        shapes: t,
                        curveSegments: e
                    };
                    let i = [],
                        s = [],
                        r = [],
                        n = [],
                        a = 0,
                        o = 0;
                    if (!1 === Array.isArray(t)) h(t);
                    else
                        for (let e = 0; e < t.length; e++) h(t[e]), this.addGroup(a, o, e), a += o, o = 0;

                    function h(t) {
                        let a = s.length / 3,
                            h = t.extractPoints(e),
                            l = h.shape,
                            u = h.holes;
                        !1 === at.isClockWise(l) && (l = l.reverse());
                        for (let t = 0, e = u.length; t < e; t++) {
                            let e = u[t];
                            !0 === at.isClockWise(e) && (u[t] = e.reverse())
                        }
                        let c = at.triangulateShape(l, u);
                        for (let t = 0, e = u.length; t < e; t++) {
                            let e = u[t];
                            l = l.concat(e)
                        }
                        for (let t = 0, e = l.length; t < e; t++) {
                            let e = l[t];
                            s.push(e.x, e.y, 0), r.push(0, 0, 1), n.push(e.x, e.y)
                        }
                        for (let t = 0, e = c.length; t < e; t++) {
                            let e = c[t],
                                s = e[0] + a,
                                r = e[1] + a,
                                n = e[2] + a;
                            i.push(s, r, n), o += 3
                        }
                    }
                    this.setIndex(i), this.setAttribute("position", new sU(s, 3)), this.setAttribute("normal", new sU(r, 3)), this.setAttribute("uv", new sU(n, 2))
                }
                copy(t) {
                    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                }
                toJSON() {
                    let t = super.toJSON();
                    return function(t, e) {
                        if (e.shapes = [], Array.isArray(t))
                            for (let i = 0, s = t.length; i < s; i++) {
                                let s = t[i];
                                e.shapes.push(s.uuid)
                            } else e.shapes.push(t.uuid);
                        return e
                    }(this.parameters.shapes, t)
                }
                static fromJSON(t, e) {
                    let i = [];
                    for (let s = 0, r = t.shapes.length; s < r; s++) {
                        let r = e[t.shapes[s]];
                        i.push(r)
                    }
                    return new au(i, t.curveSegments)
                }
            }
            class ac extends sH {
                constructor(t = 1, e = 32, i = 16, s = 0, r = 2 * Math.PI, n = 0, a = Math.PI) {
                    super(), this.type = "SphereGeometry", this.parameters = {
                        radius: t,
                        widthSegments: e,
                        heightSegments: i,
                        phiStart: s,
                        phiLength: r,
                        thetaStart: n,
                        thetaLength: a
                    }, e = Math.max(3, Math.floor(e)), i = Math.max(2, Math.floor(i));
                    let o = Math.min(n + a, Math.PI),
                        h = 0,
                        l = [],
                        u = new e9,
                        c = new e9,
                        p = [],
                        d = [],
                        m = [],
                        y = [];
                    for (let p = 0; p <= i; p++) {
                        let f = [],
                            g = p / i,
                            x = 0;
                        0 === p && 0 === n ? x = .5 / e : p === i && o === Math.PI && (x = -.5 / e);
                        for (let i = 0; i <= e; i++) {
                            let o = i / e;
                            u.x = -t * Math.cos(s + o * r) * Math.sin(n + g * a), u.y = t * Math.cos(n + g * a), u.z = t * Math.sin(s + o * r) * Math.sin(n + g * a), d.push(u.x, u.y, u.z), c.copy(u).normalize(), m.push(c.x, c.y, c.z), y.push(o + x, 1 - g), f.push(h++)
                        }
                        l.push(f)
                    }
                    for (let t = 0; t < i; t++)
                        for (let s = 0; s < e; s++) {
                            let e = l[t][s + 1],
                                r = l[t][s],
                                a = l[t + 1][s],
                                h = l[t + 1][s + 1];
                            (0 !== t || n > 0) && p.push(e, r, h), (t !== i - 1 || o < Math.PI) && p.push(r, a, h)
                        }
                    this.setIndex(p), this.setAttribute("position", new sU(d, 3)), this.setAttribute("normal", new sU(m, 3)), this.setAttribute("uv", new sU(y, 2))
                }
                copy(t) {
                    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                }
                static fromJSON(t) {
                    return new ac(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength)
                }
            }
            class ap extends nw {
                constructor(t = 1, e = 0) {
                    super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronGeometry", this.parameters = {
                        radius: t,
                        detail: e
                    }
                }
                static fromJSON(t) {
                    return new ap(t.radius, t.detail)
                }
            }
            class ad extends sH {
                constructor(t = 1, e = .4, i = 12, s = 48, r = 2 * Math.PI) {
                    super(), this.type = "TorusGeometry", this.parameters = {
                        radius: t,
                        tube: e,
                        radialSegments: i,
                        tubularSegments: s,
                        arc: r
                    }, i = Math.floor(i), s = Math.floor(s);
                    let n = [],
                        a = [],
                        o = [],
                        h = [],
                        l = new e9,
                        u = new e9,
                        c = new e9;
                    for (let n = 0; n <= i; n++)
                        for (let p = 0; p <= s; p++) {
                            let d = p / s * r,
                                m = n / i * Math.PI * 2;
                            u.x = (t + e * Math.cos(m)) * Math.cos(d), u.y = (t + e * Math.cos(m)) * Math.sin(d), u.z = e * Math.sin(m), a.push(u.x, u.y, u.z), l.x = t * Math.cos(d), l.y = t * Math.sin(d), c.subVectors(u, l).normalize(), o.push(c.x, c.y, c.z), h.push(p / s), h.push(n / i)
                        }
                    for (let t = 1; t <= i; t++)
                        for (let e = 1; e <= s; e++) {
                            let i = (s + 1) * t + e - 1,
                                r = (s + 1) * (t - 1) + e - 1,
                                a = (s + 1) * (t - 1) + e,
                                o = (s + 1) * t + e;
                            n.push(i, r, o), n.push(r, a, o)
                        }
                    this.setIndex(n), this.setAttribute("position", new sU(a, 3)), this.setAttribute("normal", new sU(o, 3)), this.setAttribute("uv", new sU(h, 2))
                }
                copy(t) {
                    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                }
                static fromJSON(t) {
                    return new ad(t.radius, t.tube, t.radialSegments, t.tubularSegments, t.arc)
                }
            }
            class am extends sH {
                constructor(t = 1, e = .4, i = 64, s = 8, r = 2, n = 3) {
                    super(), this.type = "TorusKnotGeometry", this.parameters = {
                        radius: t,
                        tube: e,
                        tubularSegments: i,
                        radialSegments: s,
                        p: r,
                        q: n
                    }, i = Math.floor(i), s = Math.floor(s);
                    let a = [],
                        o = [],
                        h = [],
                        l = [],
                        u = new e9,
                        c = new e9,
                        p = new e9,
                        d = new e9,
                        m = new e9,
                        y = new e9,
                        f = new e9;
                    for (let a = 0; a <= i; ++a) {
                        let x = a / i * r * Math.PI * 2;
                        g(x, r, n, t, p), g(x + .01, r, n, t, d), y.subVectors(d, p), f.addVectors(d, p), m.crossVectors(y, f), f.crossVectors(m, y), m.normalize(), f.normalize();
                        for (let t = 0; t <= s; ++t) {
                            let r = t / s * Math.PI * 2,
                                n = -e * Math.cos(r),
                                d = e * Math.sin(r);
                            u.x = p.x + (n * f.x + d * m.x), u.y = p.y + (n * f.y + d * m.y), u.z = p.z + (n * f.z + d * m.z), o.push(u.x, u.y, u.z), c.subVectors(u, p).normalize(), h.push(c.x, c.y, c.z), l.push(a / i), l.push(t / s)
                        }
                    }
                    for (let t = 1; t <= i; t++)
                        for (let e = 1; e <= s; e++) {
                            let i = (s + 1) * (t - 1) + (e - 1),
                                r = (s + 1) * t + (e - 1),
                                n = (s + 1) * t + e,
                                o = (s + 1) * (t - 1) + e;
                            a.push(i, r, o), a.push(r, n, o)
                        }

                    function g(t, e, i, s, r) {
                        let n = i / e * t,
                            a = Math.cos(n);
                        r.x = s * (2 + a) * .5 * Math.cos(t), r.y = s * (2 + a) * Math.sin(t) * .5, r.z = s * Math.sin(n) * .5
                    }
                    this.setIndex(a), this.setAttribute("position", new sU(o, 3)), this.setAttribute("normal", new sU(h, 3)), this.setAttribute("uv", new sU(l, 2))
                }
                copy(t) {
                    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                }
                static fromJSON(t) {
                    return new am(t.radius, t.tube, t.tubularSegments, t.radialSegments, t.p, t.q)
                }
            }
            class ay extends sH {
                constructor(t = new nj(new e9(-1, -1, 0), new e9(-1, 1, 0), new e9(1, 1, 0)), e = 64, i = 1, s = 8, r = !1) {
                    super(), this.type = "TubeGeometry", this.parameters = {
                        path: t,
                        tubularSegments: e,
                        radius: i,
                        radialSegments: s,
                        closed: r
                    };
                    let n = t.computeFrenetFrames(e, r);
                    this.tangents = n.tangents, this.normals = n.normals, this.binormals = n.binormals;
                    let a = new e9,
                        o = new e9,
                        h = new e6,
                        l = new e9,
                        u = [],
                        c = [],
                        p = [],
                        d = [];

                    function m(r) {
                        l = t.getPointAt(r / e, l);
                        let h = n.normals[r],
                            p = n.binormals[r];
                        for (let t = 0; t <= s; t++) {
                            let e = t / s * Math.PI * 2,
                                r = Math.sin(e),
                                n = -Math.cos(e);
                            o.x = n * h.x + r * p.x, o.y = n * h.y + r * p.y, o.z = n * h.z + r * p.z, o.normalize(), c.push(o.x, o.y, o.z), a.x = l.x + i * o.x, a.y = l.y + i * o.y, a.z = l.z + i * o.z, u.push(a.x, a.y, a.z)
                        }
                    }(function() {
                        for (let t = 0; t < e; t++) m(t);
                        m(!1 === r ? e : 0),
                            function() {
                                for (let t = 0; t <= e; t++)
                                    for (let i = 0; i <= s; i++) h.x = t / e, h.y = i / s, p.push(h.x, h.y)
                            }(),
                            function() {
                                for (let t = 1; t <= e; t++)
                                    for (let e = 1; e <= s; e++) {
                                        let i = (s + 1) * (t - 1) + (e - 1),
                                            r = (s + 1) * t + (e - 1),
                                            n = (s + 1) * t + e,
                                            a = (s + 1) * (t - 1) + e;
                                        d.push(i, r, a), d.push(r, n, a)
                                    }
                            }()
                    })(), this.setIndex(d), this.setAttribute("position", new sU(u, 3)), this.setAttribute("normal", new sU(c, 3)), this.setAttribute("uv", new sU(p, 2))
                }
                copy(t) {
                    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
                }
                toJSON() {
                    let t = super.toJSON();
                    return t.path = this.parameters.path.toJSON(), t
                }
                static fromJSON(t) {
                    return new ay(new nW[t.path.type]().fromJSON(t.path), t.tubularSegments, t.radius, t.radialSegments, t.closed)
                }
            }
            class af extends rn {
                constructor(t) {
                    super(t), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial"
                }
            }
            class ag extends sP {
                constructor(t) {
                    super(), this.isMeshStandardMaterial = !0, this.type = "MeshStandardMaterial", this.defines = {
                        STANDARD: ""
                    }, this.color = new sB(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new sB(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ew, this.normalScale = new e6(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new i4, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.defines = {
                        STANDARD: ""
                    }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.envMapIntensity = t.envMapIntensity, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this
                }
            }
            class ax extends ag {
                constructor(t) {
                    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new e6(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                        get: function() {
                            return e0(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                        },
                        set: function(t) {
                            this.ior = (1 + .4 * t) / (1 - .4 * t)
                        }
                    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new sB(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new sB(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new sB(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(t)
                }
                get anisotropy() {
                    return this._anisotropy
                }
                set anisotropy(t) {
                    this._anisotropy > 0 != t > 0 && this.version++, this._anisotropy = t
                }
                get clearcoat() {
                    return this._clearcoat
                }
                set clearcoat(t) {
                    this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t
                }
                get iridescence() {
                    return this._iridescence
                }
                set iridescence(t) {
                    this._iridescence > 0 != t > 0 && this.version++, this._iridescence = t
                }
                get dispersion() {
                    return this._dispersion
                }
                set dispersion(t) {
                    this._dispersion > 0 != t > 0 && this.version++, this._dispersion = t
                }
                get sheen() {
                    return this._sheen
                }
                set sheen(t) {
                    this._sheen > 0 != t > 0 && this.version++, this._sheen = t
                }
                get transmission() {
                    return this._transmission
                }
                set transmission(t) {
                    this._transmission > 0 != t > 0 && this.version++, this._transmission = t
                }
                copy(t) {
                    return super.copy(t), this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    }, this.anisotropy = t.anisotropy, this.anisotropyRotation = t.anisotropyRotation, this.anisotropyMap = t.anisotropyMap, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.dispersion = t.dispersion, this.ior = t.ior, this.iridescence = t.iridescence, this.iridescenceMap = t.iridescenceMap, this.iridescenceIOR = t.iridescenceIOR, this.iridescenceThicknessRange = [...t.iridescenceThicknessRange], this.iridescenceThicknessMap = t.iridescenceThicknessMap, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this
                }
            }
            class ab extends sP {
                constructor(t) {
                    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new sB(16777215), this.specular = new sB(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new sB(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ew, this.normalScale = new e6(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new i4, this.combine = H, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this
                }
            }
            class aM extends sP {
                constructor(t) {
                    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new sB(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new sB(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ew, this.normalScale = new e6(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new i4, this.combine = H, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this
                }
            }
            class av extends sP {
                constructor(t) {
                    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
                }
            }
            class aw extends sP {
                constructor(t) {
                    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
                }
            }

            function aS(t, e) {
                return t && t.constructor !== e ? "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t) : t
            }

            function a_(t, e, i) {
                let s = t.length,
                    r = new t.constructor(s);
                for (let n = 0, a = 0; a !== s; ++n) {
                    let s = i[n] * e;
                    for (let i = 0; i !== e; ++i) r[a++] = t[s + i]
                }
                return r
            }

            function az(t, e, i, s) {
                let r = 1,
                    n = t[0];
                for (; void 0 !== n && void 0 === n[s];) n = t[r++];
                if (void 0 === n) return;
                let a = n[s];
                if (void 0 !== a) {
                    if (Array.isArray(a))
                        do void 0 !== (a = n[s]) && (e.push(n.time), i.push(...a)), n = t[r++]; while (void 0 !== n);
                    else if (void 0 !== a.toArray)
                        do void 0 !== (a = n[s]) && (e.push(n.time), a.toArray(i, i.length)), n = t[r++]; while (void 0 !== n);
                    else
                        do void 0 !== (a = n[s]) && (e.push(n.time), i.push(a)), n = t[r++]; while (void 0 !== n)
                }
            }
            class aA {
                constructor(t, e, i, s) {
                    this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== s ? s : new e.constructor(i), this.sampleValues = e, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {}
                }
                evaluate(t) {
                    let e = this.parameterPositions,
                        i = this._cachedIndex,
                        s = e[i],
                        r = e[i - 1];
                    t: {
                        e: {
                            let n;i: {
                                s: if (!(t < s)) {
                                    for (let n = i + 2;;) {
                                        if (void 0 === s) {
                                            if (t < r) break s;
                                            return i = e.length, this._cachedIndex = i, this.copySampleValue_(i - 1)
                                        }
                                        if (i === n) break;
                                        if (r = s, t < (s = e[++i])) break e
                                    }
                                    n = e.length;
                                    break i
                                }if (!(t >= r)) {
                                    let a = e[1];
                                    t < a && (i = 2, r = a);
                                    for (let n = i - 2;;) {
                                        if (void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0);
                                        if (i === n) break;
                                        if (s = r, t >= (r = e[--i - 1])) break e
                                    }
                                    n = i, i = 0;
                                    break i
                                }
                                break t
                            }
                            for (; i < n;) {
                                let s = i + n >>> 1;
                                t < e[s] ? n = s : i = s + 1
                            }
                            if (s = e[i], void 0 === (r = e[i - 1])) return this._cachedIndex = 0, this.copySampleValue_(0);
                            if (void 0 === s) return i = e.length, this._cachedIndex = i, this.copySampleValue_(i - 1)
                        }
                        this._cachedIndex = i,
                        this.intervalChanged_(i, r, s)
                    }
                    return this.interpolate_(i, r, t, s)
                }
                getSettings_() {
                    return this.settings || this.DefaultSettings_
                }
                copySampleValue_(t) {
                    let e = this.resultBuffer,
                        i = this.sampleValues,
                        s = this.valueSize,
                        r = t * s;
                    for (let t = 0; t !== s; ++t) e[t] = i[r + t];
                    return e
                }
                interpolate_() {
                    throw Error("call to abstract method")
                }
                intervalChanged_() {}
            }
            class aT extends aA {
                constructor(t, e, i, s) {
                    super(t, e, i, s), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                        endingStart: 2400,
                        endingEnd: 2400
                    }
                }
                intervalChanged_(t, e, i) {
                    let s = this.parameterPositions,
                        r = t - 2,
                        n = t + 1,
                        a = s[r],
                        o = s[n];
                    if (void 0 === a) switch (this.getSettings_().endingStart) {
                        case 2401:
                            r = t, a = 2 * e - i;
                            break;
                        case 2402:
                            r = s.length - 2, a = e + s[r] - s[r + 1];
                            break;
                        default:
                            r = t, a = i
                    }
                    if (void 0 === o) switch (this.getSettings_().endingEnd) {
                        case 2401:
                            n = t, o = 2 * i - e;
                            break;
                        case 2402:
                            n = 1, o = i + s[1] - s[0];
                            break;
                        default:
                            n = t - 1, o = e
                    }
                    let h = (i - e) * .5,
                        l = this.valueSize;
                    this._weightPrev = h / (e - a), this._weightNext = h / (o - i), this._offsetPrev = r * l, this._offsetNext = n * l
                }
                interpolate_(t, e, i, s) {
                    let r = this.resultBuffer,
                        n = this.sampleValues,
                        a = this.valueSize,
                        o = t * a,
                        h = o - a,
                        l = this._offsetPrev,
                        u = this._offsetNext,
                        c = this._weightPrev,
                        p = this._weightNext,
                        d = (i - e) / (s - e),
                        m = d * d,
                        y = m * d,
                        f = -c * y + 2 * c * m - c * d,
                        g = (1 + c) * y + (-1.5 - 2 * c) * m + (-.5 + c) * d + 1,
                        x = (-1 - p) * y + (1.5 + p) * m + .5 * d,
                        b = p * y - p * m;
                    for (let t = 0; t !== a; ++t) r[t] = f * n[l + t] + g * n[h + t] + x * n[o + t] + b * n[u + t];
                    return r
                }
            }
            class aC extends aA {
                constructor(t, e, i, s) {
                    super(t, e, i, s)
                }
                interpolate_(t, e, i, s) {
                    let r = this.resultBuffer,
                        n = this.sampleValues,
                        a = this.valueSize,
                        o = t * a,
                        h = o - a,
                        l = (i - e) / (s - e),
                        u = 1 - l;
                    for (let t = 0; t !== a; ++t) r[t] = n[h + t] * u + n[o + t] * l;
                    return r
                }
            }
            class aO extends aA {
                constructor(t, e, i, s) {
                    super(t, e, i, s)
                }
                interpolate_(t) {
                    return this.copySampleValue_(t - 1)
                }
            }
            class ak {
                constructor(t, e, i, s) {
                    if (void 0 === t) throw Error("THREE.KeyframeTrack: track name is undefined");
                    if (void 0 === e || 0 === e.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                    this.name = t, this.times = aS(e, this.TimeBufferType), this.values = aS(i, this.ValueBufferType), this.setInterpolation(s || this.DefaultInterpolation)
                }
                static toJSON(t) {
                    let e;
                    let i = t.constructor;
                    if (i.toJSON !== this.toJSON) e = i.toJSON(t);
                    else {
                        e = {
                            name: t.name,
                            times: aS(t.times, Array),
                            values: aS(t.values, Array)
                        };
                        let i = t.getInterpolation();
                        i !== t.DefaultInterpolation && (e.interpolation = i)
                    }
                    return e.type = t.ValueTypeName, e
                }
                InterpolantFactoryMethodDiscrete(t) {
                    return new aO(this.times, this.values, this.getValueSize(), t)
                }
                InterpolantFactoryMethodLinear(t) {
                    return new aC(this.times, this.values, this.getValueSize(), t)
                }
                InterpolantFactoryMethodSmooth(t) {
                    return new aT(this.times, this.values, this.getValueSize(), t)
                }
                setInterpolation(t) {
                    let e;
                    switch (t) {
                        case eg:
                            e = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case ex:
                            e = this.InterpolantFactoryMethodLinear;
                            break;
                        case 2302:
                            e = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 === e) {
                        let e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (void 0 === this.createInterpolant) {
                            if (t !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                            else throw Error(e)
                        }
                        return eJ("KeyframeTrack:", e), this
                    }
                    return this.createInterpolant = e, this
                }
                getInterpolation() {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return eg;
                        case this.InterpolantFactoryMethodLinear:
                            return ex;
                        case this.InterpolantFactoryMethodSmooth:
                            return 2302
                    }
                }
                getValueSize() {
                    return this.values.length / this.times.length
                }
                shift(t) {
                    if (0 !== t) {
                        let e = this.times;
                        for (let i = 0, s = e.length; i !== s; ++i) e[i] += t
                    }
                    return this
                }
                scale(t) {
                    if (1 !== t) {
                        let e = this.times;
                        for (let i = 0, s = e.length; i !== s; ++i) e[i] *= t
                    }
                    return this
                }
                trim(t, e) {
                    let i = this.times,
                        s = i.length,
                        r = 0,
                        n = s - 1;
                    for (; r !== s && i[r] < t;) ++r;
                    for (; - 1 !== n && i[n] > e;) --n;
                    if (++n, 0 !== r || n !== s) {
                        r >= n && (r = (n = Math.max(n, 1)) - 1);
                        let t = this.getValueSize();
                        this.times = i.slice(r, n), this.values = this.values.slice(r * t, n * t)
                    }
                    return this
                }
                validate() {
                    let t = !0,
                        e = this.getValueSize();
                    e - Math.floor(e) != 0 && (eq("KeyframeTrack: Invalid value size in track.", this), t = !1);
                    let i = this.times,
                        s = this.values,
                        r = i.length;
                    0 === r && (eq("KeyframeTrack: Track is empty.", this), t = !1);
                    let n = null;
                    for (let e = 0; e !== r; e++) {
                        let s = i[e];
                        if ("number" == typeof s && isNaN(s)) {
                            eq("KeyframeTrack: Time is not a valid number.", this, e, s), t = !1;
                            break
                        }
                        if (null !== n && n > s) {
                            eq("KeyframeTrack: Out of order keys.", this, e, s, n), t = !1;
                            break
                        }
                        n = s
                    }
                    if (void 0 !== s && ArrayBuffer.isView(s) && !(s instanceof DataView))
                        for (let e = 0, i = s.length; e !== i; ++e) {
                            let i = s[e];
                            if (isNaN(i)) {
                                eq("KeyframeTrack: Value is not a valid number.", this, e, i), t = !1;
                                break
                            }
                        }
                    return t
                }
                optimize() {
                    let t = this.times.slice(),
                        e = this.values.slice(),
                        i = this.getValueSize(),
                        s = 2302 === this.getInterpolation(),
                        r = t.length - 1,
                        n = 1;
                    for (let a = 1; a < r; ++a) {
                        let r = !1,
                            o = t[a];
                        if (o !== t[a + 1] && (1 !== a || o !== t[0])) {
                            if (s) r = !0;
                            else {
                                let t = a * i,
                                    s = t - i,
                                    n = t + i;
                                for (let a = 0; a !== i; ++a) {
                                    let i = e[t + a];
                                    if (i !== e[s + a] || i !== e[n + a]) {
                                        r = !0;
                                        break
                                    }
                                }
                            }
                        }
                        if (r) {
                            if (a !== n) {
                                t[n] = t[a];
                                let s = a * i,
                                    r = n * i;
                                for (let t = 0; t !== i; ++t) e[r + t] = e[s + t]
                            }++n
                        }
                    }
                    if (r > 0) {
                        t[n] = t[r];
                        for (let t = r * i, s = n * i, a = 0; a !== i; ++a) e[s + a] = e[t + a];
                        ++n
                    }
                    return n !== t.length ? (this.times = t.slice(0, n), this.values = e.slice(0, n * i)) : (this.times = t, this.values = e), this
                }
                clone() {
                    let t = this.times.slice(),
                        e = this.values.slice(),
                        i = new this.constructor(this.name, t, e);
                    return i.createInterpolant = this.createInterpolant, i
                }
            }
            ak.prototype.ValueTypeName = "", ak.prototype.TimeBufferType = Float32Array, ak.prototype.ValueBufferType = Float32Array, ak.prototype.DefaultInterpolation = ex;
            class aB extends ak {
                constructor(t, e, i) {
                    super(t, e, i)
                }
            }
            aB.prototype.ValueTypeName = "bool", aB.prototype.ValueBufferType = Array, aB.prototype.DefaultInterpolation = eg, aB.prototype.InterpolantFactoryMethodLinear = void 0, aB.prototype.InterpolantFactoryMethodSmooth = void 0;
            class aN extends ak {
                constructor(t, e, i, s) {
                    super(t, e, i, s)
                }
            }
            aN.prototype.ValueTypeName = "color";
            class aI extends ak {
                constructor(t, e, i, s) {
                    super(t, e, i, s)
                }
            }
            aI.prototype.ValueTypeName = "number";
            class aP extends aA {
                constructor(t, e, i, s) {
                    super(t, e, i, s)
                }
                interpolate_(t, e, i, s) {
                    let r = this.resultBuffer,
                        n = this.sampleValues,
                        a = this.valueSize,
                        o = (i - e) / (s - e),
                        h = t * a;
                    for (let t = h + a; h !== t; h += 4) e7.slerpFlat(r, 0, n, h - a, n, h, o);
                    return r
                }
            }
            class aR extends ak {
                constructor(t, e, i, s) {
                    super(t, e, i, s)
                }
                InterpolantFactoryMethodLinear(t) {
                    return new aP(this.times, this.values, this.getValueSize(), t)
                }
            }
            aR.prototype.ValueTypeName = "quaternion", aR.prototype.InterpolantFactoryMethodSmooth = void 0;
            class aV extends ak {
                constructor(t, e, i) {
                    super(t, e, i)
                }
            }
            aV.prototype.ValueTypeName = "string", aV.prototype.ValueBufferType = Array, aV.prototype.DefaultInterpolation = eg, aV.prototype.InterpolantFactoryMethodLinear = void 0, aV.prototype.InterpolantFactoryMethodSmooth = void 0;
            class aL extends ak {
                constructor(t, e, i, s) {
                    super(t, e, i, s)
                }
            }
            aL.prototype.ValueTypeName = "vector";
            class aE {
                constructor(t = "", e = -1, i = [], s = 2500) {
                    this.name = t, this.tracks = i, this.duration = e, this.blendMode = s, this.uuid = eK(), this.userData = {}, this.duration < 0 && this.resetDuration()
                }
                static parse(t) {
                    let e = [],
                        i = t.tracks,
                        s = 1 / (t.fps || 1);
                    for (let t = 0, r = i.length; t !== r; ++t) e.push((function(t) {
                        if (void 0 === t.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
                        let e = function(t) {
                            switch (t.toLowerCase()) {
                                case "scalar":
                                case "double":
                                case "float":
                                case "number":
                                case "integer":
                                    return aI;
                                case "vector":
                                case "vector2":
                                case "vector3":
                                case "vector4":
                                    return aL;
                                case "color":
                                    return aN;
                                case "quaternion":
                                    return aR;
                                case "bool":
                                case "boolean":
                                    return aB;
                                case "string":
                                    return aV
                            }
                            throw Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
                        }(t.type);
                        if (void 0 === t.times) {
                            let e = [],
                                i = [];
                            az(t.keys, e, i, "value"), t.times = e, t.values = i
                        }
                        return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
                    })(i[t]).scale(s));
                    let r = new this(t.name, t.duration, e, t.blendMode);
                    return r.uuid = t.uuid, r.userData = JSON.parse(t.userData || "{}"), r
                }
                static toJSON(t) {
                    let e = [],
                        i = t.tracks,
                        s = {
                            name: t.name,
                            duration: t.duration,
                            tracks: e,
                            uuid: t.uuid,
                            blendMode: t.blendMode,
                            userData: JSON.stringify(t.userData)
                        };
                    for (let t = 0, s = i.length; t !== s; ++t) e.push(ak.toJSON(i[t]));
                    return s
                }
                static CreateFromMorphTargetSequence(t, e, i, s) {
                    let r = e.length,
                        n = [];
                    for (let t = 0; t < r; t++) {
                        let a = [],
                            o = [];
                        a.push((t + r - 1) % r, t, (t + 1) % r), o.push(0, 1, 0);
                        let h = function(t) {
                            let e = t.length,
                                i = Array(e);
                            for (let t = 0; t !== e; ++t) i[t] = t;
                            return i.sort(function(e, i) {
                                return t[e] - t[i]
                            }), i
                        }(a);
                        a = a_(a, 1, h), o = a_(o, 1, h), s || 0 !== a[0] || (a.push(r), o.push(o[0])), n.push(new aI(".morphTargetInfluences[" + e[t].name + "]", a, o).scale(1 / i))
                    }
                    return new this(t, -1, n)
                }
                static findByName(t, e) {
                    let i = t;
                    Array.isArray(t) || (i = t.geometry && t.geometry.animations || t.animations);
                    for (let t = 0; t < i.length; t++)
                        if (i[t].name === e) return i[t];
                    return null
                }
                static CreateClipsFromMorphTargetSequences(t, e, i) {
                    let s = {},
                        r = /^([\w-]*?)([\d]+)$/;
                    for (let e = 0, i = t.length; e < i; e++) {
                        let i = t[e],
                            n = i.name.match(r);
                        if (n && n.length > 1) {
                            let t = n[1],
                                e = s[t];
                            e || (s[t] = e = []), e.push(i)
                        }
                    }
                    let n = [];
                    for (let t in s) n.push(this.CreateFromMorphTargetSequence(t, s[t], e, i));
                    return n
                }
                static parseAnimation(t, e) {
                    if (eJ("AnimationClip: parseAnimation() is deprecated and will be removed with r185"), !t) return eq("AnimationClip: No animation in JSONLoader data."), null;
                    let i = function(t, e, i, s, r) {
                            if (0 !== i.length) {
                                let n = [],
                                    a = [];
                                az(i, n, a, s), 0 !== n.length && r.push(new t(e, n, a))
                            }
                        },
                        s = [],
                        r = t.name || "default",
                        n = t.fps || 30,
                        a = t.blendMode,
                        o = t.length || -1,
                        h = t.hierarchy || [];
                    for (let t = 0; t < h.length; t++) {
                        let r = h[t].keys;
                        if (r && 0 !== r.length) {
                            if (r[0].morphTargets) {
                                let t;
                                let e = {};
                                for (t = 0; t < r.length; t++)
                                    if (r[t].morphTargets)
                                        for (let i = 0; i < r[t].morphTargets.length; i++) e[r[t].morphTargets[i]] = -1;
                                for (let i in e) {
                                    let e = [],
                                        n = [];
                                    for (let s = 0; s !== r[t].morphTargets.length; ++s) {
                                        let s = r[t];
                                        e.push(s.time), n.push(s.morphTarget === i ? 1 : 0)
                                    }
                                    s.push(new aI(".morphTargetInfluence[" + i + "]", e, n))
                                }
                                o = e.length * n
                            } else {
                                let n = ".bones[" + e[t].name + "]";
                                i(aL, n + ".position", r, "pos", s), i(aR, n + ".quaternion", r, "rot", s), i(aL, n + ".scale", r, "scl", s)
                            }
                        }
                    }
                    return 0 === s.length ? null : new this(r, o, s, a)
                }
                resetDuration() {
                    let t = this.tracks,
                        e = 0;
                    for (let i = 0, s = t.length; i !== s; ++i) {
                        let t = this.tracks[i];
                        e = Math.max(e, t.times[t.times.length - 1])
                    }
                    return this.duration = e, this
                }
                trim() {
                    for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                    return this
                }
                validate() {
                    let t = !0;
                    for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                    return t
                }
                optimize() {
                    for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                    return this
                }
                clone() {
                    let t = [];
                    for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
                    let e = new this.constructor(this.name, this.duration, t, this.blendMode);
                    return e.userData = JSON.parse(JSON.stringify(this.userData)), e
                }
                toJSON() {
                    return this.constructor.toJSON(this)
                }
            }
            let aF = {
                enabled: !1,
                files: {},
                add: function(t, e) {
                    !1 !== this.enabled && (this.files[t] = e)
                },
                get: function(t) {
                    if (!1 !== this.enabled) return this.files[t]
                },
                remove: function(t) {
                    delete this.files[t]
                }
            };
            class aD {
                constructor(t, e, i) {
                    let s;
                    let r = this,
                        n = !1,
                        a = 0,
                        o = 0,
                        h = [];
                    this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this._abortController = null, this.itemStart = function(t) {
                        o++, !1 === n && void 0 !== r.onStart && r.onStart(t, a, o), n = !0
                    }, this.itemEnd = function(t) {
                        a++, void 0 !== r.onProgress && r.onProgress(t, a, o), a === o && (n = !1, void 0 !== r.onLoad && r.onLoad())
                    }, this.itemError = function(t) {
                        void 0 !== r.onError && r.onError(t)
                    }, this.resolveURL = function(t) {
                        return s ? s(t) : t
                    }, this.setURLModifier = function(t) {
                        return s = t, this
                    }, this.addHandler = function(t, e) {
                        return h.push(t, e), this
                    }, this.removeHandler = function(t) {
                        let e = h.indexOf(t);
                        return -1 !== e && h.splice(e, 2), this
                    }, this.getHandler = function(t) {
                        for (let e = 0, i = h.length; e < i; e += 2) {
                            let i = h[e],
                                s = h[e + 1];
                            if (i.global && (i.lastIndex = 0), i.test(t)) return s
                        }
                        return null
                    }, this.abort = function() {
                        return this.abortController.abort(), this._abortController = null, this
                    }
                }
                get abortController() {
                    return this._abortController || (this._abortController = new AbortController), this._abortController
                }
            }
            let aj = new aD;
            class aU {
                constructor(t) {
                    this.manager = void 0 !== t ? t : aj, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
                }
                load() {}
                loadAsync(t, e) {
                    let i = this;
                    return new Promise(function(s, r) {
                        i.load(t, s, e, r)
                    })
                }
                parse() {}
                setCrossOrigin(t) {
                    return this.crossOrigin = t, this
                }
                setWithCredentials(t) {
                    return this.withCredentials = t, this
                }
                setPath(t) {
                    return this.path = t, this
                }
                setResourcePath(t) {
                    return this.resourcePath = t, this
                }
                setRequestHeader(t) {
                    return this.requestHeader = t, this
                }
                abort() {
                    return this
                }
            }
            aU.DEFAULT_MATERIAL_NAME = "__DEFAULT";
            let aW = {};
            class aJ extends Error {
                constructor(t, e) {
                    super(t), this.response = e
                }
            }
            class aq extends aU {
                constructor(t) {
                    super(t), this.mimeType = "", this.responseType = "", this._abortController = new AbortController
                }
                load(t, e, i, s) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    let r = aF.get(`file:${t}`);
                    if (void 0 !== r) return this.manager.itemStart(t), setTimeout(() => {
                        e && e(r), this.manager.itemEnd(t)
                    }, 0), r;
                    if (void 0 !== aW[t]) {
                        aW[t].push({
                            onLoad: e,
                            onProgress: i,
                            onError: s
                        });
                        return
                    }
                    aW[t] = [], aW[t].push({
                        onLoad: e,
                        onProgress: i,
                        onError: s
                    });
                    let n = new Request(t, {
                            headers: new Headers(this.requestHeader),
                            credentials: this.withCredentials ? "include" : "same-origin",
                            signal: "function" == typeof AbortSignal.any ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal
                        }),
                        a = this.mimeType,
                        o = this.responseType;
                    fetch(n).then(e => {
                        if (200 === e.status || 0 === e.status) {
                            if (0 === e.status && eJ("FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === e.body || void 0 === e.body.getReader) return e;
                            let i = aW[t],
                                s = e.body.getReader(),
                                r = e.headers.get("X-File-Size") || e.headers.get("Content-Length"),
                                n = r ? parseInt(r) : 0,
                                a = 0 !== n,
                                o = 0;
                            return new Response(new ReadableStream({
                                start(t) {
                                    (function e() {
                                        s.read().then(({
                                            done: s,
                                            value: r
                                        }) => {
                                            if (s) t.close();
                                            else {
                                                let s = new ProgressEvent("progress", {
                                                    lengthComputable: a,
                                                    loaded: o += r.byteLength,
                                                    total: n
                                                });
                                                for (let t = 0, e = i.length; t < e; t++) {
                                                    let e = i[t];
                                                    e.onProgress && e.onProgress(s)
                                                }
                                                t.enqueue(r), e()
                                            }
                                        }, e => {
                                            t.error(e)
                                        })
                                    })()
                                }
                            }))
                        }
                        throw new aJ(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`, e)
                    }).then(t => {
                        switch (o) {
                            case "arraybuffer":
                                return t.arrayBuffer();
                            case "blob":
                                return t.blob();
                            case "document":
                                return t.text().then(t => new DOMParser().parseFromString(t, a));
                            case "json":
                                return t.json();
                            default:
                                if ("" === a) return t.text(); {
                                    let e = /charset="?([^;"\s]*)"?/i.exec(a),
                                        i = new TextDecoder(e && e[1] ? e[1].toLowerCase() : void 0);
                                    return t.arrayBuffer().then(t => i.decode(t))
                                }
                        }
                    }).then(e => {
                        aF.add(`file:${t}`, e);
                        let i = aW[t];
                        delete aW[t];
                        for (let t = 0, s = i.length; t < s; t++) {
                            let s = i[t];
                            s.onLoad && s.onLoad(e)
                        }
                    }).catch(e => {
                        let i = aW[t];
                        if (void 0 === i) throw this.manager.itemError(t), e;
                        delete aW[t];
                        for (let t = 0, s = i.length; t < s; t++) {
                            let s = i[t];
                            s.onError && s.onError(e)
                        }
                        this.manager.itemError(t)
                    }).finally(() => {
                        this.manager.itemEnd(t)
                    }), this.manager.itemStart(t)
                }
                setResponseType(t) {
                    return this.responseType = t, this
                }
                setMimeType(t) {
                    return this.mimeType = t, this
                }
                abort() {
                    return this._abortController.abort(), this._abortController = new AbortController, this
                }
            }
            let aZ = new WeakMap;
            class aY extends aU {
                constructor(t) {
                    super(t)
                }
                load(t, e, i, s) {
                    void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    let r = this,
                        n = aF.get(`image:${t}`);
                    if (void 0 !== n) {
                        if (!0 === n.complete) r.manager.itemStart(t), setTimeout(function() {
                            e && e(n), r.manager.itemEnd(t)
                        }, 0);
                        else {
                            let t = aZ.get(n);
                            void 0 === t && (t = [], aZ.set(n, t)), t.push({
                                onLoad: e,
                                onError: s
                            })
                        }
                        return n
                    }
                    let a = eD("img");

                    function o() {
                        l(), e && e(this);
                        let i = aZ.get(this) || [];
                        for (let t = 0; t < i.length; t++) {
                            let e = i[t];
                            e.onLoad && e.onLoad(this)
                        }
                        aZ.delete(this), r.manager.itemEnd(t)
                    }

                    function h(e) {
                        l(), s && s(e), aF.remove(`image:${t}`);
                        let i = aZ.get(this) || [];
                        for (let t = 0; t < i.length; t++) {
                            let s = i[t];
                            s.onError && s.onError(e)
                        }
                        aZ.delete(this), r.manager.itemError(t), r.manager.itemEnd(t)
                    }

                    function l() {
                        a.removeEventListener("load", o, !1), a.removeEventListener("error", h, !1)
                    }
                    return a.addEventListener("load", o, !1), a.addEventListener("error", h, !1), "data:" !== t.slice(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), aF.add(`image:${t}`, a), r.manager.itemStart(t), a.src = t, a
                }
            }
            class aX extends aU {
                constructor(t) {
                    super(t)
                }
                load(t, e, i, s) {
                    let r = new iy,
                        n = new aY(this.manager);
                    return n.setCrossOrigin(this.crossOrigin), n.setPath(this.path), n.load(t, function(t) {
                        r.image = t, r.needsUpdate = !0, void 0 !== e && e(r)
                    }, i, s), r
                }
            }
            class aG extends sp {
                constructor(t, e = 1) {
                    super(), this.isLight = !0, this.type = "Light", this.color = new sB(t), this.intensity = e
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                copy(t, e) {
                    return super.copy(t, e), this.color.copy(t.color), this.intensity = t.intensity, this
                }
                toJSON(t) {
                    let e = super.toJSON(t);
                    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, e
                }
            }
            let aH = new iG,
                aQ = new e9,
                a$ = new e9;
            class aK {
                constructor(t) {
                    this.camera = t, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new e6(512, 512), this.mapType = tw, this.map = null, this.mapPass = null, this.matrix = new iG, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new rK, this._frameExtents = new e6(1, 1), this._viewportCount = 1, this._viewports = [new ig(0, 0, 1, 1)]
                }
                getViewportCount() {
                    return this._viewportCount
                }
                getFrustum() {
                    return this._frustum
                }
                updateMatrices(t) {
                    let e = this.camera,
                        i = this.matrix;
                    aQ.setFromMatrixPosition(t.matrixWorld), e.position.copy(aQ), a$.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(a$), e.updateMatrixWorld(), aH.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(aH, e.coordinateSystem, e.reversedDepth), e.reversedDepth ? i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, 1, 0, 0, 0, 0, 1) : i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), i.multiply(aH)
                }
                getViewport(t) {
                    return this._viewports[t]
                }
                getFrameExtents() {
                    return this._frameExtents
                }
                dispose() {
                    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
                }
                copy(t) {
                    return this.camera = t.camera.clone(), this.intensity = t.intensity, this.bias = t.bias, this.radius = t.radius, this.autoUpdate = t.autoUpdate, this.needsUpdate = t.needsUpdate, this.normalBias = t.normalBias, this.blurSamples = t.blurSamples, this.mapSize.copy(t.mapSize), this
                }
                clone() {
                    return new this.constructor().copy(this)
                }
                toJSON() {
                    let t = {};
                    return 1 !== this.intensity && (t.intensity = this.intensity), 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), (512 !== this.mapSize.x || 512 !== this.mapSize.y) && (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
                }
            }
            class a0 extends aK {
                constructor() {
                    super(new ru(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1, this.aspect = 1
                }
                updateMatrices(t) {
                    let e = this.camera,
                        i = 2 * e$ * t.angle * this.focus,
                        s = this.mapSize.width / this.mapSize.height * this.aspect,
                        r = t.distance || e.far;
                    (i !== e.fov || s !== e.aspect || r !== e.far) && (e.fov = i, e.aspect = s, e.far = r, e.updateProjectionMatrix()), super.updateMatrices(t)
                }
                copy(t) {
                    return super.copy(t), this.focus = t.focus, this
                }
            }
            class a1 extends aG {
                constructor(t, e, i = 0, s = Math.PI / 3, r = 0, n = 2) {
                    super(t, e), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(sp.DEFAULT_UP), this.updateMatrix(), this.target = new sp, this.distance = i, this.angle = s, this.penumbra = r, this.decay = n, this.map = null, this.shadow = new a0
                }
                get power() {
                    return this.intensity * Math.PI
                }
                set power(t) {
                    this.intensity = t / Math.PI
                }
                dispose() {
                    super.dispose(), this.shadow.dispose()
                }
                copy(t, e) {
                    return super.copy(t, e), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.map = t.map, this.shadow = t.shadow.clone(), this
                }
                toJSON(t) {
                    let e = super.toJSON(t);
                    return e.object.distance = this.distance, e.object.angle = this.angle, e.object.decay = this.decay, e.object.penumbra = this.penumbra, e.object.target = this.target.uuid, this.map && this.map.isTexture && (e.object.map = this.map.toJSON(t).uuid), e.object.shadow = this.shadow.toJSON(), e
                }
            }
            class a2 extends aK {
                constructor() {
                    super(new ru(90, 1, .5, 500)), this.isPointLightShadow = !0
                }
            }
            class a3 extends aG {
                constructor(t, e, i = 0, s = 2) {
                    super(t, e), this.isPointLight = !0, this.type = "PointLight", this.distance = i, this.decay = s, this.shadow = new a2
                }
                get power() {
                    return 4 * this.intensity * Math.PI
                }
                set power(t) {
                    this.intensity = t / (4 * Math.PI)
                }
                dispose() {
                    super.dispose(), this.shadow.dispose()
                }
                copy(t, e) {
                    return super.copy(t, e), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
                }
                toJSON(t) {
                    let e = super.toJSON(t);
                    return e.object.distance = this.distance, e.object.decay = this.decay, e.object.shadow = this.shadow.toJSON(), e
                }
            }
            class a5 extends ra {
                constructor(t = -1, e = 1, i = 1, s = -1, r = .1, n = 2e3) {
                    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = i, this.bottom = s, this.near = r, this.far = n, this.updateProjectionMatrix()
                }
                copy(t, e) {
                    return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
                }
                setViewOffset(t, e, i, s, r, n) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = s, this.view.width = r, this.view.height = n, this.updateProjectionMatrix()
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                }
                updateProjectionMatrix() {
                    let t = (this.right - this.left) / (2 * this.zoom),
                        e = (this.top - this.bottom) / (2 * this.zoom),
                        i = (this.right + this.left) / 2,
                        s = (this.top + this.bottom) / 2,
                        r = i - t,
                        n = i + t,
                        a = s + e,
                        o = s - e;
                    if (null !== this.view && this.view.enabled) {
                        let t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                            e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                        r += t * this.view.offsetX, n = r + t * this.view.width, a -= e * this.view.offsetY, o = a - e * this.view.height
                    }
                    this.projectionMatrix.makeOrthographic(r, n, a, o, this.near, this.far, this.coordinateSystem, this.reversedDepth), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                }
                toJSON(t) {
                    let e = super.toJSON(t);
                    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
                }
            }
            class a4 extends aK {
                constructor() {
                    super(new a5(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
                }
            }
            class a6 extends aG {
                constructor(t, e) {
                    super(t, e), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(sp.DEFAULT_UP), this.updateMatrix(), this.target = new sp, this.shadow = new a4
                }
                dispose() {
                    super.dispose(), this.shadow.dispose()
                }
                copy(t) {
                    return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                }
                toJSON(t) {
                    let e = super.toJSON(t);
                    return e.object.shadow = this.shadow.toJSON(), e.object.target = this.target.uuid, e
                }
            }
            class a7 extends aG {
                constructor(t, e) {
                    super(t, e), this.isAmbientLight = !0, this.type = "AmbientLight"
                }
            }
            class a9 {
                static extractUrlBase(t) {
                    let e = t.lastIndexOf("/");
                    return -1 === e ? "./" : t.slice(0, e + 1)
                }
                static resolveURL(t, e) {
                    return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t)) ? t : e + t
                }
            }
            let a8 = new WeakMap;
            class ot extends aU {
                constructor(t) {
                    super(t), this.isImageBitmapLoader = !0, "undefined" == typeof createImageBitmap && eJ("ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && eJ("ImageBitmapLoader: fetch() not supported."), this.options = {
                        premultiplyAlpha: "none"
                    }, this._abortController = new AbortController
                }
                setOptions(t) {
                    return this.options = t, this
                }
                load(t, e, i, s) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    let r = this,
                        n = aF.get(`image-bitmap:${t}`);
                    if (void 0 !== n) {
                        if (r.manager.itemStart(t), n.then) {
                            n.then(i => {
                                if (!0 !== a8.has(n)) return e && e(i), r.manager.itemEnd(t), i;
                                s && s(a8.get(n)), r.manager.itemError(t), r.manager.itemEnd(t)
                            });
                            return
                        }
                        return setTimeout(function() {
                            e && e(n), r.manager.itemEnd(t)
                        }, 0), n
                    }
                    let a = {};
                    a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", a.headers = this.requestHeader, a.signal = "function" == typeof AbortSignal.any ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal;
                    let o = fetch(t, a).then(function(t) {
                        return t.blob()
                    }).then(function(t) {
                        return createImageBitmap(t, Object.assign(r.options, {
                            colorSpaceConversion: "none"
                        }))
                    }).then(function(i) {
                        return aF.add(`image-bitmap:${t}`, i), e && e(i), r.manager.itemEnd(t), i
                    }).catch(function(e) {
                        s && s(e), a8.set(o, e), aF.remove(`image-bitmap:${t}`), r.manager.itemError(t), r.manager.itemEnd(t)
                    });
                    aF.add(`image-bitmap:${t}`, o), r.manager.itemStart(t)
                }
                abort() {
                    return this._abortController.abort(), this._abortController = new AbortController, this
                }
            }
            class oe extends ru {
                constructor(t = []) {
                    super(), this.isArrayCamera = !0, this.isMultiViewCamera = !1, this.cameras = t
                }
            }
            class oi {
                constructor(t = !0) {
                    this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
                }
                start() {
                    this.startTime = performance.now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                }
                stop() {
                    this.getElapsedTime(), this.running = !1, this.autoStart = !1
                }
                getElapsedTime() {
                    return this.getDelta(), this.elapsedTime
                }
                getDelta() {
                    let t = 0;
                    if (this.autoStart && !this.running) return this.start(), 0;
                    if (this.running) {
                        let e = performance.now();
                        t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                    }
                    return t
                }
            }
            let os = "\\[\\]\\.:\\/",
                or = RegExp("[" + os + "]", "g"),
                on = "[^" + os + "]",
                oa = "[^" + os.replace("\\.", "") + "]",
                oo = /((?:WC+[\/:])*)/.source.replace("WC", on),
                oh = RegExp("^" + oo + /(WCOD+)?/.source.replace("WCOD", oa) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", on) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", on) + "$"),
                ol = ["material", "materials", "bones", "map"];
            class ou {
                constructor(t, e, i) {
                    let s = i || oc.parseTrackName(e);
                    this._targetGroup = t, this._bindings = t.subscribe_(e, s)
                }
                getValue(t, e) {
                    this.bind();
                    let i = this._targetGroup.nCachedObjects_,
                        s = this._bindings[i];
                    void 0 !== s && s.getValue(t, e)
                }
                setValue(t, e) {
                    let i = this._bindings;
                    for (let s = this._targetGroup.nCachedObjects_, r = i.length; s !== r; ++s) i[s].setValue(t, e)
                }
                bind() {
                    let t = this._bindings;
                    for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].bind()
                }
                unbind() {
                    let t = this._bindings;
                    for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].unbind()
                }
            }
            class oc {
                constructor(t, e, i) {
                    this.path = e, this.parsedPath = i || oc.parseTrackName(e), this.node = oc.findNode(t, this.parsedPath.nodeName), this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
                static create(t, e, i) {
                    return t && t.isAnimationObjectGroup ? new oc.Composite(t, e, i) : new oc(t, e, i)
                }
                static sanitizeNodeName(t) {
                    return t.replace(/\s/g, "_").replace(or, "")
                }
                static parseTrackName(t) {
                    let e = oh.exec(t);
                    if (null === e) throw Error("PropertyBinding: Cannot parse trackName: " + t);
                    let i = {
                            nodeName: e[2],
                            objectName: e[3],
                            objectIndex: e[4],
                            propertyName: e[5],
                            propertyIndex: e[6]
                        },
                        s = i.nodeName && i.nodeName.lastIndexOf(".");
                    if (void 0 !== s && -1 !== s) {
                        let t = i.nodeName.substring(s + 1); - 1 !== ol.indexOf(t) && (i.nodeName = i.nodeName.substring(0, s), i.objectName = t)
                    }
                    if (null === i.propertyName || 0 === i.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                    return i
                }
                static findNode(t, e) {
                    if (void 0 === e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                    if (t.skeleton) {
                        let i = t.skeleton.getBoneByName(e);
                        if (void 0 !== i) return i
                    }
                    if (t.children) {
                        let i = function(t) {
                                for (let s = 0; s < t.length; s++) {
                                    let r = t[s];
                                    if (r.name === e || r.uuid === e) return r;
                                    let n = i(r.children);
                                    if (n) return n
                                }
                                return null
                            },
                            s = i(t.children);
                        if (s) return s
                    }
                    return null
                }
                _getValue_unavailable() {}
                _setValue_unavailable() {}
                _getValue_direct(t, e) {
                    t[e] = this.targetObject[this.propertyName]
                }
                _getValue_array(t, e) {
                    let i = this.resolvedProperty;
                    for (let s = 0, r = i.length; s !== r; ++s) t[e++] = i[s]
                }
                _getValue_arrayElement(t, e) {
                    t[e] = this.resolvedProperty[this.propertyIndex]
                }
                _getValue_toArray(t, e) {
                    this.resolvedProperty.toArray(t, e)
                }
                _setValue_direct(t, e) {
                    this.targetObject[this.propertyName] = t[e]
                }
                _setValue_direct_setNeedsUpdate(t, e) {
                    this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                }
                _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
                    this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_array(t, e) {
                    let i = this.resolvedProperty;
                    for (let s = 0, r = i.length; s !== r; ++s) i[s] = t[e++]
                }
                _setValue_array_setNeedsUpdate(t, e) {
                    let i = this.resolvedProperty;
                    for (let s = 0, r = i.length; s !== r; ++s) i[s] = t[e++];
                    this.targetObject.needsUpdate = !0
                }
                _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                    let i = this.resolvedProperty;
                    for (let s = 0, r = i.length; s !== r; ++s) i[s] = t[e++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_arrayElement(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e]
                }
                _setValue_arrayElement_setNeedsUpdate(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                }
                _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_fromArray(t, e) {
                    this.resolvedProperty.fromArray(t, e)
                }
                _setValue_fromArray_setNeedsUpdate(t, e) {
                    this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                }
                _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
                    this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _getValue_unbound(t, e) {
                    this.bind(), this.getValue(t, e)
                }
                _setValue_unbound(t, e) {
                    this.bind(), this.setValue(t, e)
                }
                bind() {
                    let t = this.node,
                        e = this.parsedPath,
                        i = e.objectName,
                        s = e.propertyName,
                        r = e.propertyIndex;
                    if (t || (t = oc.findNode(this.rootNode, e.nodeName), this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) {
                        eJ("PropertyBinding: No target node found for track: " + this.path + ".");
                        return
                    }
                    if (i) {
                        let s = e.objectIndex;
                        switch (i) {
                            case "materials":
                                if (!t.material) {
                                    eq("PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    return
                                }
                                if (!t.material.materials) {
                                    eq("PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                    return
                                }
                                t = t.material.materials;
                                break;
                            case "bones":
                                if (!t.skeleton) {
                                    eq("PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                    return
                                }
                                t = t.skeleton.bones;
                                for (let e = 0; e < t.length; e++)
                                    if (t[e].name === s) {
                                        s = e;
                                        break
                                    }
                                break;
                            case "map":
                                if ("map" in t) {
                                    t = t.map;
                                    break
                                }
                                if (!t.material) {
                                    eq("PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    return
                                }
                                if (!t.material.map) {
                                    eq("PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                                    return
                                }
                                t = t.material.map;
                                break;
                            default:
                                if (void 0 === t[i]) {
                                    eq("PropertyBinding: Can not bind to objectName of node undefined.", this);
                                    return
                                }
                                t = t[i]
                        }
                        if (void 0 !== s) {
                            if (void 0 === t[s]) {
                                eq("PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                                return
                            }
                            t = t[s]
                        }
                    }
                    let n = t[s];
                    if (void 0 === n) {
                        eq("PropertyBinding: Trying to update property for track: " + e.nodeName + "." + s + " but it wasn't found.", t);
                        return
                    }
                    let a = this.Versioning.None;
                    this.targetObject = t, !0 === t.isMaterial ? a = this.Versioning.NeedsUpdate : !0 === t.isObject3D && (a = this.Versioning.MatrixWorldNeedsUpdate);
                    let o = this.BindingType.Direct;
                    if (void 0 !== r) {
                        if ("morphTargetInfluences" === s) {
                            if (!t.geometry) {
                                eq("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                return
                            }
                            if (!t.geometry.morphAttributes) {
                                eq("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                return
                            }
                            void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                        }
                        o = this.BindingType.ArrayElement, this.resolvedProperty = n, this.propertyIndex = r
                    } else void 0 !== n.fromArray && void 0 !== n.toArray ? (o = this.BindingType.HasFromToArray, this.resolvedProperty = n) : Array.isArray(n) ? (o = this.BindingType.EntireArray, this.resolvedProperty = n) : this.propertyName = s;
                    this.getValue = this.GetterByBindingType[o], this.setValue = this.SetterByBindingTypeAndVersioning[o][a]
                }
                unbind() {
                    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
            }
            oc.Composite = ou, oc.prototype.BindingType = {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            }, oc.prototype.Versioning = {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            }, oc.prototype.GetterByBindingType = [oc.prototype._getValue_direct, oc.prototype._getValue_array, oc.prototype._getValue_arrayElement, oc.prototype._getValue_toArray], oc.prototype.SetterByBindingTypeAndVersioning = [
                [oc.prototype._setValue_direct, oc.prototype._setValue_direct_setNeedsUpdate, oc.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
                [oc.prototype._setValue_array, oc.prototype._setValue_array_setNeedsUpdate, oc.prototype._setValue_array_setMatrixWorldNeedsUpdate],
                [oc.prototype._setValue_arrayElement, oc.prototype._setValue_arrayElement_setNeedsUpdate, oc.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
                [oc.prototype._setValue_fromArray, oc.prototype._setValue_fromArray_setNeedsUpdate, oc.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
            ], new Float32Array(1);
            let op = new iG;
            class od {
                constructor(t, e, i = 0, s = 1 / 0) {
                    this.ray = new iX(t, e), this.near = i, this.far = s, this.camera = null, this.layers = new i6, this.params = {
                        Mesh: {},
                        Line: {
                            threshold: 1
                        },
                        LOD: {},
                        Points: {
                            threshold: 1
                        },
                        Sprite: {}
                    }
                }
                set(t, e) {
                    this.ray.set(t, e)
                }
                setFromCamera(t, e) {
                    e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : eq("Raycaster: Unsupported camera type: " + e.type)
                }
                setFromXRController(t) {
                    return op.identity().extractRotation(t.matrixWorld), this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(op), this
                }
                intersectObject(t, e = !0, i = []) {
                    return oy(t, this, i, e), i.sort(om), i
                }
                intersectObjects(t, e = !0, i = []) {
                    for (let s = 0, r = t.length; s < r; s++) oy(t[s], this, i, e);
                    return i.sort(om), i
                }
            }

            function om(t, e) {
                return t.distance - e.distance
            }

            function oy(t, e, i, s) {
                let r = !0;
                if (t.layers.test(e.layers) && !1 === t.raycast(e, i) && (r = !1), !0 === r && !0 === s) {
                    let s = t.children;
                    for (let t = 0, r = s.length; t < r; t++) oy(s[t], e, i, !0)
                }
            }
            class of {
                constructor(t = 1, e = 0, i = 0) {
                    this.radius = t, this.phi = e, this.theta = i
                }
                set(t, e, i) {
                    return this.radius = t, this.phi = e, this.theta = i, this
                }
                copy(t) {
                    return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
                }
                makeSafe() {
                    return this.phi = e0(this.phi, 1e-6, Math.PI - 1e-6), this
                }
                setFromVector3(t) {
                    return this.setFromCartesianCoords(t.x, t.y, t.z)
                }
                setFromCartesianCoords(t, e, i) {
                    return this.radius = Math.sqrt(t * t + e * e + i * i), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, i), this.phi = Math.acos(e0(e / this.radius, -1, 1))), this
                }
                clone() {
                    return new this.constructor().copy(this)
                }
            }
            class og extends eX {
                constructor(t, e = null) {
                    super(), this.object = t, this.domElement = e, this.enabled = !0, this.state = -1, this.keys = {}, this.mouseButtons = {
                        LEFT: null,
                        MIDDLE: null,
                        RIGHT: null
                    }, this.touches = {
                        ONE: null,
                        TWO: null
                    }
                }
                connect(t) {
                    if (void 0 === t) {
                        eJ("Controls: connect() now requires an element.");
                        return
                    }
                    null !== this.domElement && this.disconnect(), this.domElement = t
                }
                disconnect() {}
                dispose() {}
                update() {}
            }

            function ox(t, e, i, s) {
                let r = function(t) {
                    switch (t) {
                        case tw:
                        case tS:
                            return {
                                byteLength: 1,
                                components: 1
                            };
                        case tz:
                        case t_:
                        case tO:
                            return {
                                byteLength: 2,
                                components: 1
                            };
                        case tk:
                        case tB:
                            return {
                                byteLength: 2,
                                components: 4
                            };
                        case tT:
                        case tA:
                        case tC:
                            return {
                                byteLength: 4,
                                components: 1
                            };
                        case tI:
                        case tP:
                            return {
                                byteLength: 4,
                                components: 3
                            }
                    }
                    throw Error(`Unknown texture type ${t}.`)
                }(s);
                switch (i) {
                    case tR:
                        return t * e;
                    case tD:
                    case tj:
                        return t * e / r.components * r.byteLength;
                    case tU:
                    case tW:
                        return t * e * 2 / r.components * r.byteLength;
                    case tV:
                        return t * e * 3 / r.components * r.byteLength;
                    case tL:
                    case tJ:
                        return t * e * 4 / r.components * r.byteLength;
                    case tq:
                    case tZ:
                        return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 8;
                    case tY:
                    case tX:
                        return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 16;
                    case tH:
                    case t$:
                        return Math.max(t, 16) * Math.max(e, 8) / 4;
                    case tG:
                    case tQ:
                        return Math.max(t, 8) * Math.max(e, 8) / 2;
                    case tK:
                    case t0:
                    case t2:
                    case t3:
                        return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 8;
                    case t1:
                    case t5:
                    case t4:
                    case t6:
                        return Math.floor((t + 3) / 4) * Math.floor((e + 3) / 4) * 16;
                    case t7:
                        return Math.floor((t + 4) / 5) * Math.floor((e + 3) / 4) * 16;
                    case t9:
                        return Math.floor((t + 4) / 5) * Math.floor((e + 4) / 5) * 16;
                    case t8:
                        return Math.floor((t + 5) / 6) * Math.floor((e + 4) / 5) * 16;
                    case et:
                        return Math.floor((t + 5) / 6) * Math.floor((e + 5) / 6) * 16;
                    case ee:
                        return Math.floor((t + 7) / 8) * Math.floor((e + 4) / 5) * 16;
                    case ei:
                        return Math.floor((t + 7) / 8) * Math.floor((e + 5) / 6) * 16;
                    case es:
                        return Math.floor((t + 7) / 8) * Math.floor((e + 7) / 8) * 16;
                    case er:
                        return Math.floor((t + 9) / 10) * Math.floor((e + 4) / 5) * 16;
                    case en:
                        return Math.floor((t + 9) / 10) * Math.floor((e + 5) / 6) * 16;
                    case ea:
                        return Math.floor((t + 9) / 10) * Math.floor((e + 7) / 8) * 16;
                    case eo:
                        return Math.floor((t + 9) / 10) * Math.floor((e + 9) / 10) * 16;
                    case eh:
                        return Math.floor((t + 11) / 12) * Math.floor((e + 9) / 10) * 16;
                    case el:
                        return Math.floor((t + 11) / 12) * Math.floor((e + 11) / 12) * 16;
                    case eu:
                    case ec:
                    case ep:
                        return Math.ceil(t / 4) * Math.ceil(e / 4) * 16;
                    case ed:
                    case em:
                        return Math.ceil(t / 4) * Math.ceil(e / 4) * 8;
                    case ey:
                    case ef:
                        return Math.ceil(t / 4) * Math.ceil(e / 4) * 16
                }
                throw Error(`Unable to determine texture byte length for ${i} format.`)
            }
            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                detail: {
                    revision: r
                }
            })), "undefined" != typeof window && (window.__THREE__ ? eJ("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = r)
        }
    }
]);